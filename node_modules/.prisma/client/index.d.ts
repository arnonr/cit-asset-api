
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type news_typePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "news_type"
  objects: {
    news: newsPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name_th: string
    name_en: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["news_type"]>
  composites: {}
}

/**
 * Model news_type
 * 
 */
export type news_type = runtime.Types.DefaultSelection<news_typePayload>
export type newsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "news"
  objects: {
    news_type: news_typePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    news_type_id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    news_file: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_news: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["news"]>
  composites: {}
}

/**
 * Model news
 * 
 */
export type news = runtime.Types.DefaultSelection<newsPayload>
export type bannerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "banner"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    title_th: string
    title_en: string | null
    banner_file: string | null
    banner_url: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_banner: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["banner"]>
  composites: {}
}

/**
 * Model banner
 * 
 */
export type banner = runtime.Types.DefaultSelection<bannerPayload>
export type aboutPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "about"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_about: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["about"]>
  composites: {}
}

/**
 * Model about
 * 
 */
export type about = runtime.Types.DefaultSelection<aboutPayload>
export type contactPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "contact"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_contact: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["contact"]>
  composites: {}
}

/**
 * Model contact
 * 
 */
export type contact = runtime.Types.DefaultSelection<contactPayload>
export type departmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "department"
  objects: {
    team: teamPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name_th: string
    name_en: string | null
    level: number
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["department"]>
  composites: {}
}

/**
 * Model department
 * 
 */
export type department = runtime.Types.DefaultSelection<departmentPayload>
export type teamPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "team"
  objects: {
    department: departmentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    department_id: number
    prefix_th: string | null
    prefix_en: string | null
    firstname_th: string | null
    firstname_en: string | null
    surname_th: string | null
    surname_en: string | null
    position_th: string | null
    position_en: string | null
    position_level_th: string | null
    position_level_en: string | null
    phone: string
    email: string
    level: number
    team_file: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["team"]>
  composites: {}
}

/**
 * Model team
 * 
 */
export type team = runtime.Types.DefaultSelection<teamPayload>
export type news_galleryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "news_gallery"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    news_id: number | null
    secret_key: string
    news_gallery_file: string
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["news_gallery"]>
  composites: {}
}

/**
 * Model news_gallery
 * 
 */
export type news_gallery = runtime.Types.DefaultSelection<news_galleryPayload>
export type equipment_departmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment_department"
  objects: {
    equipments: equipmentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name_th: string | null
    name_en: string | null
    name_short: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["equipment_department"]>
  composites: {}
}

/**
 * Model equipment_department
 * 
 */
export type equipment_department = runtime.Types.DefaultSelection<equipment_departmentPayload>
export type equipment_categoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment_category"
  objects: {
    equipments: equipmentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name_th: string
    name_en: string | null
    name_short: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["equipment_category"]>
  composites: {}
}

/**
 * Model equipment_category
 * 
 */
export type equipment_category = runtime.Types.DefaultSelection<equipment_categoryPayload>
export type equipmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment"
  objects: {
    equipment_category: equipment_categoryPayload<ExtArgs>
    equipment_department: equipment_departmentPayload<ExtArgs>
    equipment_method: equipment_methodPayload<ExtArgs>[]
    equipment_booking: equipment_bookingPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    equipment_file: string | null
    rate_file: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_equipment: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["equipment"]>
  composites: {}
}

/**
 * Model equipment
 * 
 */
export type equipment = runtime.Types.DefaultSelection<equipmentPayload>
export type equipment_galleryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment_gallery"
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    equipment_id: number | null
    secret_key: string
    equipment_gallery_file: string
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["equipment_gallery"]>
  composites: {}
}

/**
 * Model equipment_gallery
 * 
 */
export type equipment_gallery = runtime.Types.DefaultSelection<equipment_galleryPayload>
export type equipment_methodPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment_method"
  objects: {
    equipment: equipmentPayload<ExtArgs>
    equipment_booking_method: equipment_booking_methodPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    name_th: string
    name_en: string | null
    name_short: string | null
    unit_th: string | null
    unit_en: string | null
    price: number | null
    is_fixrate: number | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    equipment_id: number
  }, ExtArgs["result"]["equipment_method"]>
  composites: {}
}

/**
 * Model equipment_method
 * 
 */
export type equipment_method = runtime.Types.DefaultSelection<equipment_methodPayload>
export type groupPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "group"
  objects: {
    users: userPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    title_th: string
    title_en: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["group"]>
  composites: {}
}

/**
 * Model group
 * 
 */
export type group = runtime.Types.DefaultSelection<groupPayload>
export type userPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "user"
  objects: {
    group: groupPayload<ExtArgs>
    profile: profilePayload<ExtArgs> | null
    equipment_booking: equipment_bookingPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    group_id: number
    email: string
    secret_confirm_email: string | null
    password: string | null
    status: number
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model user
 * 
 */
export type user = runtime.Types.DefaultSelection<userPayload>
export type profilePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "profile"
  objects: {
    user: userPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    user_id: number
    prefix: string | null
    firstname: string | null
    surname: string | null
    member_status: number
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_name: string | null
    invoice_address: string | null
    tax_id: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["profile"]>
  composites: {}
}

/**
 * Model profile
 * 
 */
export type profile = runtime.Types.DefaultSelection<profilePayload>
export type equipment_bookingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment_booking"
  objects: {
    user: userPayload<ExtArgs>
    equipment: equipmentPayload<ExtArgs>
    equipment_booking_method: equipment_booking_methodPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    user_id: number
    equipment_id: number
    booking_date: Date
    period_time: number
    member_status: number
    example: string | null
    prefix: string | null
    firstname: string | null
    surname: string | null
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_address: string | null
    tax_id: string | null
    price: number | null
    reject_comment: string | null
    confirmed_date: Date | null
    status_id: number
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["equipment_booking"]>
  composites: {}
}

/**
 * Model equipment_booking
 * 
 */
export type equipment_booking = runtime.Types.DefaultSelection<equipment_bookingPayload>
export type equipment_booking_methodPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "equipment_booking_method"
  objects: {
    equipment_booking: equipment_bookingPayload<ExtArgs>
    equipment_method: equipment_methodPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    equipment_booking_id: number
    equipment_method_id: number
    quantity: number | null
    price: number | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }, ExtArgs["result"]["equipment_booking_method"]>
  composites: {}
}

/**
 * Model equipment_booking_method
 * 
 */
export type equipment_booking_method = runtime.Types.DefaultSelection<equipment_booking_methodPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more News_types
 * const news_types = await prisma.news_type.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more News_types
   * const news_types = await prisma.news_type.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.news_type`: Exposes CRUD operations for the **news_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News_types
    * const news_types = await prisma.news_type.findMany()
    * ```
    */
  get news_type(): Prisma.news_typeDelegate<ExtArgs>;

  /**
   * `prisma.news`: Exposes CRUD operations for the **news** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News
    * const news = await prisma.news.findMany()
    * ```
    */
  get news(): Prisma.newsDelegate<ExtArgs>;

  /**
   * `prisma.banner`: Exposes CRUD operations for the **banner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Banners
    * const banners = await prisma.banner.findMany()
    * ```
    */
  get banner(): Prisma.bannerDelegate<ExtArgs>;

  /**
   * `prisma.about`: Exposes CRUD operations for the **about** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abouts
    * const abouts = await prisma.about.findMany()
    * ```
    */
  get about(): Prisma.aboutDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.contactDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.departmentDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<ExtArgs>;

  /**
   * `prisma.news_gallery`: Exposes CRUD operations for the **news_gallery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more News_galleries
    * const news_galleries = await prisma.news_gallery.findMany()
    * ```
    */
  get news_gallery(): Prisma.news_galleryDelegate<ExtArgs>;

  /**
   * `prisma.equipment_department`: Exposes CRUD operations for the **equipment_department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment_departments
    * const equipment_departments = await prisma.equipment_department.findMany()
    * ```
    */
  get equipment_department(): Prisma.equipment_departmentDelegate<ExtArgs>;

  /**
   * `prisma.equipment_category`: Exposes CRUD operations for the **equipment_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment_categories
    * const equipment_categories = await prisma.equipment_category.findMany()
    * ```
    */
  get equipment_category(): Prisma.equipment_categoryDelegate<ExtArgs>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.equipmentDelegate<ExtArgs>;

  /**
   * `prisma.equipment_gallery`: Exposes CRUD operations for the **equipment_gallery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment_galleries
    * const equipment_galleries = await prisma.equipment_gallery.findMany()
    * ```
    */
  get equipment_gallery(): Prisma.equipment_galleryDelegate<ExtArgs>;

  /**
   * `prisma.equipment_method`: Exposes CRUD operations for the **equipment_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment_methods
    * const equipment_methods = await prisma.equipment_method.findMany()
    * ```
    */
  get equipment_method(): Prisma.equipment_methodDelegate<ExtArgs>;

  /**
   * `prisma.group`: Exposes CRUD operations for the **group** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.group.findMany()
    * ```
    */
  get group(): Prisma.groupDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<ExtArgs>;

  /**
   * `prisma.equipment_booking`: Exposes CRUD operations for the **equipment_booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment_bookings
    * const equipment_bookings = await prisma.equipment_booking.findMany()
    * ```
    */
  get equipment_booking(): Prisma.equipment_bookingDelegate<ExtArgs>;

  /**
   * `prisma.equipment_booking_method`: Exposes CRUD operations for the **equipment_booking_method** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment_booking_methods
    * const equipment_booking_methods = await prisma.equipment_booking_method.findMany()
    * ```
    */
  get equipment_booking_method(): Prisma.equipment_booking_methodDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    news_type: 'news_type',
    news: 'news',
    banner: 'banner',
    about: 'about',
    contact: 'contact',
    department: 'department',
    team: 'team',
    news_gallery: 'news_gallery',
    equipment_department: 'equipment_department',
    equipment_category: 'equipment_category',
    equipment: 'equipment',
    equipment_gallery: 'equipment_gallery',
    equipment_method: 'equipment_method',
    group: 'group',
    user: 'user',
    profile: 'profile',
    equipment_booking: 'equipment_booking',
    equipment_booking_method: 'equipment_booking_method'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'news_type' | 'news' | 'banner' | 'about' | 'contact' | 'department' | 'team' | 'news_gallery' | 'equipment_department' | 'equipment_category' | 'equipment' | 'equipment_gallery' | 'equipment_method' | 'group' | 'user' | 'profile' | 'equipment_booking' | 'equipment_booking_method'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      news_type: {
        payload: news_typePayload<ExtArgs>
        fields: Prisma.news_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.news_typeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.news_typeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>
          }
          findFirst: {
            args: Prisma.news_typeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.news_typeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>
          }
          findMany: {
            args: Prisma.news_typeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>[]
          }
          create: {
            args: Prisma.news_typeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>
          }
          createMany: {
            args: Prisma.news_typeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.news_typeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>
          }
          update: {
            args: Prisma.news_typeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>
          }
          deleteMany: {
            args: Prisma.news_typeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.news_typeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.news_typeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_typePayload>
          }
          aggregate: {
            args: Prisma.News_typeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNews_type>
          }
          groupBy: {
            args: Prisma.news_typeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<News_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.news_typeCountArgs<ExtArgs>,
            result: $Utils.Optional<News_typeCountAggregateOutputType> | number
          }
        }
      }
      news: {
        payload: newsPayload<ExtArgs>
        fields: Prisma.newsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.newsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.newsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>
          }
          findFirst: {
            args: Prisma.newsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.newsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>
          }
          findMany: {
            args: Prisma.newsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>[]
          }
          create: {
            args: Prisma.newsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>
          }
          createMany: {
            args: Prisma.newsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.newsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>
          }
          update: {
            args: Prisma.newsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>
          }
          deleteMany: {
            args: Prisma.newsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.newsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.newsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<newsPayload>
          }
          aggregate: {
            args: Prisma.NewsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNews>
          }
          groupBy: {
            args: Prisma.newsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.newsCountArgs<ExtArgs>,
            result: $Utils.Optional<NewsCountAggregateOutputType> | number
          }
        }
      }
      banner: {
        payload: bannerPayload<ExtArgs>
        fields: Prisma.bannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bannerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bannerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>
          }
          findFirst: {
            args: Prisma.bannerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bannerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>
          }
          findMany: {
            args: Prisma.bannerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>[]
          }
          create: {
            args: Prisma.bannerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>
          }
          createMany: {
            args: Prisma.bannerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bannerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>
          }
          update: {
            args: Prisma.bannerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>
          }
          deleteMany: {
            args: Prisma.bannerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bannerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bannerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<bannerPayload>
          }
          aggregate: {
            args: Prisma.BannerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBanner>
          }
          groupBy: {
            args: Prisma.bannerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.bannerCountArgs<ExtArgs>,
            result: $Utils.Optional<BannerCountAggregateOutputType> | number
          }
        }
      }
      about: {
        payload: aboutPayload<ExtArgs>
        fields: Prisma.aboutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aboutFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aboutFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>
          }
          findFirst: {
            args: Prisma.aboutFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aboutFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>
          }
          findMany: {
            args: Prisma.aboutFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>[]
          }
          create: {
            args: Prisma.aboutCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>
          }
          createMany: {
            args: Prisma.aboutCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.aboutDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>
          }
          update: {
            args: Prisma.aboutUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>
          }
          deleteMany: {
            args: Prisma.aboutDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.aboutUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.aboutUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<aboutPayload>
          }
          aggregate: {
            args: Prisma.AboutAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAbout>
          }
          groupBy: {
            args: Prisma.aboutGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AboutGroupByOutputType>[]
          }
          count: {
            args: Prisma.aboutCountArgs<ExtArgs>,
            result: $Utils.Optional<AboutCountAggregateOutputType> | number
          }
        }
      }
      contact: {
        payload: contactPayload<ExtArgs>
        fields: Prisma.contactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>
          }
          findFirst: {
            args: Prisma.contactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>
          }
          findMany: {
            args: Prisma.contactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>[]
          }
          create: {
            args: Prisma.contactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>
          }
          createMany: {
            args: Prisma.contactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.contactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>
          }
          update: {
            args: Prisma.contactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>
          }
          deleteMany: {
            args: Prisma.contactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.contactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.contactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<contactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.contactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      department: {
        payload: departmentPayload<ExtArgs>
        fields: Prisma.departmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.departmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.departmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>
          }
          findFirst: {
            args: Prisma.departmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.departmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>
          }
          findMany: {
            args: Prisma.departmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>[]
          }
          create: {
            args: Prisma.departmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>
          }
          createMany: {
            args: Prisma.departmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.departmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>
          }
          update: {
            args: Prisma.departmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>
          }
          deleteMany: {
            args: Prisma.departmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.departmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.departmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<departmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.departmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.departmentCountArgs<ExtArgs>,
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      team: {
        payload: teamPayload<ExtArgs>
        fields: Prisma.teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          findFirst: {
            args: Prisma.teamFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          findMany: {
            args: Prisma.teamFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>[]
          }
          create: {
            args: Prisma.teamCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          createMany: {
            args: Prisma.teamCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.teamDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          update: {
            args: Prisma.teamUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          deleteMany: {
            args: Prisma.teamDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.teamUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.teamUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<teamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.teamGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.teamCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      news_gallery: {
        payload: news_galleryPayload<ExtArgs>
        fields: Prisma.news_galleryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.news_galleryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.news_galleryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>
          }
          findFirst: {
            args: Prisma.news_galleryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.news_galleryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>
          }
          findMany: {
            args: Prisma.news_galleryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>[]
          }
          create: {
            args: Prisma.news_galleryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>
          }
          createMany: {
            args: Prisma.news_galleryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.news_galleryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>
          }
          update: {
            args: Prisma.news_galleryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>
          }
          deleteMany: {
            args: Prisma.news_galleryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.news_galleryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.news_galleryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<news_galleryPayload>
          }
          aggregate: {
            args: Prisma.News_galleryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNews_gallery>
          }
          groupBy: {
            args: Prisma.news_galleryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<News_galleryGroupByOutputType>[]
          }
          count: {
            args: Prisma.news_galleryCountArgs<ExtArgs>,
            result: $Utils.Optional<News_galleryCountAggregateOutputType> | number
          }
        }
      }
      equipment_department: {
        payload: equipment_departmentPayload<ExtArgs>
        fields: Prisma.equipment_departmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipment_departmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipment_departmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>
          }
          findFirst: {
            args: Prisma.equipment_departmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipment_departmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>
          }
          findMany: {
            args: Prisma.equipment_departmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>[]
          }
          create: {
            args: Prisma.equipment_departmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>
          }
          createMany: {
            args: Prisma.equipment_departmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipment_departmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>
          }
          update: {
            args: Prisma.equipment_departmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>
          }
          deleteMany: {
            args: Prisma.equipment_departmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipment_departmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipment_departmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_departmentPayload>
          }
          aggregate: {
            args: Prisma.Equipment_departmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment_department>
          }
          groupBy: {
            args: Prisma.equipment_departmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_departmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipment_departmentCountArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_departmentCountAggregateOutputType> | number
          }
        }
      }
      equipment_category: {
        payload: equipment_categoryPayload<ExtArgs>
        fields: Prisma.equipment_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipment_categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipment_categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>
          }
          findFirst: {
            args: Prisma.equipment_categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipment_categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>
          }
          findMany: {
            args: Prisma.equipment_categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>[]
          }
          create: {
            args: Prisma.equipment_categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>
          }
          createMany: {
            args: Prisma.equipment_categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipment_categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>
          }
          update: {
            args: Prisma.equipment_categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>
          }
          deleteMany: {
            args: Prisma.equipment_categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipment_categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipment_categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_categoryPayload>
          }
          aggregate: {
            args: Prisma.Equipment_categoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment_category>
          }
          groupBy: {
            args: Prisma.equipment_categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipment_categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_categoryCountAggregateOutputType> | number
          }
        }
      }
      equipment: {
        payload: equipmentPayload<ExtArgs>
        fields: Prisma.equipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>
          }
          findFirst: {
            args: Prisma.equipmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>
          }
          findMany: {
            args: Prisma.equipmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>[]
          }
          create: {
            args: Prisma.equipmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>
          }
          createMany: {
            args: Prisma.equipmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>
          }
          update: {
            args: Prisma.equipmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>
          }
          deleteMany: {
            args: Prisma.equipmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.equipmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipmentCountArgs<ExtArgs>,
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      equipment_gallery: {
        payload: equipment_galleryPayload<ExtArgs>
        fields: Prisma.equipment_galleryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipment_galleryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipment_galleryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>
          }
          findFirst: {
            args: Prisma.equipment_galleryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipment_galleryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>
          }
          findMany: {
            args: Prisma.equipment_galleryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>[]
          }
          create: {
            args: Prisma.equipment_galleryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>
          }
          createMany: {
            args: Prisma.equipment_galleryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipment_galleryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>
          }
          update: {
            args: Prisma.equipment_galleryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>
          }
          deleteMany: {
            args: Prisma.equipment_galleryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipment_galleryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipment_galleryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_galleryPayload>
          }
          aggregate: {
            args: Prisma.Equipment_galleryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment_gallery>
          }
          groupBy: {
            args: Prisma.equipment_galleryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_galleryGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipment_galleryCountArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_galleryCountAggregateOutputType> | number
          }
        }
      }
      equipment_method: {
        payload: equipment_methodPayload<ExtArgs>
        fields: Prisma.equipment_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipment_methodFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipment_methodFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>
          }
          findFirst: {
            args: Prisma.equipment_methodFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipment_methodFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>
          }
          findMany: {
            args: Prisma.equipment_methodFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>[]
          }
          create: {
            args: Prisma.equipment_methodCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>
          }
          createMany: {
            args: Prisma.equipment_methodCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipment_methodDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>
          }
          update: {
            args: Prisma.equipment_methodUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>
          }
          deleteMany: {
            args: Prisma.equipment_methodDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipment_methodUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipment_methodUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_methodPayload>
          }
          aggregate: {
            args: Prisma.Equipment_methodAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment_method>
          }
          groupBy: {
            args: Prisma.equipment_methodGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipment_methodCountArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_methodCountAggregateOutputType> | number
          }
        }
      }
      group: {
        payload: groupPayload<ExtArgs>
        fields: Prisma.groupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>
          }
          findFirst: {
            args: Prisma.groupFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>
          }
          findMany: {
            args: Prisma.groupFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>[]
          }
          create: {
            args: Prisma.groupCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>
          }
          createMany: {
            args: Prisma.groupCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.groupDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>
          }
          update: {
            args: Prisma.groupUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>
          }
          deleteMany: {
            args: Prisma.groupDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.groupUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.groupUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<groupPayload>
          }
          aggregate: {
            args: Prisma.GroupAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGroup>
          }
          groupBy: {
            args: Prisma.groupGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupCountArgs<ExtArgs>,
            result: $Utils.Optional<GroupCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      profile: {
        payload: profilePayload<ExtArgs>
        fields: Prisma.profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.profileFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.profileFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>
          }
          findFirst: {
            args: Prisma.profileFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.profileFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>
          }
          findMany: {
            args: Prisma.profileFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>[]
          }
          create: {
            args: Prisma.profileCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>
          }
          createMany: {
            args: Prisma.profileCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.profileDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>
          }
          update: {
            args: Prisma.profileUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>
          }
          deleteMany: {
            args: Prisma.profileDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.profileUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.profileUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<profilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.profileGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.profileCountArgs<ExtArgs>,
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      equipment_booking: {
        payload: equipment_bookingPayload<ExtArgs>
        fields: Prisma.equipment_bookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipment_bookingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipment_bookingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>
          }
          findFirst: {
            args: Prisma.equipment_bookingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipment_bookingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>
          }
          findMany: {
            args: Prisma.equipment_bookingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>[]
          }
          create: {
            args: Prisma.equipment_bookingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>
          }
          createMany: {
            args: Prisma.equipment_bookingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipment_bookingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>
          }
          update: {
            args: Prisma.equipment_bookingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>
          }
          deleteMany: {
            args: Prisma.equipment_bookingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipment_bookingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipment_bookingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_bookingPayload>
          }
          aggregate: {
            args: Prisma.Equipment_bookingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment_booking>
          }
          groupBy: {
            args: Prisma.equipment_bookingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_bookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipment_bookingCountArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_bookingCountAggregateOutputType> | number
          }
        }
      }
      equipment_booking_method: {
        payload: equipment_booking_methodPayload<ExtArgs>
        fields: Prisma.equipment_booking_methodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipment_booking_methodFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipment_booking_methodFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>
          }
          findFirst: {
            args: Prisma.equipment_booking_methodFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipment_booking_methodFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>
          }
          findMany: {
            args: Prisma.equipment_booking_methodFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>[]
          }
          create: {
            args: Prisma.equipment_booking_methodCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>
          }
          createMany: {
            args: Prisma.equipment_booking_methodCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.equipment_booking_methodDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>
          }
          update: {
            args: Prisma.equipment_booking_methodUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>
          }
          deleteMany: {
            args: Prisma.equipment_booking_methodDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.equipment_booking_methodUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.equipment_booking_methodUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<equipment_booking_methodPayload>
          }
          aggregate: {
            args: Prisma.Equipment_booking_methodAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEquipment_booking_method>
          }
          groupBy: {
            args: Prisma.equipment_booking_methodGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_booking_methodGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipment_booking_methodCountArgs<ExtArgs>,
            result: $Utils.Optional<Equipment_booking_methodCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type News_typeCountOutputType
   */


  export type News_typeCountOutputType = {
    news: number
  }

  export type News_typeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    news?: boolean | News_typeCountOutputTypeCountNewsArgs
  }

  // Custom InputTypes

  /**
   * News_typeCountOutputType without action
   */
  export type News_typeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the News_typeCountOutputType
     */
    select?: News_typeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * News_typeCountOutputType without action
   */
  export type News_typeCountOutputTypeCountNewsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: newsWhereInput
  }



  /**
   * Count Type DepartmentCountOutputType
   */


  export type DepartmentCountOutputType = {
    team: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team?: boolean | DepartmentCountOutputTypeCountTeamArgs
  }

  // Custom InputTypes

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }



  /**
   * Count Type Equipment_departmentCountOutputType
   */


  export type Equipment_departmentCountOutputType = {
    equipments: number
  }

  export type Equipment_departmentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipments?: boolean | Equipment_departmentCountOutputTypeCountEquipmentsArgs
  }

  // Custom InputTypes

  /**
   * Equipment_departmentCountOutputType without action
   */
  export type Equipment_departmentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment_departmentCountOutputType
     */
    select?: Equipment_departmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Equipment_departmentCountOutputType without action
   */
  export type Equipment_departmentCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipmentWhereInput
  }



  /**
   * Count Type Equipment_categoryCountOutputType
   */


  export type Equipment_categoryCountOutputType = {
    equipments: number
  }

  export type Equipment_categoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipments?: boolean | Equipment_categoryCountOutputTypeCountEquipmentsArgs
  }

  // Custom InputTypes

  /**
   * Equipment_categoryCountOutputType without action
   */
  export type Equipment_categoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment_categoryCountOutputType
     */
    select?: Equipment_categoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Equipment_categoryCountOutputType without action
   */
  export type Equipment_categoryCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipmentWhereInput
  }



  /**
   * Count Type EquipmentCountOutputType
   */


  export type EquipmentCountOutputType = {
    equipment_method: number
    equipment_booking: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment_method?: boolean | EquipmentCountOutputTypeCountEquipment_methodArgs
    equipment_booking?: boolean | EquipmentCountOutputTypeCountEquipment_bookingArgs
  }

  // Custom InputTypes

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEquipment_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_methodWhereInput
  }


  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEquipment_bookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_bookingWhereInput
  }



  /**
   * Count Type Equipment_methodCountOutputType
   */


  export type Equipment_methodCountOutputType = {
    equipment_booking_method: number
  }

  export type Equipment_methodCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment_booking_method?: boolean | Equipment_methodCountOutputTypeCountEquipment_booking_methodArgs
  }

  // Custom InputTypes

  /**
   * Equipment_methodCountOutputType without action
   */
  export type Equipment_methodCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment_methodCountOutputType
     */
    select?: Equipment_methodCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Equipment_methodCountOutputType without action
   */
  export type Equipment_methodCountOutputTypeCountEquipment_booking_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_booking_methodWhereInput
  }



  /**
   * Count Type GroupCountOutputType
   */


  export type GroupCountOutputType = {
    users: number
  }

  export type GroupCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | GroupCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes

  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupCountOutputType
     */
    select?: GroupCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GroupCountOutputType without action
   */
  export type GroupCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    equipment_booking: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment_booking?: boolean | UserCountOutputTypeCountEquipment_bookingArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEquipment_bookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_bookingWhereInput
  }



  /**
   * Count Type Equipment_bookingCountOutputType
   */


  export type Equipment_bookingCountOutputType = {
    equipment_booking_method: number
  }

  export type Equipment_bookingCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment_booking_method?: boolean | Equipment_bookingCountOutputTypeCountEquipment_booking_methodArgs
  }

  // Custom InputTypes

  /**
   * Equipment_bookingCountOutputType without action
   */
  export type Equipment_bookingCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment_bookingCountOutputType
     */
    select?: Equipment_bookingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Equipment_bookingCountOutputType without action
   */
  export type Equipment_bookingCountOutputTypeCountEquipment_booking_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_booking_methodWhereInput
  }



  /**
   * Models
   */

  /**
   * Model news_type
   */


  export type AggregateNews_type = {
    _count: News_typeCountAggregateOutputType | null
    _avg: News_typeAvgAggregateOutputType | null
    _sum: News_typeSumAggregateOutputType | null
    _min: News_typeMinAggregateOutputType | null
    _max: News_typeMaxAggregateOutputType | null
  }

  export type News_typeAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type News_typeSumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type News_typeMinAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type News_typeMaxAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type News_typeCountAggregateOutputType = {
    id: number
    name_th: number
    name_en: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type News_typeAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type News_typeSumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type News_typeMinAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type News_typeMaxAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type News_typeCountAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type News_typeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_type to aggregate.
     */
    where?: news_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_types to fetch.
     */
    orderBy?: news_typeOrderByWithRelationInput | news_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: news_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned news_types
    **/
    _count?: true | News_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: News_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: News_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: News_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: News_typeMaxAggregateInputType
  }

  export type GetNews_typeAggregateType<T extends News_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateNews_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews_type[P]>
      : GetScalarType<T[P], AggregateNews_type[P]>
  }




  export type news_typeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: news_typeWhereInput
    orderBy?: news_typeOrderByWithAggregationInput | news_typeOrderByWithAggregationInput[]
    by: News_typeScalarFieldEnum[] | News_typeScalarFieldEnum
    having?: news_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: News_typeCountAggregateInputType | true
    _avg?: News_typeAvgAggregateInputType
    _sum?: News_typeSumAggregateInputType
    _min?: News_typeMinAggregateInputType
    _max?: News_typeMaxAggregateInputType
  }


  export type News_typeGroupByOutputType = {
    id: number
    name_th: string
    name_en: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: News_typeCountAggregateOutputType | null
    _avg: News_typeAvgAggregateOutputType | null
    _sum: News_typeSumAggregateOutputType | null
    _min: News_typeMinAggregateOutputType | null
    _max: News_typeMaxAggregateOutputType | null
  }

  type GetNews_typeGroupByPayload<T extends news_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<News_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof News_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], News_typeGroupByOutputType[P]>
            : GetScalarType<T[P], News_typeGroupByOutputType[P]>
        }
      >
    >


  export type news_typeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    news?: boolean | news_type$newsArgs<ExtArgs>
    _count?: boolean | News_typeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["news_type"]>

  export type news_typeSelectScalar = {
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type news_typeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    news?: boolean | news_type$newsArgs<ExtArgs>
    _count?: boolean | News_typeCountOutputTypeArgs<ExtArgs>
  }


  type news_typeGetPayload<S extends boolean | null | undefined | news_typeArgs> = $Types.GetResult<news_typePayload, S>

  type news_typeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<news_typeFindManyArgs, 'select' | 'include'> & {
      select?: News_typeCountAggregateInputType | true
    }

  export interface news_typeDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['news_type'], meta: { name: 'news_type' } }
    /**
     * Find zero or one News_type that matches the filter.
     * @param {news_typeFindUniqueArgs} args - Arguments to find a News_type
     * @example
     * // Get one News_type
     * const news_type = await prisma.news_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends news_typeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, news_typeFindUniqueArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one News_type that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {news_typeFindUniqueOrThrowArgs} args - Arguments to find a News_type
     * @example
     * // Get one News_type
     * const news_type = await prisma.news_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends news_typeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, news_typeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first News_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_typeFindFirstArgs} args - Arguments to find a News_type
     * @example
     * // Get one News_type
     * const news_type = await prisma.news_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends news_typeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, news_typeFindFirstArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first News_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_typeFindFirstOrThrowArgs} args - Arguments to find a News_type
     * @example
     * // Get one News_type
     * const news_type = await prisma.news_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends news_typeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, news_typeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more News_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_typeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News_types
     * const news_types = await prisma.news_type.findMany()
     * 
     * // Get first 10 News_types
     * const news_types = await prisma.news_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const news_typeWithIdOnly = await prisma.news_type.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends news_typeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, news_typeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<news_typePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a News_type.
     * @param {news_typeCreateArgs} args - Arguments to create a News_type.
     * @example
     * // Create one News_type
     * const News_type = await prisma.news_type.create({
     *   data: {
     *     // ... data to create a News_type
     *   }
     * })
     * 
    **/
    create<T extends news_typeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, news_typeCreateArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many News_types.
     *     @param {news_typeCreateManyArgs} args - Arguments to create many News_types.
     *     @example
     *     // Create many News_types
     *     const news_type = await prisma.news_type.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends news_typeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, news_typeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News_type.
     * @param {news_typeDeleteArgs} args - Arguments to delete one News_type.
     * @example
     * // Delete one News_type
     * const News_type = await prisma.news_type.delete({
     *   where: {
     *     // ... filter to delete one News_type
     *   }
     * })
     * 
    **/
    delete<T extends news_typeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, news_typeDeleteArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one News_type.
     * @param {news_typeUpdateArgs} args - Arguments to update one News_type.
     * @example
     * // Update one News_type
     * const news_type = await prisma.news_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends news_typeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, news_typeUpdateArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more News_types.
     * @param {news_typeDeleteManyArgs} args - Arguments to filter News_types to delete.
     * @example
     * // Delete a few News_types
     * const { count } = await prisma.news_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends news_typeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, news_typeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News_types
     * const news_type = await prisma.news_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends news_typeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, news_typeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News_type.
     * @param {news_typeUpsertArgs} args - Arguments to update or create a News_type.
     * @example
     * // Update or create a News_type
     * const news_type = await prisma.news_type.upsert({
     *   create: {
     *     // ... data to create a News_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News_type we want to update
     *   }
     * })
    **/
    upsert<T extends news_typeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, news_typeUpsertArgs<ExtArgs>>
    ): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of News_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_typeCountArgs} args - Arguments to filter News_types to count.
     * @example
     * // Count the number of News_types
     * const count = await prisma.news_type.count({
     *   where: {
     *     // ... the filter for the News_types we want to count
     *   }
     * })
    **/
    count<T extends news_typeCountArgs>(
      args?: Subset<T, news_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], News_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {News_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends News_typeAggregateArgs>(args: Subset<T, News_typeAggregateArgs>): Prisma.PrismaPromise<GetNews_typeAggregateType<T>>

    /**
     * Group by News_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends news_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: news_typeGroupByArgs['orderBy'] }
        : { orderBy?: news_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, news_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNews_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the news_type model
   */
  readonly fields: news_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__news_typeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    news<T extends news_type$newsArgs<ExtArgs> = {}>(args?: Subset<T, news_type$newsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<newsPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the news_type model
   */ 
  interface news_typeFieldRefs {
    readonly id: FieldRef<"news_type", 'Int'>
    readonly name_th: FieldRef<"news_type", 'String'>
    readonly name_en: FieldRef<"news_type", 'String'>
    readonly is_active: FieldRef<"news_type", 'Int'>
    readonly is_publish: FieldRef<"news_type", 'Int'>
    readonly created_at: FieldRef<"news_type", 'DateTime'>
    readonly created_by: FieldRef<"news_type", 'String'>
    readonly updated_at: FieldRef<"news_type", 'DateTime'>
    readonly updated_by: FieldRef<"news_type", 'String'>
    readonly deleted_at: FieldRef<"news_type", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * news_type findUnique
   */
  export type news_typeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * Filter, which news_type to fetch.
     */
    where: news_typeWhereUniqueInput
  }


  /**
   * news_type findUniqueOrThrow
   */
  export type news_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * Filter, which news_type to fetch.
     */
    where: news_typeWhereUniqueInput
  }


  /**
   * news_type findFirst
   */
  export type news_typeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * Filter, which news_type to fetch.
     */
    where?: news_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_types to fetch.
     */
    orderBy?: news_typeOrderByWithRelationInput | news_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_types.
     */
    cursor?: news_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_types.
     */
    distinct?: News_typeScalarFieldEnum | News_typeScalarFieldEnum[]
  }


  /**
   * news_type findFirstOrThrow
   */
  export type news_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * Filter, which news_type to fetch.
     */
    where?: news_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_types to fetch.
     */
    orderBy?: news_typeOrderByWithRelationInput | news_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_types.
     */
    cursor?: news_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_types.
     */
    distinct?: News_typeScalarFieldEnum | News_typeScalarFieldEnum[]
  }


  /**
   * news_type findMany
   */
  export type news_typeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * Filter, which news_types to fetch.
     */
    where?: news_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_types to fetch.
     */
    orderBy?: news_typeOrderByWithRelationInput | news_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing news_types.
     */
    cursor?: news_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_types.
     */
    skip?: number
    distinct?: News_typeScalarFieldEnum | News_typeScalarFieldEnum[]
  }


  /**
   * news_type create
   */
  export type news_typeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a news_type.
     */
    data: XOR<news_typeCreateInput, news_typeUncheckedCreateInput>
  }


  /**
   * news_type createMany
   */
  export type news_typeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many news_types.
     */
    data: news_typeCreateManyInput | news_typeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * news_type update
   */
  export type news_typeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a news_type.
     */
    data: XOR<news_typeUpdateInput, news_typeUncheckedUpdateInput>
    /**
     * Choose, which news_type to update.
     */
    where: news_typeWhereUniqueInput
  }


  /**
   * news_type updateMany
   */
  export type news_typeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update news_types.
     */
    data: XOR<news_typeUpdateManyMutationInput, news_typeUncheckedUpdateManyInput>
    /**
     * Filter which news_types to update
     */
    where?: news_typeWhereInput
  }


  /**
   * news_type upsert
   */
  export type news_typeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the news_type to update in case it exists.
     */
    where: news_typeWhereUniqueInput
    /**
     * In case the news_type found by the `where` argument doesn't exist, create a new news_type with this data.
     */
    create: XOR<news_typeCreateInput, news_typeUncheckedCreateInput>
    /**
     * In case the news_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<news_typeUpdateInput, news_typeUncheckedUpdateInput>
  }


  /**
   * news_type delete
   */
  export type news_typeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
    /**
     * Filter which news_type to delete.
     */
    where: news_typeWhereUniqueInput
  }


  /**
   * news_type deleteMany
   */
  export type news_typeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_types to delete
     */
    where?: news_typeWhereInput
  }


  /**
   * news_type.news
   */
  export type news_type$newsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    where?: newsWhereInput
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    cursor?: newsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * news_type without action
   */
  export type news_typeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_type
     */
    select?: news_typeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: news_typeInclude<ExtArgs> | null
  }



  /**
   * Model news
   */


  export type AggregateNews = {
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  export type NewsAvgAggregateOutputType = {
    id: number | null
    news_type_id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type NewsSumAggregateOutputType = {
    id: number | null
    news_type_id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type NewsMinAggregateOutputType = {
    id: number | null
    news_type_id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    news_file: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_news: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type NewsMaxAggregateOutputType = {
    id: number | null
    news_type_id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    news_file: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_news: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type NewsCountAggregateOutputType = {
    id: number
    news_type_id: number
    title_th: number
    title_en: number
    detail_th: number
    detail_en: number
    news_file: number
    is_active: number
    is_publish: number
    count_views: number
    created_news: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type NewsAvgAggregateInputType = {
    id?: true
    news_type_id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type NewsSumAggregateInputType = {
    id?: true
    news_type_id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type NewsMinAggregateInputType = {
    id?: true
    news_type_id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    news_file?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_news?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type NewsMaxAggregateInputType = {
    id?: true
    news_type_id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    news_file?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_news?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type NewsCountAggregateInputType = {
    id?: true
    news_type_id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    news_file?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_news?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type NewsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which news to aggregate.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned news
    **/
    _count?: true | NewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NewsMaxAggregateInputType
  }

  export type GetNewsAggregateType<T extends NewsAggregateArgs> = {
        [P in keyof T & keyof AggregateNews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews[P]>
      : GetScalarType<T[P], AggregateNews[P]>
  }




  export type newsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: newsWhereInput
    orderBy?: newsOrderByWithAggregationInput | newsOrderByWithAggregationInput[]
    by: NewsScalarFieldEnum[] | NewsScalarFieldEnum
    having?: newsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NewsCountAggregateInputType | true
    _avg?: NewsAvgAggregateInputType
    _sum?: NewsSumAggregateInputType
    _min?: NewsMinAggregateInputType
    _max?: NewsMaxAggregateInputType
  }


  export type NewsGroupByOutputType = {
    id: number
    news_type_id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    news_file: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_news: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: NewsCountAggregateOutputType | null
    _avg: NewsAvgAggregateOutputType | null
    _sum: NewsSumAggregateOutputType | null
    _min: NewsMinAggregateOutputType | null
    _max: NewsMaxAggregateOutputType | null
  }

  type GetNewsGroupByPayload<T extends newsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NewsGroupByOutputType[P]>
            : GetScalarType<T[P], NewsGroupByOutputType[P]>
        }
      >
    >


  export type newsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    news_type_id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    news_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_news?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    news_type?: boolean | news_typeArgs<ExtArgs>
  }, ExtArgs["result"]["news"]>

  export type newsSelectScalar = {
    id?: boolean
    news_type_id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    news_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_news?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type newsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    news_type?: boolean | news_typeArgs<ExtArgs>
  }


  type newsGetPayload<S extends boolean | null | undefined | newsArgs> = $Types.GetResult<newsPayload, S>

  type newsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<newsFindManyArgs, 'select' | 'include'> & {
      select?: NewsCountAggregateInputType | true
    }

  export interface newsDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['news'], meta: { name: 'news' } }
    /**
     * Find zero or one News that matches the filter.
     * @param {newsFindUniqueArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends newsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, newsFindUniqueArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one News that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {newsFindUniqueOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends newsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, newsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsFindFirstArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends newsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, newsFindFirstArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first News that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsFindFirstOrThrowArgs} args - Arguments to find a News
     * @example
     * // Get one News
     * const news = await prisma.news.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends newsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, newsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more News that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News
     * const news = await prisma.news.findMany()
     * 
     * // Get first 10 News
     * const news = await prisma.news.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const newsWithIdOnly = await prisma.news.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends newsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, newsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<newsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a News.
     * @param {newsCreateArgs} args - Arguments to create a News.
     * @example
     * // Create one News
     * const News = await prisma.news.create({
     *   data: {
     *     // ... data to create a News
     *   }
     * })
     * 
    **/
    create<T extends newsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, newsCreateArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many News.
     *     @param {newsCreateManyArgs} args - Arguments to create many News.
     *     @example
     *     // Create many News
     *     const news = await prisma.news.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends newsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, newsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News.
     * @param {newsDeleteArgs} args - Arguments to delete one News.
     * @example
     * // Delete one News
     * const News = await prisma.news.delete({
     *   where: {
     *     // ... filter to delete one News
     *   }
     * })
     * 
    **/
    delete<T extends newsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, newsDeleteArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one News.
     * @param {newsUpdateArgs} args - Arguments to update one News.
     * @example
     * // Update one News
     * const news = await prisma.news.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends newsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, newsUpdateArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more News.
     * @param {newsDeleteManyArgs} args - Arguments to filter News to delete.
     * @example
     * // Delete a few News
     * const { count } = await prisma.news.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends newsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, newsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News
     * const news = await prisma.news.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends newsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, newsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News.
     * @param {newsUpsertArgs} args - Arguments to update or create a News.
     * @example
     * // Update or create a News
     * const news = await prisma.news.upsert({
     *   create: {
     *     // ... data to create a News
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News we want to update
     *   }
     * })
    **/
    upsert<T extends newsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, newsUpsertArgs<ExtArgs>>
    ): Prisma__newsClient<$Types.GetResult<newsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsCountArgs} args - Arguments to filter News to count.
     * @example
     * // Count the number of News
     * const count = await prisma.news.count({
     *   where: {
     *     // ... the filter for the News we want to count
     *   }
     * })
    **/
    count<T extends newsCountArgs>(
      args?: Subset<T, newsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NewsAggregateArgs>(args: Subset<T, NewsAggregateArgs>): Prisma.PrismaPromise<GetNewsAggregateType<T>>

    /**
     * Group by News.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {newsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends newsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: newsGroupByArgs['orderBy'] }
        : { orderBy?: newsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, newsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the news model
   */
  readonly fields: newsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__newsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    news_type<T extends news_typeArgs<ExtArgs> = {}>(args?: Subset<T, news_typeArgs<ExtArgs>>): Prisma__news_typeClient<$Types.GetResult<news_typePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the news model
   */ 
  interface newsFieldRefs {
    readonly id: FieldRef<"news", 'Int'>
    readonly news_type_id: FieldRef<"news", 'Int'>
    readonly title_th: FieldRef<"news", 'String'>
    readonly title_en: FieldRef<"news", 'String'>
    readonly detail_th: FieldRef<"news", 'String'>
    readonly detail_en: FieldRef<"news", 'String'>
    readonly news_file: FieldRef<"news", 'String'>
    readonly is_active: FieldRef<"news", 'Int'>
    readonly is_publish: FieldRef<"news", 'Int'>
    readonly count_views: FieldRef<"news", 'Int'>
    readonly created_news: FieldRef<"news", 'DateTime'>
    readonly created_at: FieldRef<"news", 'DateTime'>
    readonly created_by: FieldRef<"news", 'String'>
    readonly updated_at: FieldRef<"news", 'DateTime'>
    readonly updated_by: FieldRef<"news", 'String'>
    readonly deleted_at: FieldRef<"news", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * news findUnique
   */
  export type newsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where: newsWhereUniqueInput
  }


  /**
   * news findUniqueOrThrow
   */
  export type newsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where: newsWhereUniqueInput
  }


  /**
   * news findFirst
   */
  export type newsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news.
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * news findFirstOrThrow
   */
  export type newsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news.
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news.
     */
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * news findMany
   */
  export type newsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * Filter, which news to fetch.
     */
    where?: newsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news to fetch.
     */
    orderBy?: newsOrderByWithRelationInput | newsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing news.
     */
    cursor?: newsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news.
     */
    skip?: number
    distinct?: NewsScalarFieldEnum | NewsScalarFieldEnum[]
  }


  /**
   * news create
   */
  export type newsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * The data needed to create a news.
     */
    data: XOR<newsCreateInput, newsUncheckedCreateInput>
  }


  /**
   * news createMany
   */
  export type newsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many news.
     */
    data: newsCreateManyInput | newsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * news update
   */
  export type newsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * The data needed to update a news.
     */
    data: XOR<newsUpdateInput, newsUncheckedUpdateInput>
    /**
     * Choose, which news to update.
     */
    where: newsWhereUniqueInput
  }


  /**
   * news updateMany
   */
  export type newsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update news.
     */
    data: XOR<newsUpdateManyMutationInput, newsUncheckedUpdateManyInput>
    /**
     * Filter which news to update
     */
    where?: newsWhereInput
  }


  /**
   * news upsert
   */
  export type newsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * The filter to search for the news to update in case it exists.
     */
    where: newsWhereUniqueInput
    /**
     * In case the news found by the `where` argument doesn't exist, create a new news with this data.
     */
    create: XOR<newsCreateInput, newsUncheckedCreateInput>
    /**
     * In case the news was found with the provided `where` argument, update it with this data.
     */
    update: XOR<newsUpdateInput, newsUncheckedUpdateInput>
  }


  /**
   * news delete
   */
  export type newsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
    /**
     * Filter which news to delete.
     */
    where: newsWhereUniqueInput
  }


  /**
   * news deleteMany
   */
  export type newsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which news to delete
     */
    where?: newsWhereInput
  }


  /**
   * news without action
   */
  export type newsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news
     */
    select?: newsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: newsInclude<ExtArgs> | null
  }



  /**
   * Model banner
   */


  export type AggregateBanner = {
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  export type BannerAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type BannerSumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type BannerMinAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    banner_file: string | null
    banner_url: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_banner: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type BannerMaxAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    banner_file: string | null
    banner_url: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_banner: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type BannerCountAggregateOutputType = {
    id: number
    title_th: number
    title_en: number
    banner_file: number
    banner_url: number
    is_active: number
    is_publish: number
    count_views: number
    created_banner: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type BannerAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type BannerSumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type BannerMinAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    banner_file?: true
    banner_url?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_banner?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type BannerMaxAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    banner_file?: true
    banner_url?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_banner?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type BannerCountAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    banner_file?: true
    banner_url?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_banner?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type BannerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which banner to aggregate.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned banners
    **/
    _count?: true | BannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BannerMaxAggregateInputType
  }

  export type GetBannerAggregateType<T extends BannerAggregateArgs> = {
        [P in keyof T & keyof AggregateBanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBanner[P]>
      : GetScalarType<T[P], AggregateBanner[P]>
  }




  export type bannerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: bannerWhereInput
    orderBy?: bannerOrderByWithAggregationInput | bannerOrderByWithAggregationInput[]
    by: BannerScalarFieldEnum[] | BannerScalarFieldEnum
    having?: bannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BannerCountAggregateInputType | true
    _avg?: BannerAvgAggregateInputType
    _sum?: BannerSumAggregateInputType
    _min?: BannerMinAggregateInputType
    _max?: BannerMaxAggregateInputType
  }


  export type BannerGroupByOutputType = {
    id: number
    title_th: string
    title_en: string | null
    banner_file: string | null
    banner_url: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_banner: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: BannerCountAggregateOutputType | null
    _avg: BannerAvgAggregateOutputType | null
    _sum: BannerSumAggregateOutputType | null
    _min: BannerMinAggregateOutputType | null
    _max: BannerMaxAggregateOutputType | null
  }

  type GetBannerGroupByPayload<T extends bannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BannerGroupByOutputType[P]>
            : GetScalarType<T[P], BannerGroupByOutputType[P]>
        }
      >
    >


  export type bannerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    banner_file?: boolean
    banner_url?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_banner?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["banner"]>

  export type bannerSelectScalar = {
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    banner_file?: boolean
    banner_url?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_banner?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }


  type bannerGetPayload<S extends boolean | null | undefined | bannerArgs> = $Types.GetResult<bannerPayload, S>

  type bannerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<bannerFindManyArgs, 'select' | 'include'> & {
      select?: BannerCountAggregateInputType | true
    }

  export interface bannerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['banner'], meta: { name: 'banner' } }
    /**
     * Find zero or one Banner that matches the filter.
     * @param {bannerFindUniqueArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bannerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bannerFindUniqueArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Banner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bannerFindUniqueOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bannerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bannerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Banner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerFindFirstArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bannerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bannerFindFirstArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Banner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerFindFirstOrThrowArgs} args - Arguments to find a Banner
     * @example
     * // Get one Banner
     * const banner = await prisma.banner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bannerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bannerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Banners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Banners
     * const banners = await prisma.banner.findMany()
     * 
     * // Get first 10 Banners
     * const banners = await prisma.banner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bannerWithIdOnly = await prisma.banner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bannerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bannerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<bannerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Banner.
     * @param {bannerCreateArgs} args - Arguments to create a Banner.
     * @example
     * // Create one Banner
     * const Banner = await prisma.banner.create({
     *   data: {
     *     // ... data to create a Banner
     *   }
     * })
     * 
    **/
    create<T extends bannerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bannerCreateArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Banners.
     *     @param {bannerCreateManyArgs} args - Arguments to create many Banners.
     *     @example
     *     // Create many Banners
     *     const banner = await prisma.banner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bannerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bannerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Banner.
     * @param {bannerDeleteArgs} args - Arguments to delete one Banner.
     * @example
     * // Delete one Banner
     * const Banner = await prisma.banner.delete({
     *   where: {
     *     // ... filter to delete one Banner
     *   }
     * })
     * 
    **/
    delete<T extends bannerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bannerDeleteArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Banner.
     * @param {bannerUpdateArgs} args - Arguments to update one Banner.
     * @example
     * // Update one Banner
     * const banner = await prisma.banner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bannerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bannerUpdateArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Banners.
     * @param {bannerDeleteManyArgs} args - Arguments to filter Banners to delete.
     * @example
     * // Delete a few Banners
     * const { count } = await prisma.banner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bannerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bannerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Banners
     * const banner = await prisma.banner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bannerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bannerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Banner.
     * @param {bannerUpsertArgs} args - Arguments to update or create a Banner.
     * @example
     * // Update or create a Banner
     * const banner = await prisma.banner.upsert({
     *   create: {
     *     // ... data to create a Banner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Banner we want to update
     *   }
     * })
    **/
    upsert<T extends bannerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bannerUpsertArgs<ExtArgs>>
    ): Prisma__bannerClient<$Types.GetResult<bannerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Banners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerCountArgs} args - Arguments to filter Banners to count.
     * @example
     * // Count the number of Banners
     * const count = await prisma.banner.count({
     *   where: {
     *     // ... the filter for the Banners we want to count
     *   }
     * })
    **/
    count<T extends bannerCountArgs>(
      args?: Subset<T, bannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BannerAggregateArgs>(args: Subset<T, BannerAggregateArgs>): Prisma.PrismaPromise<GetBannerAggregateType<T>>

    /**
     * Group by Banner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bannerGroupByArgs['orderBy'] }
        : { orderBy?: bannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the banner model
   */
  readonly fields: bannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for banner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__bannerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the banner model
   */ 
  interface bannerFieldRefs {
    readonly id: FieldRef<"banner", 'Int'>
    readonly title_th: FieldRef<"banner", 'String'>
    readonly title_en: FieldRef<"banner", 'String'>
    readonly banner_file: FieldRef<"banner", 'String'>
    readonly banner_url: FieldRef<"banner", 'String'>
    readonly is_active: FieldRef<"banner", 'Int'>
    readonly is_publish: FieldRef<"banner", 'Int'>
    readonly count_views: FieldRef<"banner", 'Int'>
    readonly created_banner: FieldRef<"banner", 'DateTime'>
    readonly created_at: FieldRef<"banner", 'DateTime'>
    readonly created_by: FieldRef<"banner", 'String'>
    readonly updated_at: FieldRef<"banner", 'DateTime'>
    readonly updated_by: FieldRef<"banner", 'String'>
    readonly deleted_at: FieldRef<"banner", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * banner findUnique
   */
  export type bannerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where: bannerWhereUniqueInput
  }


  /**
   * banner findUniqueOrThrow
   */
  export type bannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where: bannerWhereUniqueInput
  }


  /**
   * banner findFirst
   */
  export type bannerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }


  /**
   * banner findFirstOrThrow
   */
  export type bannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Filter, which banner to fetch.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for banners.
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of banners.
     */
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }


  /**
   * banner findMany
   */
  export type bannerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Filter, which banners to fetch.
     */
    where?: bannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of banners to fetch.
     */
    orderBy?: bannerOrderByWithRelationInput | bannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing banners.
     */
    cursor?: bannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` banners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` banners.
     */
    skip?: number
    distinct?: BannerScalarFieldEnum | BannerScalarFieldEnum[]
  }


  /**
   * banner create
   */
  export type bannerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * The data needed to create a banner.
     */
    data: XOR<bannerCreateInput, bannerUncheckedCreateInput>
  }


  /**
   * banner createMany
   */
  export type bannerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many banners.
     */
    data: bannerCreateManyInput | bannerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * banner update
   */
  export type bannerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * The data needed to update a banner.
     */
    data: XOR<bannerUpdateInput, bannerUncheckedUpdateInput>
    /**
     * Choose, which banner to update.
     */
    where: bannerWhereUniqueInput
  }


  /**
   * banner updateMany
   */
  export type bannerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update banners.
     */
    data: XOR<bannerUpdateManyMutationInput, bannerUncheckedUpdateManyInput>
    /**
     * Filter which banners to update
     */
    where?: bannerWhereInput
  }


  /**
   * banner upsert
   */
  export type bannerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * The filter to search for the banner to update in case it exists.
     */
    where: bannerWhereUniqueInput
    /**
     * In case the banner found by the `where` argument doesn't exist, create a new banner with this data.
     */
    create: XOR<bannerCreateInput, bannerUncheckedCreateInput>
    /**
     * In case the banner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bannerUpdateInput, bannerUncheckedUpdateInput>
  }


  /**
   * banner delete
   */
  export type bannerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
    /**
     * Filter which banner to delete.
     */
    where: bannerWhereUniqueInput
  }


  /**
   * banner deleteMany
   */
  export type bannerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which banners to delete
     */
    where?: bannerWhereInput
  }


  /**
   * banner without action
   */
  export type bannerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the banner
     */
    select?: bannerSelect<ExtArgs> | null
  }



  /**
   * Model about
   */


  export type AggregateAbout = {
    _count: AboutCountAggregateOutputType | null
    _avg: AboutAvgAggregateOutputType | null
    _sum: AboutSumAggregateOutputType | null
    _min: AboutMinAggregateOutputType | null
    _max: AboutMaxAggregateOutputType | null
  }

  export type AboutAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type AboutSumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type AboutMinAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_about: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type AboutMaxAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_about: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type AboutCountAggregateOutputType = {
    id: number
    title_th: number
    title_en: number
    detail_th: number
    detail_en: number
    is_active: number
    is_publish: number
    count_views: number
    created_about: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type AboutAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type AboutSumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type AboutMinAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_about?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type AboutMaxAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_about?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type AboutCountAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_about?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type AboutAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which about to aggregate.
     */
    where?: aboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abouts to fetch.
     */
    orderBy?: aboutOrderByWithRelationInput | aboutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned abouts
    **/
    _count?: true | AboutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AboutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AboutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AboutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AboutMaxAggregateInputType
  }

  export type GetAboutAggregateType<T extends AboutAggregateArgs> = {
        [P in keyof T & keyof AggregateAbout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbout[P]>
      : GetScalarType<T[P], AggregateAbout[P]>
  }




  export type aboutGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: aboutWhereInput
    orderBy?: aboutOrderByWithAggregationInput | aboutOrderByWithAggregationInput[]
    by: AboutScalarFieldEnum[] | AboutScalarFieldEnum
    having?: aboutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AboutCountAggregateInputType | true
    _avg?: AboutAvgAggregateInputType
    _sum?: AboutSumAggregateInputType
    _min?: AboutMinAggregateInputType
    _max?: AboutMaxAggregateInputType
  }


  export type AboutGroupByOutputType = {
    id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_about: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: AboutCountAggregateOutputType | null
    _avg: AboutAvgAggregateOutputType | null
    _sum: AboutSumAggregateOutputType | null
    _min: AboutMinAggregateOutputType | null
    _max: AboutMaxAggregateOutputType | null
  }

  type GetAboutGroupByPayload<T extends aboutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AboutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AboutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AboutGroupByOutputType[P]>
            : GetScalarType<T[P], AboutGroupByOutputType[P]>
        }
      >
    >


  export type aboutSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_about?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["about"]>

  export type aboutSelectScalar = {
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_about?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }


  type aboutGetPayload<S extends boolean | null | undefined | aboutArgs> = $Types.GetResult<aboutPayload, S>

  type aboutCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<aboutFindManyArgs, 'select' | 'include'> & {
      select?: AboutCountAggregateInputType | true
    }

  export interface aboutDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['about'], meta: { name: 'about' } }
    /**
     * Find zero or one About that matches the filter.
     * @param {aboutFindUniqueArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends aboutFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, aboutFindUniqueArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one About that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {aboutFindUniqueOrThrowArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends aboutFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, aboutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first About that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutFindFirstArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends aboutFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, aboutFindFirstArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first About that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutFindFirstOrThrowArgs} args - Arguments to find a About
     * @example
     * // Get one About
     * const about = await prisma.about.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends aboutFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, aboutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Abouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abouts
     * const abouts = await prisma.about.findMany()
     * 
     * // Get first 10 Abouts
     * const abouts = await prisma.about.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aboutWithIdOnly = await prisma.about.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends aboutFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, aboutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<aboutPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a About.
     * @param {aboutCreateArgs} args - Arguments to create a About.
     * @example
     * // Create one About
     * const About = await prisma.about.create({
     *   data: {
     *     // ... data to create a About
     *   }
     * })
     * 
    **/
    create<T extends aboutCreateArgs<ExtArgs>>(
      args: SelectSubset<T, aboutCreateArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Abouts.
     *     @param {aboutCreateManyArgs} args - Arguments to create many Abouts.
     *     @example
     *     // Create many Abouts
     *     const about = await prisma.about.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends aboutCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, aboutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a About.
     * @param {aboutDeleteArgs} args - Arguments to delete one About.
     * @example
     * // Delete one About
     * const About = await prisma.about.delete({
     *   where: {
     *     // ... filter to delete one About
     *   }
     * })
     * 
    **/
    delete<T extends aboutDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, aboutDeleteArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one About.
     * @param {aboutUpdateArgs} args - Arguments to update one About.
     * @example
     * // Update one About
     * const about = await prisma.about.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends aboutUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, aboutUpdateArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Abouts.
     * @param {aboutDeleteManyArgs} args - Arguments to filter Abouts to delete.
     * @example
     * // Delete a few Abouts
     * const { count } = await prisma.about.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends aboutDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, aboutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abouts
     * const about = await prisma.about.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends aboutUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, aboutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one About.
     * @param {aboutUpsertArgs} args - Arguments to update or create a About.
     * @example
     * // Update or create a About
     * const about = await prisma.about.upsert({
     *   create: {
     *     // ... data to create a About
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the About we want to update
     *   }
     * })
    **/
    upsert<T extends aboutUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, aboutUpsertArgs<ExtArgs>>
    ): Prisma__aboutClient<$Types.GetResult<aboutPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Abouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutCountArgs} args - Arguments to filter Abouts to count.
     * @example
     * // Count the number of Abouts
     * const count = await prisma.about.count({
     *   where: {
     *     // ... the filter for the Abouts we want to count
     *   }
     * })
    **/
    count<T extends aboutCountArgs>(
      args?: Subset<T, aboutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AboutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a About.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AboutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AboutAggregateArgs>(args: Subset<T, AboutAggregateArgs>): Prisma.PrismaPromise<GetAboutAggregateType<T>>

    /**
     * Group by About.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aboutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aboutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aboutGroupByArgs['orderBy'] }
        : { orderBy?: aboutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aboutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAboutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the about model
   */
  readonly fields: aboutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for about.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__aboutClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the about model
   */ 
  interface aboutFieldRefs {
    readonly id: FieldRef<"about", 'Int'>
    readonly title_th: FieldRef<"about", 'String'>
    readonly title_en: FieldRef<"about", 'String'>
    readonly detail_th: FieldRef<"about", 'String'>
    readonly detail_en: FieldRef<"about", 'String'>
    readonly is_active: FieldRef<"about", 'Int'>
    readonly is_publish: FieldRef<"about", 'Int'>
    readonly count_views: FieldRef<"about", 'Int'>
    readonly created_about: FieldRef<"about", 'DateTime'>
    readonly created_at: FieldRef<"about", 'DateTime'>
    readonly created_by: FieldRef<"about", 'String'>
    readonly updated_at: FieldRef<"about", 'DateTime'>
    readonly updated_by: FieldRef<"about", 'String'>
    readonly deleted_at: FieldRef<"about", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * about findUnique
   */
  export type aboutFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * Filter, which about to fetch.
     */
    where: aboutWhereUniqueInput
  }


  /**
   * about findUniqueOrThrow
   */
  export type aboutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * Filter, which about to fetch.
     */
    where: aboutWhereUniqueInput
  }


  /**
   * about findFirst
   */
  export type aboutFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * Filter, which about to fetch.
     */
    where?: aboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abouts to fetch.
     */
    orderBy?: aboutOrderByWithRelationInput | aboutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abouts.
     */
    cursor?: aboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abouts.
     */
    distinct?: AboutScalarFieldEnum | AboutScalarFieldEnum[]
  }


  /**
   * about findFirstOrThrow
   */
  export type aboutFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * Filter, which about to fetch.
     */
    where?: aboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abouts to fetch.
     */
    orderBy?: aboutOrderByWithRelationInput | aboutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for abouts.
     */
    cursor?: aboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of abouts.
     */
    distinct?: AboutScalarFieldEnum | AboutScalarFieldEnum[]
  }


  /**
   * about findMany
   */
  export type aboutFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * Filter, which abouts to fetch.
     */
    where?: aboutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of abouts to fetch.
     */
    orderBy?: aboutOrderByWithRelationInput | aboutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing abouts.
     */
    cursor?: aboutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` abouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` abouts.
     */
    skip?: number
    distinct?: AboutScalarFieldEnum | AboutScalarFieldEnum[]
  }


  /**
   * about create
   */
  export type aboutCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * The data needed to create a about.
     */
    data: XOR<aboutCreateInput, aboutUncheckedCreateInput>
  }


  /**
   * about createMany
   */
  export type aboutCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many abouts.
     */
    data: aboutCreateManyInput | aboutCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * about update
   */
  export type aboutUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * The data needed to update a about.
     */
    data: XOR<aboutUpdateInput, aboutUncheckedUpdateInput>
    /**
     * Choose, which about to update.
     */
    where: aboutWhereUniqueInput
  }


  /**
   * about updateMany
   */
  export type aboutUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update abouts.
     */
    data: XOR<aboutUpdateManyMutationInput, aboutUncheckedUpdateManyInput>
    /**
     * Filter which abouts to update
     */
    where?: aboutWhereInput
  }


  /**
   * about upsert
   */
  export type aboutUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * The filter to search for the about to update in case it exists.
     */
    where: aboutWhereUniqueInput
    /**
     * In case the about found by the `where` argument doesn't exist, create a new about with this data.
     */
    create: XOR<aboutCreateInput, aboutUncheckedCreateInput>
    /**
     * In case the about was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aboutUpdateInput, aboutUncheckedUpdateInput>
  }


  /**
   * about delete
   */
  export type aboutDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
    /**
     * Filter which about to delete.
     */
    where: aboutWhereUniqueInput
  }


  /**
   * about deleteMany
   */
  export type aboutDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which abouts to delete
     */
    where?: aboutWhereInput
  }


  /**
   * about without action
   */
  export type aboutArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the about
     */
    select?: aboutSelect<ExtArgs> | null
  }



  /**
   * Model contact
   */


  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type ContactSumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type ContactMinAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_contact: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_contact: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    title_th: number
    title_en: number
    detail_th: number
    detail_en: number
    is_active: number
    is_publish: number
    count_views: number
    created_contact: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type ContactAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type ContactSumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type ContactMinAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_contact?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_contact?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_contact?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which contact to aggregate.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type contactGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: contactWhereInput
    orderBy?: contactOrderByWithAggregationInput | contactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: contactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _avg?: ContactAvgAggregateInputType
    _sum?: ContactSumAggregateInputType
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }


  export type ContactGroupByOutputType = {
    id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_contact: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: ContactCountAggregateOutputType | null
    _avg: ContactAvgAggregateOutputType | null
    _sum: ContactSumAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends contactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type contactSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_contact?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["contact"]>

  export type contactSelectScalar = {
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_contact?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }


  type contactGetPayload<S extends boolean | null | undefined | contactArgs> = $Types.GetResult<contactPayload, S>

  type contactCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<contactFindManyArgs, 'select' | 'include'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface contactDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contact'], meta: { name: 'contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {contactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends contactFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, contactFindUniqueArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {contactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends contactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends contactFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, contactFindFirstArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends contactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, contactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends contactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<contactPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contact.
     * @param {contactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
    **/
    create<T extends contactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, contactCreateArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     *     @param {contactCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contact = await prisma.contact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends contactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {contactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
    **/
    delete<T extends contactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, contactDeleteArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {contactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends contactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, contactUpdateArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {contactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends contactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, contactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends contactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, contactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {contactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
    **/
    upsert<T extends contactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, contactUpsertArgs<ExtArgs>>
    ): Prisma__contactClient<$Types.GetResult<contactPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactCountArgs>(
      args?: Subset<T, contactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactGroupByArgs['orderBy'] }
        : { orderBy?: contactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contact model
   */
  readonly fields: contactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__contactClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the contact model
   */ 
  interface contactFieldRefs {
    readonly id: FieldRef<"contact", 'Int'>
    readonly title_th: FieldRef<"contact", 'String'>
    readonly title_en: FieldRef<"contact", 'String'>
    readonly detail_th: FieldRef<"contact", 'String'>
    readonly detail_en: FieldRef<"contact", 'String'>
    readonly is_active: FieldRef<"contact", 'Int'>
    readonly is_publish: FieldRef<"contact", 'Int'>
    readonly count_views: FieldRef<"contact", 'Int'>
    readonly created_contact: FieldRef<"contact", 'DateTime'>
    readonly created_at: FieldRef<"contact", 'DateTime'>
    readonly created_by: FieldRef<"contact", 'String'>
    readonly updated_at: FieldRef<"contact", 'DateTime'>
    readonly updated_by: FieldRef<"contact", 'String'>
    readonly deleted_at: FieldRef<"contact", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * contact findUnique
   */
  export type contactFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }


  /**
   * contact findUniqueOrThrow
   */
  export type contactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where: contactWhereUniqueInput
  }


  /**
   * contact findFirst
   */
  export type contactFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * contact findFirstOrThrow
   */
  export type contactFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contact to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * contact findMany
   */
  export type contactFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactOrderByWithRelationInput | contactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * contact create
   */
  export type contactCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * The data needed to create a contact.
     */
    data: XOR<contactCreateInput, contactUncheckedCreateInput>
  }


  /**
   * contact createMany
   */
  export type contactCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactCreateManyInput | contactCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * contact update
   */
  export type contactUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * The data needed to update a contact.
     */
    data: XOR<contactUpdateInput, contactUncheckedUpdateInput>
    /**
     * Choose, which contact to update.
     */
    where: contactWhereUniqueInput
  }


  /**
   * contact updateMany
   */
  export type contactUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactUpdateManyMutationInput, contactUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactWhereInput
  }


  /**
   * contact upsert
   */
  export type contactUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * The filter to search for the contact to update in case it exists.
     */
    where: contactWhereUniqueInput
    /**
     * In case the contact found by the `where` argument doesn't exist, create a new contact with this data.
     */
    create: XOR<contactCreateInput, contactUncheckedCreateInput>
    /**
     * In case the contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactUpdateInput, contactUncheckedUpdateInput>
  }


  /**
   * contact delete
   */
  export type contactDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
    /**
     * Filter which contact to delete.
     */
    where: contactWhereUniqueInput
  }


  /**
   * contact deleteMany
   */
  export type contactDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactWhereInput
  }


  /**
   * contact without action
   */
  export type contactArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contact
     */
    select?: contactSelect<ExtArgs> | null
  }



  /**
   * Model department
   */


  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    id: number | null
    level: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    id: number | null
    level: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    level: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    level: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name_th: number
    name_en: number
    level: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    id?: true
    level?: true
    is_active?: true
    is_publish?: true
  }

  export type DepartmentSumAggregateInputType = {
    id?: true
    level?: true
    is_active?: true
    is_publish?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    level?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    level?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    level?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which department to aggregate.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type departmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: departmentWhereInput
    orderBy?: departmentOrderByWithAggregationInput | departmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: departmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }


  export type DepartmentGroupByOutputType = {
    id: number
    name_th: string
    name_en: string | null
    level: number
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends departmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type departmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    level?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    team?: boolean | department$teamArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type departmentSelectScalar = {
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    level?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type departmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    team?: boolean | department$teamArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeArgs<ExtArgs>
  }


  type departmentGetPayload<S extends boolean | null | undefined | departmentArgs> = $Types.GetResult<departmentPayload, S>

  type departmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<departmentFindManyArgs, 'select' | 'include'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface departmentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['department'], meta: { name: 'department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {departmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends departmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, departmentFindUniqueArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {departmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends departmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, departmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends departmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, departmentFindFirstArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends departmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, departmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends departmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, departmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<departmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Department.
     * @param {departmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
    **/
    create<T extends departmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, departmentCreateArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Departments.
     *     @param {departmentCreateManyArgs} args - Arguments to create many Departments.
     *     @example
     *     // Create many Departments
     *     const department = await prisma.department.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends departmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, departmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Department.
     * @param {departmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
    **/
    delete<T extends departmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, departmentDeleteArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Department.
     * @param {departmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends departmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, departmentUpdateArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {departmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends departmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, departmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends departmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, departmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {departmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
    **/
    upsert<T extends departmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, departmentUpsertArgs<ExtArgs>>
    ): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends departmentCountArgs>(
      args?: Subset<T, departmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {departmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends departmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: departmentGroupByArgs['orderBy'] }
        : { orderBy?: departmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, departmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the department model
   */
  readonly fields: departmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__departmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    team<T extends department$teamArgs<ExtArgs> = {}>(args?: Subset<T, department$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<teamPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the department model
   */ 
  interface departmentFieldRefs {
    readonly id: FieldRef<"department", 'Int'>
    readonly name_th: FieldRef<"department", 'String'>
    readonly name_en: FieldRef<"department", 'String'>
    readonly level: FieldRef<"department", 'Int'>
    readonly is_active: FieldRef<"department", 'Int'>
    readonly is_publish: FieldRef<"department", 'Int'>
    readonly created_at: FieldRef<"department", 'DateTime'>
    readonly created_by: FieldRef<"department", 'String'>
    readonly updated_at: FieldRef<"department", 'DateTime'>
    readonly updated_by: FieldRef<"department", 'String'>
    readonly deleted_at: FieldRef<"department", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * department findUnique
   */
  export type departmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }


  /**
   * department findUniqueOrThrow
   */
  export type departmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where: departmentWhereUniqueInput
  }


  /**
   * department findFirst
   */
  export type departmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }


  /**
   * department findFirstOrThrow
   */
  export type departmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which department to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }


  /**
   * department findMany
   */
  export type departmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter, which departments to fetch.
     */
    where?: departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of departments to fetch.
     */
    orderBy?: departmentOrderByWithRelationInput | departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing departments.
     */
    cursor?: departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }


  /**
   * department create
   */
  export type departmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to create a department.
     */
    data: XOR<departmentCreateInput, departmentUncheckedCreateInput>
  }


  /**
   * department createMany
   */
  export type departmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many departments.
     */
    data: departmentCreateManyInput | departmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * department update
   */
  export type departmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The data needed to update a department.
     */
    data: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
    /**
     * Choose, which department to update.
     */
    where: departmentWhereUniqueInput
  }


  /**
   * department updateMany
   */
  export type departmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update departments.
     */
    data: XOR<departmentUpdateManyMutationInput, departmentUncheckedUpdateManyInput>
    /**
     * Filter which departments to update
     */
    where?: departmentWhereInput
  }


  /**
   * department upsert
   */
  export type departmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * The filter to search for the department to update in case it exists.
     */
    where: departmentWhereUniqueInput
    /**
     * In case the department found by the `where` argument doesn't exist, create a new department with this data.
     */
    create: XOR<departmentCreateInput, departmentUncheckedCreateInput>
    /**
     * In case the department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<departmentUpdateInput, departmentUncheckedUpdateInput>
  }


  /**
   * department delete
   */
  export type departmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
    /**
     * Filter which department to delete.
     */
    where: departmentWhereUniqueInput
  }


  /**
   * department deleteMany
   */
  export type departmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which departments to delete
     */
    where?: departmentWhereInput
  }


  /**
   * department.team
   */
  export type department$teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * department without action
   */
  export type departmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the department
     */
    select?: departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: departmentInclude<ExtArgs> | null
  }



  /**
   * Model team
   */


  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    department_id: number | null
    level: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    department_id: number | null
    level: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    department_id: number | null
    prefix_th: string | null
    prefix_en: string | null
    firstname_th: string | null
    firstname_en: string | null
    surname_th: string | null
    surname_en: string | null
    position_th: string | null
    position_en: string | null
    position_level_th: string | null
    position_level_en: string | null
    phone: string | null
    email: string | null
    level: number | null
    team_file: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    department_id: number | null
    prefix_th: string | null
    prefix_en: string | null
    firstname_th: string | null
    firstname_en: string | null
    surname_th: string | null
    surname_en: string | null
    position_th: string | null
    position_en: string | null
    position_level_th: string | null
    position_level_en: string | null
    phone: string | null
    email: string | null
    level: number | null
    team_file: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    department_id: number
    prefix_th: number
    prefix_en: number
    firstname_th: number
    firstname_en: number
    surname_th: number
    surname_en: number
    position_th: number
    position_en: number
    position_level_th: number
    position_level_en: number
    phone: number
    email: number
    level: number
    team_file: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    department_id?: true
    level?: true
    is_active?: true
    is_publish?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    department_id?: true
    level?: true
    is_active?: true
    is_publish?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    department_id?: true
    prefix_th?: true
    prefix_en?: true
    firstname_th?: true
    firstname_en?: true
    surname_th?: true
    surname_en?: true
    position_th?: true
    position_en?: true
    position_level_th?: true
    position_level_en?: true
    phone?: true
    email?: true
    level?: true
    team_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    department_id?: true
    prefix_th?: true
    prefix_en?: true
    firstname_th?: true
    firstname_en?: true
    surname_th?: true
    surname_en?: true
    position_th?: true
    position_en?: true
    position_level_th?: true
    position_level_en?: true
    phone?: true
    email?: true
    level?: true
    team_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    department_id?: true
    prefix_th?: true
    prefix_en?: true
    firstname_th?: true
    firstname_en?: true
    surname_th?: true
    surname_en?: true
    position_th?: true
    position_en?: true
    position_level_th?: true
    position_level_en?: true
    phone?: true
    email?: true
    level?: true
    team_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type teamGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
    orderBy?: teamOrderByWithAggregationInput | teamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }


  export type TeamGroupByOutputType = {
    id: number
    department_id: number
    prefix_th: string | null
    prefix_en: string | null
    firstname_th: string | null
    firstname_en: string | null
    surname_th: string | null
    surname_en: string | null
    position_th: string | null
    position_en: string | null
    position_level_th: string | null
    position_level_en: string | null
    phone: string
    email: string
    level: number
    team_file: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    department_id?: boolean
    prefix_th?: boolean
    prefix_en?: boolean
    firstname_th?: boolean
    firstname_en?: boolean
    surname_th?: boolean
    surname_en?: boolean
    position_th?: boolean
    position_en?: boolean
    position_level_th?: boolean
    position_level_en?: boolean
    phone?: boolean
    email?: boolean
    level?: boolean
    team_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    department?: boolean | departmentArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type teamSelectScalar = {
    id?: boolean
    department_id?: boolean
    prefix_th?: boolean
    prefix_en?: boolean
    firstname_th?: boolean
    firstname_en?: boolean
    surname_th?: boolean
    surname_en?: boolean
    position_th?: boolean
    position_en?: boolean
    position_level_th?: boolean
    position_level_en?: boolean
    phone?: boolean
    email?: boolean
    level?: boolean
    team_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type teamInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    department?: boolean | departmentArgs<ExtArgs>
  }


  type teamGetPayload<S extends boolean | null | undefined | teamArgs> = $Types.GetResult<teamPayload, S>

  type teamCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<teamFindManyArgs, 'select' | 'include'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team'], meta: { name: 'team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends teamFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, teamFindUniqueArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends teamFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindFirstArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends teamFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<teamPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
    **/
    create<T extends teamCreateArgs<ExtArgs>>(
      args: SelectSubset<T, teamCreateArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Teams.
     *     @param {teamCreateManyArgs} args - Arguments to create many Teams.
     *     @example
     *     // Create many Teams
     *     const team = await prisma.team.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends teamCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
    **/
    delete<T extends teamDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, teamDeleteArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends teamUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpdateArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends teamDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, teamDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends teamUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
    **/
    upsert<T extends teamUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, teamUpsertArgs<ExtArgs>>
    ): Prisma__teamClient<$Types.GetResult<teamPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamGroupByArgs['orderBy'] }
        : { orderBy?: teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team model
   */
  readonly fields: teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__teamClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    department<T extends departmentArgs<ExtArgs> = {}>(args?: Subset<T, departmentArgs<ExtArgs>>): Prisma__departmentClient<$Types.GetResult<departmentPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the team model
   */ 
  interface teamFieldRefs {
    readonly id: FieldRef<"team", 'Int'>
    readonly department_id: FieldRef<"team", 'Int'>
    readonly prefix_th: FieldRef<"team", 'String'>
    readonly prefix_en: FieldRef<"team", 'String'>
    readonly firstname_th: FieldRef<"team", 'String'>
    readonly firstname_en: FieldRef<"team", 'String'>
    readonly surname_th: FieldRef<"team", 'String'>
    readonly surname_en: FieldRef<"team", 'String'>
    readonly position_th: FieldRef<"team", 'String'>
    readonly position_en: FieldRef<"team", 'String'>
    readonly position_level_th: FieldRef<"team", 'String'>
    readonly position_level_en: FieldRef<"team", 'String'>
    readonly phone: FieldRef<"team", 'String'>
    readonly email: FieldRef<"team", 'String'>
    readonly level: FieldRef<"team", 'Int'>
    readonly team_file: FieldRef<"team", 'String'>
    readonly is_active: FieldRef<"team", 'Int'>
    readonly is_publish: FieldRef<"team", 'Int'>
    readonly created_at: FieldRef<"team", 'DateTime'>
    readonly created_by: FieldRef<"team", 'String'>
    readonly updated_at: FieldRef<"team", 'DateTime'>
    readonly updated_by: FieldRef<"team", 'String'>
    readonly deleted_at: FieldRef<"team", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * team findUnique
   */
  export type teamFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team findFirst
   */
  export type teamFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team findMany
   */
  export type teamFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }


  /**
   * team create
   */
  export type teamCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }


  /**
   * team createMany
   */
  export type teamCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * team update
   */
  export type teamUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team updateMany
   */
  export type teamUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
  }


  /**
   * team upsert
   */
  export type teamUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }


  /**
   * team delete
   */
  export type teamDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }


  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
  }


  /**
   * team without action
   */
  export type teamArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: teamInclude<ExtArgs> | null
  }



  /**
   * Model news_gallery
   */


  export type AggregateNews_gallery = {
    _count: News_galleryCountAggregateOutputType | null
    _avg: News_galleryAvgAggregateOutputType | null
    _sum: News_gallerySumAggregateOutputType | null
    _min: News_galleryMinAggregateOutputType | null
    _max: News_galleryMaxAggregateOutputType | null
  }

  export type News_galleryAvgAggregateOutputType = {
    id: number | null
    news_id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type News_gallerySumAggregateOutputType = {
    id: number | null
    news_id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type News_galleryMinAggregateOutputType = {
    id: number | null
    news_id: number | null
    secret_key: string | null
    news_gallery_file: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type News_galleryMaxAggregateOutputType = {
    id: number | null
    news_id: number | null
    secret_key: string | null
    news_gallery_file: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type News_galleryCountAggregateOutputType = {
    id: number
    news_id: number
    secret_key: number
    news_gallery_file: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type News_galleryAvgAggregateInputType = {
    id?: true
    news_id?: true
    is_active?: true
    is_publish?: true
  }

  export type News_gallerySumAggregateInputType = {
    id?: true
    news_id?: true
    is_active?: true
    is_publish?: true
  }

  export type News_galleryMinAggregateInputType = {
    id?: true
    news_id?: true
    secret_key?: true
    news_gallery_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type News_galleryMaxAggregateInputType = {
    id?: true
    news_id?: true
    secret_key?: true
    news_gallery_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type News_galleryCountAggregateInputType = {
    id?: true
    news_id?: true
    secret_key?: true
    news_gallery_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type News_galleryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_gallery to aggregate.
     */
    where?: news_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_galleries to fetch.
     */
    orderBy?: news_galleryOrderByWithRelationInput | news_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: news_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned news_galleries
    **/
    _count?: true | News_galleryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: News_galleryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: News_gallerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: News_galleryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: News_galleryMaxAggregateInputType
  }

  export type GetNews_galleryAggregateType<T extends News_galleryAggregateArgs> = {
        [P in keyof T & keyof AggregateNews_gallery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNews_gallery[P]>
      : GetScalarType<T[P], AggregateNews_gallery[P]>
  }




  export type news_galleryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: news_galleryWhereInput
    orderBy?: news_galleryOrderByWithAggregationInput | news_galleryOrderByWithAggregationInput[]
    by: News_galleryScalarFieldEnum[] | News_galleryScalarFieldEnum
    having?: news_galleryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: News_galleryCountAggregateInputType | true
    _avg?: News_galleryAvgAggregateInputType
    _sum?: News_gallerySumAggregateInputType
    _min?: News_galleryMinAggregateInputType
    _max?: News_galleryMaxAggregateInputType
  }


  export type News_galleryGroupByOutputType = {
    id: number
    news_id: number | null
    secret_key: string
    news_gallery_file: string
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: News_galleryCountAggregateOutputType | null
    _avg: News_galleryAvgAggregateOutputType | null
    _sum: News_gallerySumAggregateOutputType | null
    _min: News_galleryMinAggregateOutputType | null
    _max: News_galleryMaxAggregateOutputType | null
  }

  type GetNews_galleryGroupByPayload<T extends news_galleryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<News_galleryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof News_galleryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], News_galleryGroupByOutputType[P]>
            : GetScalarType<T[P], News_galleryGroupByOutputType[P]>
        }
      >
    >


  export type news_gallerySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    news_id?: boolean
    secret_key?: boolean
    news_gallery_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["news_gallery"]>

  export type news_gallerySelectScalar = {
    id?: boolean
    news_id?: boolean
    secret_key?: boolean
    news_gallery_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }


  type news_galleryGetPayload<S extends boolean | null | undefined | news_galleryArgs> = $Types.GetResult<news_galleryPayload, S>

  type news_galleryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<news_galleryFindManyArgs, 'select' | 'include'> & {
      select?: News_galleryCountAggregateInputType | true
    }

  export interface news_galleryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['news_gallery'], meta: { name: 'news_gallery' } }
    /**
     * Find zero or one News_gallery that matches the filter.
     * @param {news_galleryFindUniqueArgs} args - Arguments to find a News_gallery
     * @example
     * // Get one News_gallery
     * const news_gallery = await prisma.news_gallery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends news_galleryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, news_galleryFindUniqueArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one News_gallery that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {news_galleryFindUniqueOrThrowArgs} args - Arguments to find a News_gallery
     * @example
     * // Get one News_gallery
     * const news_gallery = await prisma.news_gallery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends news_galleryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, news_galleryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first News_gallery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_galleryFindFirstArgs} args - Arguments to find a News_gallery
     * @example
     * // Get one News_gallery
     * const news_gallery = await prisma.news_gallery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends news_galleryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, news_galleryFindFirstArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first News_gallery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_galleryFindFirstOrThrowArgs} args - Arguments to find a News_gallery
     * @example
     * // Get one News_gallery
     * const news_gallery = await prisma.news_gallery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends news_galleryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, news_galleryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more News_galleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_galleryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all News_galleries
     * const news_galleries = await prisma.news_gallery.findMany()
     * 
     * // Get first 10 News_galleries
     * const news_galleries = await prisma.news_gallery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const news_galleryWithIdOnly = await prisma.news_gallery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends news_galleryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, news_galleryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a News_gallery.
     * @param {news_galleryCreateArgs} args - Arguments to create a News_gallery.
     * @example
     * // Create one News_gallery
     * const News_gallery = await prisma.news_gallery.create({
     *   data: {
     *     // ... data to create a News_gallery
     *   }
     * })
     * 
    **/
    create<T extends news_galleryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, news_galleryCreateArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many News_galleries.
     *     @param {news_galleryCreateManyArgs} args - Arguments to create many News_galleries.
     *     @example
     *     // Create many News_galleries
     *     const news_gallery = await prisma.news_gallery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends news_galleryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, news_galleryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a News_gallery.
     * @param {news_galleryDeleteArgs} args - Arguments to delete one News_gallery.
     * @example
     * // Delete one News_gallery
     * const News_gallery = await prisma.news_gallery.delete({
     *   where: {
     *     // ... filter to delete one News_gallery
     *   }
     * })
     * 
    **/
    delete<T extends news_galleryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, news_galleryDeleteArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one News_gallery.
     * @param {news_galleryUpdateArgs} args - Arguments to update one News_gallery.
     * @example
     * // Update one News_gallery
     * const news_gallery = await prisma.news_gallery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends news_galleryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, news_galleryUpdateArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more News_galleries.
     * @param {news_galleryDeleteManyArgs} args - Arguments to filter News_galleries to delete.
     * @example
     * // Delete a few News_galleries
     * const { count } = await prisma.news_gallery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends news_galleryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, news_galleryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more News_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_galleryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many News_galleries
     * const news_gallery = await prisma.news_gallery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends news_galleryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, news_galleryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one News_gallery.
     * @param {news_galleryUpsertArgs} args - Arguments to update or create a News_gallery.
     * @example
     * // Update or create a News_gallery
     * const news_gallery = await prisma.news_gallery.upsert({
     *   create: {
     *     // ... data to create a News_gallery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the News_gallery we want to update
     *   }
     * })
    **/
    upsert<T extends news_galleryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, news_galleryUpsertArgs<ExtArgs>>
    ): Prisma__news_galleryClient<$Types.GetResult<news_galleryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of News_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_galleryCountArgs} args - Arguments to filter News_galleries to count.
     * @example
     * // Count the number of News_galleries
     * const count = await prisma.news_gallery.count({
     *   where: {
     *     // ... the filter for the News_galleries we want to count
     *   }
     * })
    **/
    count<T extends news_galleryCountArgs>(
      args?: Subset<T, news_galleryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], News_galleryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a News_gallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {News_galleryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends News_galleryAggregateArgs>(args: Subset<T, News_galleryAggregateArgs>): Prisma.PrismaPromise<GetNews_galleryAggregateType<T>>

    /**
     * Group by News_gallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {news_galleryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends news_galleryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: news_galleryGroupByArgs['orderBy'] }
        : { orderBy?: news_galleryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, news_galleryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNews_galleryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the news_gallery model
   */
  readonly fields: news_galleryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for news_gallery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__news_galleryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the news_gallery model
   */ 
  interface news_galleryFieldRefs {
    readonly id: FieldRef<"news_gallery", 'Int'>
    readonly news_id: FieldRef<"news_gallery", 'Int'>
    readonly secret_key: FieldRef<"news_gallery", 'String'>
    readonly news_gallery_file: FieldRef<"news_gallery", 'String'>
    readonly is_active: FieldRef<"news_gallery", 'Int'>
    readonly is_publish: FieldRef<"news_gallery", 'Int'>
    readonly created_at: FieldRef<"news_gallery", 'DateTime'>
    readonly created_by: FieldRef<"news_gallery", 'String'>
    readonly updated_at: FieldRef<"news_gallery", 'DateTime'>
    readonly updated_by: FieldRef<"news_gallery", 'String'>
    readonly deleted_at: FieldRef<"news_gallery", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * news_gallery findUnique
   */
  export type news_galleryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * Filter, which news_gallery to fetch.
     */
    where: news_galleryWhereUniqueInput
  }


  /**
   * news_gallery findUniqueOrThrow
   */
  export type news_galleryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * Filter, which news_gallery to fetch.
     */
    where: news_galleryWhereUniqueInput
  }


  /**
   * news_gallery findFirst
   */
  export type news_galleryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * Filter, which news_gallery to fetch.
     */
    where?: news_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_galleries to fetch.
     */
    orderBy?: news_galleryOrderByWithRelationInput | news_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_galleries.
     */
    cursor?: news_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_galleries.
     */
    distinct?: News_galleryScalarFieldEnum | News_galleryScalarFieldEnum[]
  }


  /**
   * news_gallery findFirstOrThrow
   */
  export type news_galleryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * Filter, which news_gallery to fetch.
     */
    where?: news_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_galleries to fetch.
     */
    orderBy?: news_galleryOrderByWithRelationInput | news_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for news_galleries.
     */
    cursor?: news_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of news_galleries.
     */
    distinct?: News_galleryScalarFieldEnum | News_galleryScalarFieldEnum[]
  }


  /**
   * news_gallery findMany
   */
  export type news_galleryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * Filter, which news_galleries to fetch.
     */
    where?: news_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of news_galleries to fetch.
     */
    orderBy?: news_galleryOrderByWithRelationInput | news_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing news_galleries.
     */
    cursor?: news_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` news_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` news_galleries.
     */
    skip?: number
    distinct?: News_galleryScalarFieldEnum | News_galleryScalarFieldEnum[]
  }


  /**
   * news_gallery create
   */
  export type news_galleryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * The data needed to create a news_gallery.
     */
    data: XOR<news_galleryCreateInput, news_galleryUncheckedCreateInput>
  }


  /**
   * news_gallery createMany
   */
  export type news_galleryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many news_galleries.
     */
    data: news_galleryCreateManyInput | news_galleryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * news_gallery update
   */
  export type news_galleryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * The data needed to update a news_gallery.
     */
    data: XOR<news_galleryUpdateInput, news_galleryUncheckedUpdateInput>
    /**
     * Choose, which news_gallery to update.
     */
    where: news_galleryWhereUniqueInput
  }


  /**
   * news_gallery updateMany
   */
  export type news_galleryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update news_galleries.
     */
    data: XOR<news_galleryUpdateManyMutationInput, news_galleryUncheckedUpdateManyInput>
    /**
     * Filter which news_galleries to update
     */
    where?: news_galleryWhereInput
  }


  /**
   * news_gallery upsert
   */
  export type news_galleryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * The filter to search for the news_gallery to update in case it exists.
     */
    where: news_galleryWhereUniqueInput
    /**
     * In case the news_gallery found by the `where` argument doesn't exist, create a new news_gallery with this data.
     */
    create: XOR<news_galleryCreateInput, news_galleryUncheckedCreateInput>
    /**
     * In case the news_gallery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<news_galleryUpdateInput, news_galleryUncheckedUpdateInput>
  }


  /**
   * news_gallery delete
   */
  export type news_galleryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
    /**
     * Filter which news_gallery to delete.
     */
    where: news_galleryWhereUniqueInput
  }


  /**
   * news_gallery deleteMany
   */
  export type news_galleryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which news_galleries to delete
     */
    where?: news_galleryWhereInput
  }


  /**
   * news_gallery without action
   */
  export type news_galleryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the news_gallery
     */
    select?: news_gallerySelect<ExtArgs> | null
  }



  /**
   * Model equipment_department
   */


  export type AggregateEquipment_department = {
    _count: Equipment_departmentCountAggregateOutputType | null
    _avg: Equipment_departmentAvgAggregateOutputType | null
    _sum: Equipment_departmentSumAggregateOutputType | null
    _min: Equipment_departmentMinAggregateOutputType | null
    _max: Equipment_departmentMaxAggregateOutputType | null
  }

  export type Equipment_departmentAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_departmentSumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_departmentMinAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    name_short: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_departmentMaxAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    name_short: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_departmentCountAggregateOutputType = {
    id: number
    name_th: number
    name_en: number
    name_short: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type Equipment_departmentAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_departmentSumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_departmentMinAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_departmentMaxAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_departmentCountAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Equipment_departmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_department to aggregate.
     */
    where?: equipment_departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_departments to fetch.
     */
    orderBy?: equipment_departmentOrderByWithRelationInput | equipment_departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipment_departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment_departments
    **/
    _count?: true | Equipment_departmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Equipment_departmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Equipment_departmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Equipment_departmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Equipment_departmentMaxAggregateInputType
  }

  export type GetEquipment_departmentAggregateType<T extends Equipment_departmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment_department]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment_department[P]>
      : GetScalarType<T[P], AggregateEquipment_department[P]>
  }




  export type equipment_departmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_departmentWhereInput
    orderBy?: equipment_departmentOrderByWithAggregationInput | equipment_departmentOrderByWithAggregationInput[]
    by: Equipment_departmentScalarFieldEnum[] | Equipment_departmentScalarFieldEnum
    having?: equipment_departmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Equipment_departmentCountAggregateInputType | true
    _avg?: Equipment_departmentAvgAggregateInputType
    _sum?: Equipment_departmentSumAggregateInputType
    _min?: Equipment_departmentMinAggregateInputType
    _max?: Equipment_departmentMaxAggregateInputType
  }


  export type Equipment_departmentGroupByOutputType = {
    id: number
    name_th: string | null
    name_en: string | null
    name_short: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: Equipment_departmentCountAggregateOutputType | null
    _avg: Equipment_departmentAvgAggregateOutputType | null
    _sum: Equipment_departmentSumAggregateOutputType | null
    _min: Equipment_departmentMinAggregateOutputType | null
    _max: Equipment_departmentMaxAggregateOutputType | null
  }

  type GetEquipment_departmentGroupByPayload<T extends equipment_departmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Equipment_departmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Equipment_departmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Equipment_departmentGroupByOutputType[P]>
            : GetScalarType<T[P], Equipment_departmentGroupByOutputType[P]>
        }
      >
    >


  export type equipment_departmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    name_short?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    equipments?: boolean | equipment_department$equipmentsArgs<ExtArgs>
    _count?: boolean | Equipment_departmentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["equipment_department"]>

  export type equipment_departmentSelectScalar = {
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    name_short?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type equipment_departmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipments?: boolean | equipment_department$equipmentsArgs<ExtArgs>
    _count?: boolean | Equipment_departmentCountOutputTypeArgs<ExtArgs>
  }


  type equipment_departmentGetPayload<S extends boolean | null | undefined | equipment_departmentArgs> = $Types.GetResult<equipment_departmentPayload, S>

  type equipment_departmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipment_departmentFindManyArgs, 'select' | 'include'> & {
      select?: Equipment_departmentCountAggregateInputType | true
    }

  export interface equipment_departmentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment_department'], meta: { name: 'equipment_department' } }
    /**
     * Find zero or one Equipment_department that matches the filter.
     * @param {equipment_departmentFindUniqueArgs} args - Arguments to find a Equipment_department
     * @example
     * // Get one Equipment_department
     * const equipment_department = await prisma.equipment_department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipment_departmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_departmentFindUniqueArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment_department that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipment_departmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment_department
     * @example
     * // Get one Equipment_department
     * const equipment_department = await prisma.equipment_department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipment_departmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_departmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment_department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_departmentFindFirstArgs} args - Arguments to find a Equipment_department
     * @example
     * // Get one Equipment_department
     * const equipment_department = await prisma.equipment_department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipment_departmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_departmentFindFirstArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment_department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_departmentFindFirstOrThrowArgs} args - Arguments to find a Equipment_department
     * @example
     * // Get one Equipment_department
     * const equipment_department = await prisma.equipment_department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipment_departmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_departmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment_departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_departmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment_departments
     * const equipment_departments = await prisma.equipment_department.findMany()
     * 
     * // Get first 10 Equipment_departments
     * const equipment_departments = await prisma.equipment_department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipment_departmentWithIdOnly = await prisma.equipment_department.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipment_departmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_departmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment_department.
     * @param {equipment_departmentCreateArgs} args - Arguments to create a Equipment_department.
     * @example
     * // Create one Equipment_department
     * const Equipment_department = await prisma.equipment_department.create({
     *   data: {
     *     // ... data to create a Equipment_department
     *   }
     * })
     * 
    **/
    create<T extends equipment_departmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_departmentCreateArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment_departments.
     *     @param {equipment_departmentCreateManyArgs} args - Arguments to create many Equipment_departments.
     *     @example
     *     // Create many Equipment_departments
     *     const equipment_department = await prisma.equipment_department.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipment_departmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_departmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment_department.
     * @param {equipment_departmentDeleteArgs} args - Arguments to delete one Equipment_department.
     * @example
     * // Delete one Equipment_department
     * const Equipment_department = await prisma.equipment_department.delete({
     *   where: {
     *     // ... filter to delete one Equipment_department
     *   }
     * })
     * 
    **/
    delete<T extends equipment_departmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_departmentDeleteArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment_department.
     * @param {equipment_departmentUpdateArgs} args - Arguments to update one Equipment_department.
     * @example
     * // Update one Equipment_department
     * const equipment_department = await prisma.equipment_department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipment_departmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_departmentUpdateArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment_departments.
     * @param {equipment_departmentDeleteManyArgs} args - Arguments to filter Equipment_departments to delete.
     * @example
     * // Delete a few Equipment_departments
     * const { count } = await prisma.equipment_department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipment_departmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_departmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment_departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_departmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment_departments
     * const equipment_department = await prisma.equipment_department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipment_departmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_departmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment_department.
     * @param {equipment_departmentUpsertArgs} args - Arguments to update or create a Equipment_department.
     * @example
     * // Update or create a Equipment_department
     * const equipment_department = await prisma.equipment_department.upsert({
     *   create: {
     *     // ... data to create a Equipment_department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment_department we want to update
     *   }
     * })
    **/
    upsert<T extends equipment_departmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_departmentUpsertArgs<ExtArgs>>
    ): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment_departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_departmentCountArgs} args - Arguments to filter Equipment_departments to count.
     * @example
     * // Count the number of Equipment_departments
     * const count = await prisma.equipment_department.count({
     *   where: {
     *     // ... the filter for the Equipment_departments we want to count
     *   }
     * })
    **/
    count<T extends equipment_departmentCountArgs>(
      args?: Subset<T, equipment_departmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Equipment_departmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment_department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Equipment_departmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Equipment_departmentAggregateArgs>(args: Subset<T, Equipment_departmentAggregateArgs>): Prisma.PrismaPromise<GetEquipment_departmentAggregateType<T>>

    /**
     * Group by Equipment_department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_departmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipment_departmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipment_departmentGroupByArgs['orderBy'] }
        : { orderBy?: equipment_departmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipment_departmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipment_departmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment_department model
   */
  readonly fields: equipment_departmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment_department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipment_departmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipments<T extends equipment_department$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, equipment_department$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment_department model
   */ 
  interface equipment_departmentFieldRefs {
    readonly id: FieldRef<"equipment_department", 'Int'>
    readonly name_th: FieldRef<"equipment_department", 'String'>
    readonly name_en: FieldRef<"equipment_department", 'String'>
    readonly name_short: FieldRef<"equipment_department", 'String'>
    readonly is_active: FieldRef<"equipment_department", 'Int'>
    readonly is_publish: FieldRef<"equipment_department", 'Int'>
    readonly created_at: FieldRef<"equipment_department", 'DateTime'>
    readonly created_by: FieldRef<"equipment_department", 'String'>
    readonly updated_at: FieldRef<"equipment_department", 'DateTime'>
    readonly updated_by: FieldRef<"equipment_department", 'String'>
    readonly deleted_at: FieldRef<"equipment_department", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment_department findUnique
   */
  export type equipment_departmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment_department to fetch.
     */
    where: equipment_departmentWhereUniqueInput
  }


  /**
   * equipment_department findUniqueOrThrow
   */
  export type equipment_departmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment_department to fetch.
     */
    where: equipment_departmentWhereUniqueInput
  }


  /**
   * equipment_department findFirst
   */
  export type equipment_departmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment_department to fetch.
     */
    where?: equipment_departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_departments to fetch.
     */
    orderBy?: equipment_departmentOrderByWithRelationInput | equipment_departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_departments.
     */
    cursor?: equipment_departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_departments.
     */
    distinct?: Equipment_departmentScalarFieldEnum | Equipment_departmentScalarFieldEnum[]
  }


  /**
   * equipment_department findFirstOrThrow
   */
  export type equipment_departmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment_department to fetch.
     */
    where?: equipment_departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_departments to fetch.
     */
    orderBy?: equipment_departmentOrderByWithRelationInput | equipment_departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_departments.
     */
    cursor?: equipment_departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_departments.
     */
    distinct?: Equipment_departmentScalarFieldEnum | Equipment_departmentScalarFieldEnum[]
  }


  /**
   * equipment_department findMany
   */
  export type equipment_departmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment_departments to fetch.
     */
    where?: equipment_departmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_departments to fetch.
     */
    orderBy?: equipment_departmentOrderByWithRelationInput | equipment_departmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment_departments.
     */
    cursor?: equipment_departmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_departments.
     */
    skip?: number
    distinct?: Equipment_departmentScalarFieldEnum | Equipment_departmentScalarFieldEnum[]
  }


  /**
   * equipment_department create
   */
  export type equipment_departmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment_department.
     */
    data?: XOR<equipment_departmentCreateInput, equipment_departmentUncheckedCreateInput>
  }


  /**
   * equipment_department createMany
   */
  export type equipment_departmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment_departments.
     */
    data: equipment_departmentCreateManyInput | equipment_departmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment_department update
   */
  export type equipment_departmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment_department.
     */
    data: XOR<equipment_departmentUpdateInput, equipment_departmentUncheckedUpdateInput>
    /**
     * Choose, which equipment_department to update.
     */
    where: equipment_departmentWhereUniqueInput
  }


  /**
   * equipment_department updateMany
   */
  export type equipment_departmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment_departments.
     */
    data: XOR<equipment_departmentUpdateManyMutationInput, equipment_departmentUncheckedUpdateManyInput>
    /**
     * Filter which equipment_departments to update
     */
    where?: equipment_departmentWhereInput
  }


  /**
   * equipment_department upsert
   */
  export type equipment_departmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment_department to update in case it exists.
     */
    where: equipment_departmentWhereUniqueInput
    /**
     * In case the equipment_department found by the `where` argument doesn't exist, create a new equipment_department with this data.
     */
    create: XOR<equipment_departmentCreateInput, equipment_departmentUncheckedCreateInput>
    /**
     * In case the equipment_department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipment_departmentUpdateInput, equipment_departmentUncheckedUpdateInput>
  }


  /**
   * equipment_department delete
   */
  export type equipment_departmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
    /**
     * Filter which equipment_department to delete.
     */
    where: equipment_departmentWhereUniqueInput
  }


  /**
   * equipment_department deleteMany
   */
  export type equipment_departmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_departments to delete
     */
    where?: equipment_departmentWhereInput
  }


  /**
   * equipment_department.equipments
   */
  export type equipment_department$equipmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    where?: equipmentWhereInput
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    cursor?: equipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment_department without action
   */
  export type equipment_departmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_department
     */
    select?: equipment_departmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_departmentInclude<ExtArgs> | null
  }



  /**
   * Model equipment_category
   */


  export type AggregateEquipment_category = {
    _count: Equipment_categoryCountAggregateOutputType | null
    _avg: Equipment_categoryAvgAggregateOutputType | null
    _sum: Equipment_categorySumAggregateOutputType | null
    _min: Equipment_categoryMinAggregateOutputType | null
    _max: Equipment_categoryMaxAggregateOutputType | null
  }

  export type Equipment_categoryAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_categorySumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_categoryMinAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    name_short: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_categoryMaxAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    name_short: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_categoryCountAggregateOutputType = {
    id: number
    name_th: number
    name_en: number
    name_short: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type Equipment_categoryAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_categorySumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_categoryMinAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_categoryMaxAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_categoryCountAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Equipment_categoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_category to aggregate.
     */
    where?: equipment_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_categories to fetch.
     */
    orderBy?: equipment_categoryOrderByWithRelationInput | equipment_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipment_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment_categories
    **/
    _count?: true | Equipment_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Equipment_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Equipment_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Equipment_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Equipment_categoryMaxAggregateInputType
  }

  export type GetEquipment_categoryAggregateType<T extends Equipment_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment_category[P]>
      : GetScalarType<T[P], AggregateEquipment_category[P]>
  }




  export type equipment_categoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_categoryWhereInput
    orderBy?: equipment_categoryOrderByWithAggregationInput | equipment_categoryOrderByWithAggregationInput[]
    by: Equipment_categoryScalarFieldEnum[] | Equipment_categoryScalarFieldEnum
    having?: equipment_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Equipment_categoryCountAggregateInputType | true
    _avg?: Equipment_categoryAvgAggregateInputType
    _sum?: Equipment_categorySumAggregateInputType
    _min?: Equipment_categoryMinAggregateInputType
    _max?: Equipment_categoryMaxAggregateInputType
  }


  export type Equipment_categoryGroupByOutputType = {
    id: number
    name_th: string
    name_en: string | null
    name_short: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: Equipment_categoryCountAggregateOutputType | null
    _avg: Equipment_categoryAvgAggregateOutputType | null
    _sum: Equipment_categorySumAggregateOutputType | null
    _min: Equipment_categoryMinAggregateOutputType | null
    _max: Equipment_categoryMaxAggregateOutputType | null
  }

  type GetEquipment_categoryGroupByPayload<T extends equipment_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Equipment_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Equipment_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Equipment_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Equipment_categoryGroupByOutputType[P]>
        }
      >
    >


  export type equipment_categorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    name_short?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    equipments?: boolean | equipment_category$equipmentsArgs<ExtArgs>
    _count?: boolean | Equipment_categoryCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["equipment_category"]>

  export type equipment_categorySelectScalar = {
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    name_short?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type equipment_categoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipments?: boolean | equipment_category$equipmentsArgs<ExtArgs>
    _count?: boolean | Equipment_categoryCountOutputTypeArgs<ExtArgs>
  }


  type equipment_categoryGetPayload<S extends boolean | null | undefined | equipment_categoryArgs> = $Types.GetResult<equipment_categoryPayload, S>

  type equipment_categoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipment_categoryFindManyArgs, 'select' | 'include'> & {
      select?: Equipment_categoryCountAggregateInputType | true
    }

  export interface equipment_categoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment_category'], meta: { name: 'equipment_category' } }
    /**
     * Find zero or one Equipment_category that matches the filter.
     * @param {equipment_categoryFindUniqueArgs} args - Arguments to find a Equipment_category
     * @example
     * // Get one Equipment_category
     * const equipment_category = await prisma.equipment_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipment_categoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_categoryFindUniqueArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment_category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipment_categoryFindUniqueOrThrowArgs} args - Arguments to find a Equipment_category
     * @example
     * // Get one Equipment_category
     * const equipment_category = await prisma.equipment_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipment_categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_categoryFindFirstArgs} args - Arguments to find a Equipment_category
     * @example
     * // Get one Equipment_category
     * const equipment_category = await prisma.equipment_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipment_categoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_categoryFindFirstArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_categoryFindFirstOrThrowArgs} args - Arguments to find a Equipment_category
     * @example
     * // Get one Equipment_category
     * const equipment_category = await prisma.equipment_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipment_categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment_categories
     * const equipment_categories = await prisma.equipment_category.findMany()
     * 
     * // Get first 10 Equipment_categories
     * const equipment_categories = await prisma.equipment_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipment_categoryWithIdOnly = await prisma.equipment_category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipment_categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment_category.
     * @param {equipment_categoryCreateArgs} args - Arguments to create a Equipment_category.
     * @example
     * // Create one Equipment_category
     * const Equipment_category = await prisma.equipment_category.create({
     *   data: {
     *     // ... data to create a Equipment_category
     *   }
     * })
     * 
    **/
    create<T extends equipment_categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_categoryCreateArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment_categories.
     *     @param {equipment_categoryCreateManyArgs} args - Arguments to create many Equipment_categories.
     *     @example
     *     // Create many Equipment_categories
     *     const equipment_category = await prisma.equipment_category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipment_categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment_category.
     * @param {equipment_categoryDeleteArgs} args - Arguments to delete one Equipment_category.
     * @example
     * // Delete one Equipment_category
     * const Equipment_category = await prisma.equipment_category.delete({
     *   where: {
     *     // ... filter to delete one Equipment_category
     *   }
     * })
     * 
    **/
    delete<T extends equipment_categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_categoryDeleteArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment_category.
     * @param {equipment_categoryUpdateArgs} args - Arguments to update one Equipment_category.
     * @example
     * // Update one Equipment_category
     * const equipment_category = await prisma.equipment_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipment_categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_categoryUpdateArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment_categories.
     * @param {equipment_categoryDeleteManyArgs} args - Arguments to filter Equipment_categories to delete.
     * @example
     * // Delete a few Equipment_categories
     * const { count } = await prisma.equipment_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipment_categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment_categories
     * const equipment_category = await prisma.equipment_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipment_categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment_category.
     * @param {equipment_categoryUpsertArgs} args - Arguments to update or create a Equipment_category.
     * @example
     * // Update or create a Equipment_category
     * const equipment_category = await prisma.equipment_category.upsert({
     *   create: {
     *     // ... data to create a Equipment_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment_category we want to update
     *   }
     * })
    **/
    upsert<T extends equipment_categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_categoryUpsertArgs<ExtArgs>>
    ): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_categoryCountArgs} args - Arguments to filter Equipment_categories to count.
     * @example
     * // Count the number of Equipment_categories
     * const count = await prisma.equipment_category.count({
     *   where: {
     *     // ... the filter for the Equipment_categories we want to count
     *   }
     * })
    **/
    count<T extends equipment_categoryCountArgs>(
      args?: Subset<T, equipment_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Equipment_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Equipment_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Equipment_categoryAggregateArgs>(args: Subset<T, Equipment_categoryAggregateArgs>): Prisma.PrismaPromise<GetEquipment_categoryAggregateType<T>>

    /**
     * Group by Equipment_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipment_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipment_categoryGroupByArgs['orderBy'] }
        : { orderBy?: equipment_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipment_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipment_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment_category model
   */
  readonly fields: equipment_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipment_categoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipments<T extends equipment_category$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, equipment_category$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment_category model
   */ 
  interface equipment_categoryFieldRefs {
    readonly id: FieldRef<"equipment_category", 'Int'>
    readonly name_th: FieldRef<"equipment_category", 'String'>
    readonly name_en: FieldRef<"equipment_category", 'String'>
    readonly name_short: FieldRef<"equipment_category", 'String'>
    readonly is_active: FieldRef<"equipment_category", 'Int'>
    readonly is_publish: FieldRef<"equipment_category", 'Int'>
    readonly created_at: FieldRef<"equipment_category", 'DateTime'>
    readonly created_by: FieldRef<"equipment_category", 'String'>
    readonly updated_at: FieldRef<"equipment_category", 'DateTime'>
    readonly updated_by: FieldRef<"equipment_category", 'String'>
    readonly deleted_at: FieldRef<"equipment_category", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment_category findUnique
   */
  export type equipment_categoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * Filter, which equipment_category to fetch.
     */
    where: equipment_categoryWhereUniqueInput
  }


  /**
   * equipment_category findUniqueOrThrow
   */
  export type equipment_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * Filter, which equipment_category to fetch.
     */
    where: equipment_categoryWhereUniqueInput
  }


  /**
   * equipment_category findFirst
   */
  export type equipment_categoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * Filter, which equipment_category to fetch.
     */
    where?: equipment_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_categories to fetch.
     */
    orderBy?: equipment_categoryOrderByWithRelationInput | equipment_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_categories.
     */
    cursor?: equipment_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_categories.
     */
    distinct?: Equipment_categoryScalarFieldEnum | Equipment_categoryScalarFieldEnum[]
  }


  /**
   * equipment_category findFirstOrThrow
   */
  export type equipment_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * Filter, which equipment_category to fetch.
     */
    where?: equipment_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_categories to fetch.
     */
    orderBy?: equipment_categoryOrderByWithRelationInput | equipment_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_categories.
     */
    cursor?: equipment_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_categories.
     */
    distinct?: Equipment_categoryScalarFieldEnum | Equipment_categoryScalarFieldEnum[]
  }


  /**
   * equipment_category findMany
   */
  export type equipment_categoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * Filter, which equipment_categories to fetch.
     */
    where?: equipment_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_categories to fetch.
     */
    orderBy?: equipment_categoryOrderByWithRelationInput | equipment_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment_categories.
     */
    cursor?: equipment_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_categories.
     */
    skip?: number
    distinct?: Equipment_categoryScalarFieldEnum | Equipment_categoryScalarFieldEnum[]
  }


  /**
   * equipment_category create
   */
  export type equipment_categoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment_category.
     */
    data: XOR<equipment_categoryCreateInput, equipment_categoryUncheckedCreateInput>
  }


  /**
   * equipment_category createMany
   */
  export type equipment_categoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment_categories.
     */
    data: equipment_categoryCreateManyInput | equipment_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment_category update
   */
  export type equipment_categoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment_category.
     */
    data: XOR<equipment_categoryUpdateInput, equipment_categoryUncheckedUpdateInput>
    /**
     * Choose, which equipment_category to update.
     */
    where: equipment_categoryWhereUniqueInput
  }


  /**
   * equipment_category updateMany
   */
  export type equipment_categoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment_categories.
     */
    data: XOR<equipment_categoryUpdateManyMutationInput, equipment_categoryUncheckedUpdateManyInput>
    /**
     * Filter which equipment_categories to update
     */
    where?: equipment_categoryWhereInput
  }


  /**
   * equipment_category upsert
   */
  export type equipment_categoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment_category to update in case it exists.
     */
    where: equipment_categoryWhereUniqueInput
    /**
     * In case the equipment_category found by the `where` argument doesn't exist, create a new equipment_category with this data.
     */
    create: XOR<equipment_categoryCreateInput, equipment_categoryUncheckedCreateInput>
    /**
     * In case the equipment_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipment_categoryUpdateInput, equipment_categoryUncheckedUpdateInput>
  }


  /**
   * equipment_category delete
   */
  export type equipment_categoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
    /**
     * Filter which equipment_category to delete.
     */
    where: equipment_categoryWhereUniqueInput
  }


  /**
   * equipment_category deleteMany
   */
  export type equipment_categoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_categories to delete
     */
    where?: equipment_categoryWhereInput
  }


  /**
   * equipment_category.equipments
   */
  export type equipment_category$equipmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    where?: equipmentWhereInput
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    cursor?: equipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment_category without action
   */
  export type equipment_categoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_category
     */
    select?: equipment_categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_categoryInclude<ExtArgs> | null
  }



  /**
   * Model equipment
   */


  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    id: number | null
    equipment_category_id: number | null
    equipment_department_id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    id: number | null
    equipment_category_id: number | null
    equipment_department_id: number | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: number | null
    equipment_category_id: number | null
    equipment_department_id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    equipment_file: string | null
    rate_file: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_equipment: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: number | null
    equipment_category_id: number | null
    equipment_department_id: number | null
    title_th: string | null
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    equipment_file: string | null
    rate_file: string | null
    is_active: number | null
    is_publish: number | null
    count_views: number | null
    created_equipment: Date | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: number
    title_en: number
    detail_th: number
    detail_en: number
    equipment_file: number
    rate_file: number
    is_active: number
    is_publish: number
    count_views: number
    created_equipment: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    id?: true
    equipment_category_id?: true
    equipment_department_id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type EquipmentSumAggregateInputType = {
    id?: true
    equipment_category_id?: true
    equipment_department_id?: true
    is_active?: true
    is_publish?: true
    count_views?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    equipment_category_id?: true
    equipment_department_id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    equipment_file?: true
    rate_file?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_equipment?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    equipment_category_id?: true
    equipment_department_id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    equipment_file?: true
    rate_file?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_equipment?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    equipment_category_id?: true
    equipment_department_id?: true
    title_th?: true
    title_en?: true
    detail_th?: true
    detail_en?: true
    equipment_file?: true
    rate_file?: true
    is_active?: true
    is_publish?: true
    count_views?: true
    created_equipment?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment to aggregate.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type equipmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipmentWhereInput
    orderBy?: equipmentOrderByWithAggregationInput | equipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: equipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }


  export type EquipmentGroupByOutputType = {
    id: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: string
    title_en: string | null
    detail_th: string | null
    detail_en: string | null
    equipment_file: string | null
    rate_file: string | null
    is_active: number
    is_publish: number
    count_views: number
    created_equipment: Date
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends equipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type equipmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipment_category_id?: boolean
    equipment_department_id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    equipment_file?: boolean
    rate_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_equipment?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    equipment_category?: boolean | equipment_categoryArgs<ExtArgs>
    equipment_department?: boolean | equipment_departmentArgs<ExtArgs>
    equipment_method?: boolean | equipment$equipment_methodArgs<ExtArgs>
    equipment_booking?: boolean | equipment$equipment_bookingArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type equipmentSelectScalar = {
    id?: boolean
    equipment_category_id?: boolean
    equipment_department_id?: boolean
    title_th?: boolean
    title_en?: boolean
    detail_th?: boolean
    detail_en?: boolean
    equipment_file?: boolean
    rate_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    count_views?: boolean
    created_equipment?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type equipmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment_category?: boolean | equipment_categoryArgs<ExtArgs>
    equipment_department?: boolean | equipment_departmentArgs<ExtArgs>
    equipment_method?: boolean | equipment$equipment_methodArgs<ExtArgs>
    equipment_booking?: boolean | equipment$equipment_bookingArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeArgs<ExtArgs>
  }


  type equipmentGetPayload<S extends boolean | null | undefined | equipmentArgs> = $Types.GetResult<equipmentPayload, S>

  type equipmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipmentFindManyArgs, 'select' | 'include'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface equipmentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment'], meta: { name: 'equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {equipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipmentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentFindUniqueArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipmentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindFirstArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment.
     * @param {equipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
    **/
    create<T extends equipmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentCreateArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment.
     *     @param {equipmentCreateManyArgs} args - Arguments to create many Equipment.
     *     @example
     *     // Create many Equipment
     *     const equipment = await prisma.equipment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment.
     * @param {equipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
    **/
    delete<T extends equipmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentDeleteArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment.
     * @param {equipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentUpdateArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment.
     * @param {equipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment.
     * @param {equipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
    **/
    upsert<T extends equipmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipmentUpsertArgs<ExtArgs>>
    ): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends equipmentCountArgs>(
      args?: Subset<T, equipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipmentGroupByArgs['orderBy'] }
        : { orderBy?: equipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment model
   */
  readonly fields: equipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment_category<T extends equipment_categoryArgs<ExtArgs> = {}>(args?: Subset<T, equipment_categoryArgs<ExtArgs>>): Prisma__equipment_categoryClient<$Types.GetResult<equipment_categoryPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment_department<T extends equipment_departmentArgs<ExtArgs> = {}>(args?: Subset<T, equipment_departmentArgs<ExtArgs>>): Prisma__equipment_departmentClient<$Types.GetResult<equipment_departmentPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment_method<T extends equipment$equipment_methodArgs<ExtArgs> = {}>(args?: Subset<T, equipment$equipment_methodArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findMany'>| Null>;

    equipment_booking<T extends equipment$equipment_bookingArgs<ExtArgs> = {}>(args?: Subset<T, equipment$equipment_bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment model
   */ 
  interface equipmentFieldRefs {
    readonly id: FieldRef<"equipment", 'Int'>
    readonly equipment_category_id: FieldRef<"equipment", 'Int'>
    readonly equipment_department_id: FieldRef<"equipment", 'Int'>
    readonly title_th: FieldRef<"equipment", 'String'>
    readonly title_en: FieldRef<"equipment", 'String'>
    readonly detail_th: FieldRef<"equipment", 'String'>
    readonly detail_en: FieldRef<"equipment", 'String'>
    readonly equipment_file: FieldRef<"equipment", 'String'>
    readonly rate_file: FieldRef<"equipment", 'String'>
    readonly is_active: FieldRef<"equipment", 'Int'>
    readonly is_publish: FieldRef<"equipment", 'Int'>
    readonly count_views: FieldRef<"equipment", 'Int'>
    readonly created_equipment: FieldRef<"equipment", 'DateTime'>
    readonly created_at: FieldRef<"equipment", 'DateTime'>
    readonly created_by: FieldRef<"equipment", 'String'>
    readonly updated_at: FieldRef<"equipment", 'DateTime'>
    readonly updated_by: FieldRef<"equipment", 'String'>
    readonly deleted_at: FieldRef<"equipment", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment findUnique
   */
  export type equipmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment findUniqueOrThrow
   */
  export type equipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment findFirst
   */
  export type equipmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment.
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment findFirstOrThrow
   */
  export type equipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment.
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment findMany
   */
  export type equipmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter, which equipment to fetch.
     */
    where?: equipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment to fetch.
     */
    orderBy?: equipmentOrderByWithRelationInput | equipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment.
     */
    cursor?: equipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }


  /**
   * equipment create
   */
  export type equipmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment.
     */
    data: XOR<equipmentCreateInput, equipmentUncheckedCreateInput>
  }


  /**
   * equipment createMany
   */
  export type equipmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment.
     */
    data: equipmentCreateManyInput | equipmentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment update
   */
  export type equipmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment.
     */
    data: XOR<equipmentUpdateInput, equipmentUncheckedUpdateInput>
    /**
     * Choose, which equipment to update.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment updateMany
   */
  export type equipmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment.
     */
    data: XOR<equipmentUpdateManyMutationInput, equipmentUncheckedUpdateManyInput>
    /**
     * Filter which equipment to update
     */
    where?: equipmentWhereInput
  }


  /**
   * equipment upsert
   */
  export type equipmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment to update in case it exists.
     */
    where: equipmentWhereUniqueInput
    /**
     * In case the equipment found by the `where` argument doesn't exist, create a new equipment with this data.
     */
    create: XOR<equipmentCreateInput, equipmentUncheckedCreateInput>
    /**
     * In case the equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipmentUpdateInput, equipmentUncheckedUpdateInput>
  }


  /**
   * equipment delete
   */
  export type equipmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
    /**
     * Filter which equipment to delete.
     */
    where: equipmentWhereUniqueInput
  }


  /**
   * equipment deleteMany
   */
  export type equipmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment to delete
     */
    where?: equipmentWhereInput
  }


  /**
   * equipment.equipment_method
   */
  export type equipment$equipment_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    where?: equipment_methodWhereInput
    orderBy?: equipment_methodOrderByWithRelationInput | equipment_methodOrderByWithRelationInput[]
    cursor?: equipment_methodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Equipment_methodScalarFieldEnum | Equipment_methodScalarFieldEnum[]
  }


  /**
   * equipment.equipment_booking
   */
  export type equipment$equipment_bookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    where?: equipment_bookingWhereInput
    orderBy?: equipment_bookingOrderByWithRelationInput | equipment_bookingOrderByWithRelationInput[]
    cursor?: equipment_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Equipment_bookingScalarFieldEnum | Equipment_bookingScalarFieldEnum[]
  }


  /**
   * equipment without action
   */
  export type equipmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment
     */
    select?: equipmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipmentInclude<ExtArgs> | null
  }



  /**
   * Model equipment_gallery
   */


  export type AggregateEquipment_gallery = {
    _count: Equipment_galleryCountAggregateOutputType | null
    _avg: Equipment_galleryAvgAggregateOutputType | null
    _sum: Equipment_gallerySumAggregateOutputType | null
    _min: Equipment_galleryMinAggregateOutputType | null
    _max: Equipment_galleryMaxAggregateOutputType | null
  }

  export type Equipment_galleryAvgAggregateOutputType = {
    id: number | null
    equipment_id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_gallerySumAggregateOutputType = {
    id: number | null
    equipment_id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_galleryMinAggregateOutputType = {
    id: number | null
    equipment_id: number | null
    secret_key: string | null
    equipment_gallery_file: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_galleryMaxAggregateOutputType = {
    id: number | null
    equipment_id: number | null
    secret_key: string | null
    equipment_gallery_file: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_galleryCountAggregateOutputType = {
    id: number
    equipment_id: number
    secret_key: number
    equipment_gallery_file: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type Equipment_galleryAvgAggregateInputType = {
    id?: true
    equipment_id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_gallerySumAggregateInputType = {
    id?: true
    equipment_id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_galleryMinAggregateInputType = {
    id?: true
    equipment_id?: true
    secret_key?: true
    equipment_gallery_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_galleryMaxAggregateInputType = {
    id?: true
    equipment_id?: true
    secret_key?: true
    equipment_gallery_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_galleryCountAggregateInputType = {
    id?: true
    equipment_id?: true
    secret_key?: true
    equipment_gallery_file?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Equipment_galleryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_gallery to aggregate.
     */
    where?: equipment_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_galleries to fetch.
     */
    orderBy?: equipment_galleryOrderByWithRelationInput | equipment_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipment_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment_galleries
    **/
    _count?: true | Equipment_galleryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Equipment_galleryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Equipment_gallerySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Equipment_galleryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Equipment_galleryMaxAggregateInputType
  }

  export type GetEquipment_galleryAggregateType<T extends Equipment_galleryAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment_gallery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment_gallery[P]>
      : GetScalarType<T[P], AggregateEquipment_gallery[P]>
  }




  export type equipment_galleryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_galleryWhereInput
    orderBy?: equipment_galleryOrderByWithAggregationInput | equipment_galleryOrderByWithAggregationInput[]
    by: Equipment_galleryScalarFieldEnum[] | Equipment_galleryScalarFieldEnum
    having?: equipment_galleryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Equipment_galleryCountAggregateInputType | true
    _avg?: Equipment_galleryAvgAggregateInputType
    _sum?: Equipment_gallerySumAggregateInputType
    _min?: Equipment_galleryMinAggregateInputType
    _max?: Equipment_galleryMaxAggregateInputType
  }


  export type Equipment_galleryGroupByOutputType = {
    id: number
    equipment_id: number | null
    secret_key: string
    equipment_gallery_file: string
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: Equipment_galleryCountAggregateOutputType | null
    _avg: Equipment_galleryAvgAggregateOutputType | null
    _sum: Equipment_gallerySumAggregateOutputType | null
    _min: Equipment_galleryMinAggregateOutputType | null
    _max: Equipment_galleryMaxAggregateOutputType | null
  }

  type GetEquipment_galleryGroupByPayload<T extends equipment_galleryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Equipment_galleryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Equipment_galleryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Equipment_galleryGroupByOutputType[P]>
            : GetScalarType<T[P], Equipment_galleryGroupByOutputType[P]>
        }
      >
    >


  export type equipment_gallerySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipment_id?: boolean
    secret_key?: boolean
    equipment_gallery_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["equipment_gallery"]>

  export type equipment_gallerySelectScalar = {
    id?: boolean
    equipment_id?: boolean
    secret_key?: boolean
    equipment_gallery_file?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }


  type equipment_galleryGetPayload<S extends boolean | null | undefined | equipment_galleryArgs> = $Types.GetResult<equipment_galleryPayload, S>

  type equipment_galleryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipment_galleryFindManyArgs, 'select' | 'include'> & {
      select?: Equipment_galleryCountAggregateInputType | true
    }

  export interface equipment_galleryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment_gallery'], meta: { name: 'equipment_gallery' } }
    /**
     * Find zero or one Equipment_gallery that matches the filter.
     * @param {equipment_galleryFindUniqueArgs} args - Arguments to find a Equipment_gallery
     * @example
     * // Get one Equipment_gallery
     * const equipment_gallery = await prisma.equipment_gallery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipment_galleryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_galleryFindUniqueArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment_gallery that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipment_galleryFindUniqueOrThrowArgs} args - Arguments to find a Equipment_gallery
     * @example
     * // Get one Equipment_gallery
     * const equipment_gallery = await prisma.equipment_gallery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipment_galleryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_galleryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment_gallery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_galleryFindFirstArgs} args - Arguments to find a Equipment_gallery
     * @example
     * // Get one Equipment_gallery
     * const equipment_gallery = await prisma.equipment_gallery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipment_galleryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_galleryFindFirstArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment_gallery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_galleryFindFirstOrThrowArgs} args - Arguments to find a Equipment_gallery
     * @example
     * // Get one Equipment_gallery
     * const equipment_gallery = await prisma.equipment_gallery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipment_galleryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_galleryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment_galleries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_galleryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment_galleries
     * const equipment_galleries = await prisma.equipment_gallery.findMany()
     * 
     * // Get first 10 Equipment_galleries
     * const equipment_galleries = await prisma.equipment_gallery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipment_galleryWithIdOnly = await prisma.equipment_gallery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipment_galleryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_galleryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment_gallery.
     * @param {equipment_galleryCreateArgs} args - Arguments to create a Equipment_gallery.
     * @example
     * // Create one Equipment_gallery
     * const Equipment_gallery = await prisma.equipment_gallery.create({
     *   data: {
     *     // ... data to create a Equipment_gallery
     *   }
     * })
     * 
    **/
    create<T extends equipment_galleryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_galleryCreateArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment_galleries.
     *     @param {equipment_galleryCreateManyArgs} args - Arguments to create many Equipment_galleries.
     *     @example
     *     // Create many Equipment_galleries
     *     const equipment_gallery = await prisma.equipment_gallery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipment_galleryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_galleryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment_gallery.
     * @param {equipment_galleryDeleteArgs} args - Arguments to delete one Equipment_gallery.
     * @example
     * // Delete one Equipment_gallery
     * const Equipment_gallery = await prisma.equipment_gallery.delete({
     *   where: {
     *     // ... filter to delete one Equipment_gallery
     *   }
     * })
     * 
    **/
    delete<T extends equipment_galleryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_galleryDeleteArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment_gallery.
     * @param {equipment_galleryUpdateArgs} args - Arguments to update one Equipment_gallery.
     * @example
     * // Update one Equipment_gallery
     * const equipment_gallery = await prisma.equipment_gallery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipment_galleryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_galleryUpdateArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment_galleries.
     * @param {equipment_galleryDeleteManyArgs} args - Arguments to filter Equipment_galleries to delete.
     * @example
     * // Delete a few Equipment_galleries
     * const { count } = await prisma.equipment_gallery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipment_galleryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_galleryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_galleryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment_galleries
     * const equipment_gallery = await prisma.equipment_gallery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipment_galleryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_galleryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment_gallery.
     * @param {equipment_galleryUpsertArgs} args - Arguments to update or create a Equipment_gallery.
     * @example
     * // Update or create a Equipment_gallery
     * const equipment_gallery = await prisma.equipment_gallery.upsert({
     *   create: {
     *     // ... data to create a Equipment_gallery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment_gallery we want to update
     *   }
     * })
    **/
    upsert<T extends equipment_galleryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_galleryUpsertArgs<ExtArgs>>
    ): Prisma__equipment_galleryClient<$Types.GetResult<equipment_galleryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment_galleries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_galleryCountArgs} args - Arguments to filter Equipment_galleries to count.
     * @example
     * // Count the number of Equipment_galleries
     * const count = await prisma.equipment_gallery.count({
     *   where: {
     *     // ... the filter for the Equipment_galleries we want to count
     *   }
     * })
    **/
    count<T extends equipment_galleryCountArgs>(
      args?: Subset<T, equipment_galleryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Equipment_galleryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment_gallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Equipment_galleryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Equipment_galleryAggregateArgs>(args: Subset<T, Equipment_galleryAggregateArgs>): Prisma.PrismaPromise<GetEquipment_galleryAggregateType<T>>

    /**
     * Group by Equipment_gallery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_galleryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipment_galleryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipment_galleryGroupByArgs['orderBy'] }
        : { orderBy?: equipment_galleryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipment_galleryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipment_galleryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment_gallery model
   */
  readonly fields: equipment_galleryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment_gallery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipment_galleryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment_gallery model
   */ 
  interface equipment_galleryFieldRefs {
    readonly id: FieldRef<"equipment_gallery", 'Int'>
    readonly equipment_id: FieldRef<"equipment_gallery", 'Int'>
    readonly secret_key: FieldRef<"equipment_gallery", 'String'>
    readonly equipment_gallery_file: FieldRef<"equipment_gallery", 'String'>
    readonly is_active: FieldRef<"equipment_gallery", 'Int'>
    readonly is_publish: FieldRef<"equipment_gallery", 'Int'>
    readonly created_at: FieldRef<"equipment_gallery", 'DateTime'>
    readonly created_by: FieldRef<"equipment_gallery", 'String'>
    readonly updated_at: FieldRef<"equipment_gallery", 'DateTime'>
    readonly updated_by: FieldRef<"equipment_gallery", 'String'>
    readonly deleted_at: FieldRef<"equipment_gallery", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment_gallery findUnique
   */
  export type equipment_galleryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * Filter, which equipment_gallery to fetch.
     */
    where: equipment_galleryWhereUniqueInput
  }


  /**
   * equipment_gallery findUniqueOrThrow
   */
  export type equipment_galleryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * Filter, which equipment_gallery to fetch.
     */
    where: equipment_galleryWhereUniqueInput
  }


  /**
   * equipment_gallery findFirst
   */
  export type equipment_galleryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * Filter, which equipment_gallery to fetch.
     */
    where?: equipment_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_galleries to fetch.
     */
    orderBy?: equipment_galleryOrderByWithRelationInput | equipment_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_galleries.
     */
    cursor?: equipment_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_galleries.
     */
    distinct?: Equipment_galleryScalarFieldEnum | Equipment_galleryScalarFieldEnum[]
  }


  /**
   * equipment_gallery findFirstOrThrow
   */
  export type equipment_galleryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * Filter, which equipment_gallery to fetch.
     */
    where?: equipment_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_galleries to fetch.
     */
    orderBy?: equipment_galleryOrderByWithRelationInput | equipment_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_galleries.
     */
    cursor?: equipment_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_galleries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_galleries.
     */
    distinct?: Equipment_galleryScalarFieldEnum | Equipment_galleryScalarFieldEnum[]
  }


  /**
   * equipment_gallery findMany
   */
  export type equipment_galleryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * Filter, which equipment_galleries to fetch.
     */
    where?: equipment_galleryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_galleries to fetch.
     */
    orderBy?: equipment_galleryOrderByWithRelationInput | equipment_galleryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment_galleries.
     */
    cursor?: equipment_galleryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_galleries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_galleries.
     */
    skip?: number
    distinct?: Equipment_galleryScalarFieldEnum | Equipment_galleryScalarFieldEnum[]
  }


  /**
   * equipment_gallery create
   */
  export type equipment_galleryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * The data needed to create a equipment_gallery.
     */
    data: XOR<equipment_galleryCreateInput, equipment_galleryUncheckedCreateInput>
  }


  /**
   * equipment_gallery createMany
   */
  export type equipment_galleryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment_galleries.
     */
    data: equipment_galleryCreateManyInput | equipment_galleryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment_gallery update
   */
  export type equipment_galleryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * The data needed to update a equipment_gallery.
     */
    data: XOR<equipment_galleryUpdateInput, equipment_galleryUncheckedUpdateInput>
    /**
     * Choose, which equipment_gallery to update.
     */
    where: equipment_galleryWhereUniqueInput
  }


  /**
   * equipment_gallery updateMany
   */
  export type equipment_galleryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment_galleries.
     */
    data: XOR<equipment_galleryUpdateManyMutationInput, equipment_galleryUncheckedUpdateManyInput>
    /**
     * Filter which equipment_galleries to update
     */
    where?: equipment_galleryWhereInput
  }


  /**
   * equipment_gallery upsert
   */
  export type equipment_galleryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * The filter to search for the equipment_gallery to update in case it exists.
     */
    where: equipment_galleryWhereUniqueInput
    /**
     * In case the equipment_gallery found by the `where` argument doesn't exist, create a new equipment_gallery with this data.
     */
    create: XOR<equipment_galleryCreateInput, equipment_galleryUncheckedCreateInput>
    /**
     * In case the equipment_gallery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipment_galleryUpdateInput, equipment_galleryUncheckedUpdateInput>
  }


  /**
   * equipment_gallery delete
   */
  export type equipment_galleryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
    /**
     * Filter which equipment_gallery to delete.
     */
    where: equipment_galleryWhereUniqueInput
  }


  /**
   * equipment_gallery deleteMany
   */
  export type equipment_galleryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_galleries to delete
     */
    where?: equipment_galleryWhereInput
  }


  /**
   * equipment_gallery without action
   */
  export type equipment_galleryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_gallery
     */
    select?: equipment_gallerySelect<ExtArgs> | null
  }



  /**
   * Model equipment_method
   */


  export type AggregateEquipment_method = {
    _count: Equipment_methodCountAggregateOutputType | null
    _avg: Equipment_methodAvgAggregateOutputType | null
    _sum: Equipment_methodSumAggregateOutputType | null
    _min: Equipment_methodMinAggregateOutputType | null
    _max: Equipment_methodMaxAggregateOutputType | null
  }

  export type Equipment_methodAvgAggregateOutputType = {
    id: number | null
    price: number | null
    is_fixrate: number | null
    is_active: number | null
    is_publish: number | null
    equipment_id: number | null
  }

  export type Equipment_methodSumAggregateOutputType = {
    id: number | null
    price: number | null
    is_fixrate: number | null
    is_active: number | null
    is_publish: number | null
    equipment_id: number | null
  }

  export type Equipment_methodMinAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    name_short: string | null
    unit_th: string | null
    unit_en: string | null
    price: number | null
    is_fixrate: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    equipment_id: number | null
  }

  export type Equipment_methodMaxAggregateOutputType = {
    id: number | null
    name_th: string | null
    name_en: string | null
    name_short: string | null
    unit_th: string | null
    unit_en: string | null
    price: number | null
    is_fixrate: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    equipment_id: number | null
  }

  export type Equipment_methodCountAggregateOutputType = {
    id: number
    name_th: number
    name_en: number
    name_short: number
    unit_th: number
    unit_en: number
    price: number
    is_fixrate: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    equipment_id: number
    _all: number
  }


  export type Equipment_methodAvgAggregateInputType = {
    id?: true
    price?: true
    is_fixrate?: true
    is_active?: true
    is_publish?: true
    equipment_id?: true
  }

  export type Equipment_methodSumAggregateInputType = {
    id?: true
    price?: true
    is_fixrate?: true
    is_active?: true
    is_publish?: true
    equipment_id?: true
  }

  export type Equipment_methodMinAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    unit_th?: true
    unit_en?: true
    price?: true
    is_fixrate?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    equipment_id?: true
  }

  export type Equipment_methodMaxAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    unit_th?: true
    unit_en?: true
    price?: true
    is_fixrate?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    equipment_id?: true
  }

  export type Equipment_methodCountAggregateInputType = {
    id?: true
    name_th?: true
    name_en?: true
    name_short?: true
    unit_th?: true
    unit_en?: true
    price?: true
    is_fixrate?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    equipment_id?: true
    _all?: true
  }

  export type Equipment_methodAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_method to aggregate.
     */
    where?: equipment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_methods to fetch.
     */
    orderBy?: equipment_methodOrderByWithRelationInput | equipment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment_methods
    **/
    _count?: true | Equipment_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Equipment_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Equipment_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Equipment_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Equipment_methodMaxAggregateInputType
  }

  export type GetEquipment_methodAggregateType<T extends Equipment_methodAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment_method[P]>
      : GetScalarType<T[P], AggregateEquipment_method[P]>
  }




  export type equipment_methodGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_methodWhereInput
    orderBy?: equipment_methodOrderByWithAggregationInput | equipment_methodOrderByWithAggregationInput[]
    by: Equipment_methodScalarFieldEnum[] | Equipment_methodScalarFieldEnum
    having?: equipment_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Equipment_methodCountAggregateInputType | true
    _avg?: Equipment_methodAvgAggregateInputType
    _sum?: Equipment_methodSumAggregateInputType
    _min?: Equipment_methodMinAggregateInputType
    _max?: Equipment_methodMaxAggregateInputType
  }


  export type Equipment_methodGroupByOutputType = {
    id: number
    name_th: string
    name_en: string | null
    name_short: string | null
    unit_th: string | null
    unit_en: string | null
    price: number | null
    is_fixrate: number | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    equipment_id: number
    _count: Equipment_methodCountAggregateOutputType | null
    _avg: Equipment_methodAvgAggregateOutputType | null
    _sum: Equipment_methodSumAggregateOutputType | null
    _min: Equipment_methodMinAggregateOutputType | null
    _max: Equipment_methodMaxAggregateOutputType | null
  }

  type GetEquipment_methodGroupByPayload<T extends equipment_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Equipment_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Equipment_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Equipment_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Equipment_methodGroupByOutputType[P]>
        }
      >
    >


  export type equipment_methodSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    name_short?: boolean
    unit_th?: boolean
    unit_en?: boolean
    price?: boolean
    is_fixrate?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    equipment_id?: boolean
    equipment?: boolean | equipmentArgs<ExtArgs>
    equipment_booking_method?: boolean | equipment_method$equipment_booking_methodArgs<ExtArgs>
    _count?: boolean | Equipment_methodCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["equipment_method"]>

  export type equipment_methodSelectScalar = {
    id?: boolean
    name_th?: boolean
    name_en?: boolean
    name_short?: boolean
    unit_th?: boolean
    unit_en?: boolean
    price?: boolean
    is_fixrate?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    equipment_id?: boolean
  }

  export type equipment_methodInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment?: boolean | equipmentArgs<ExtArgs>
    equipment_booking_method?: boolean | equipment_method$equipment_booking_methodArgs<ExtArgs>
    _count?: boolean | Equipment_methodCountOutputTypeArgs<ExtArgs>
  }


  type equipment_methodGetPayload<S extends boolean | null | undefined | equipment_methodArgs> = $Types.GetResult<equipment_methodPayload, S>

  type equipment_methodCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipment_methodFindManyArgs, 'select' | 'include'> & {
      select?: Equipment_methodCountAggregateInputType | true
    }

  export interface equipment_methodDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment_method'], meta: { name: 'equipment_method' } }
    /**
     * Find zero or one Equipment_method that matches the filter.
     * @param {equipment_methodFindUniqueArgs} args - Arguments to find a Equipment_method
     * @example
     * // Get one Equipment_method
     * const equipment_method = await prisma.equipment_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipment_methodFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_methodFindUniqueArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment_method that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipment_methodFindUniqueOrThrowArgs} args - Arguments to find a Equipment_method
     * @example
     * // Get one Equipment_method
     * const equipment_method = await prisma.equipment_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipment_methodFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_methodFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_methodFindFirstArgs} args - Arguments to find a Equipment_method
     * @example
     * // Get one Equipment_method
     * const equipment_method = await prisma.equipment_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipment_methodFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_methodFindFirstArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_methodFindFirstOrThrowArgs} args - Arguments to find a Equipment_method
     * @example
     * // Get one Equipment_method
     * const equipment_method = await prisma.equipment_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipment_methodFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_methodFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_methodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment_methods
     * const equipment_methods = await prisma.equipment_method.findMany()
     * 
     * // Get first 10 Equipment_methods
     * const equipment_methods = await prisma.equipment_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipment_methodWithIdOnly = await prisma.equipment_method.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipment_methodFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_methodFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment_method.
     * @param {equipment_methodCreateArgs} args - Arguments to create a Equipment_method.
     * @example
     * // Create one Equipment_method
     * const Equipment_method = await prisma.equipment_method.create({
     *   data: {
     *     // ... data to create a Equipment_method
     *   }
     * })
     * 
    **/
    create<T extends equipment_methodCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_methodCreateArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment_methods.
     *     @param {equipment_methodCreateManyArgs} args - Arguments to create many Equipment_methods.
     *     @example
     *     // Create many Equipment_methods
     *     const equipment_method = await prisma.equipment_method.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipment_methodCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_methodCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment_method.
     * @param {equipment_methodDeleteArgs} args - Arguments to delete one Equipment_method.
     * @example
     * // Delete one Equipment_method
     * const Equipment_method = await prisma.equipment_method.delete({
     *   where: {
     *     // ... filter to delete one Equipment_method
     *   }
     * })
     * 
    **/
    delete<T extends equipment_methodDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_methodDeleteArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment_method.
     * @param {equipment_methodUpdateArgs} args - Arguments to update one Equipment_method.
     * @example
     * // Update one Equipment_method
     * const equipment_method = await prisma.equipment_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipment_methodUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_methodUpdateArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment_methods.
     * @param {equipment_methodDeleteManyArgs} args - Arguments to filter Equipment_methods to delete.
     * @example
     * // Delete a few Equipment_methods
     * const { count } = await prisma.equipment_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipment_methodDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_methodDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment_methods
     * const equipment_method = await prisma.equipment_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipment_methodUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_methodUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment_method.
     * @param {equipment_methodUpsertArgs} args - Arguments to update or create a Equipment_method.
     * @example
     * // Update or create a Equipment_method
     * const equipment_method = await prisma.equipment_method.upsert({
     *   create: {
     *     // ... data to create a Equipment_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment_method we want to update
     *   }
     * })
    **/
    upsert<T extends equipment_methodUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_methodUpsertArgs<ExtArgs>>
    ): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_methodCountArgs} args - Arguments to filter Equipment_methods to count.
     * @example
     * // Count the number of Equipment_methods
     * const count = await prisma.equipment_method.count({
     *   where: {
     *     // ... the filter for the Equipment_methods we want to count
     *   }
     * })
    **/
    count<T extends equipment_methodCountArgs>(
      args?: Subset<T, equipment_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Equipment_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Equipment_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Equipment_methodAggregateArgs>(args: Subset<T, Equipment_methodAggregateArgs>): Prisma.PrismaPromise<GetEquipment_methodAggregateType<T>>

    /**
     * Group by Equipment_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipment_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipment_methodGroupByArgs['orderBy'] }
        : { orderBy?: equipment_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipment_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipment_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment_method model
   */
  readonly fields: equipment_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipment_methodClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment<T extends equipmentArgs<ExtArgs> = {}>(args?: Subset<T, equipmentArgs<ExtArgs>>): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment_booking_method<T extends equipment_method$equipment_booking_methodArgs<ExtArgs> = {}>(args?: Subset<T, equipment_method$equipment_booking_methodArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment_method model
   */ 
  interface equipment_methodFieldRefs {
    readonly id: FieldRef<"equipment_method", 'Int'>
    readonly name_th: FieldRef<"equipment_method", 'String'>
    readonly name_en: FieldRef<"equipment_method", 'String'>
    readonly name_short: FieldRef<"equipment_method", 'String'>
    readonly unit_th: FieldRef<"equipment_method", 'String'>
    readonly unit_en: FieldRef<"equipment_method", 'String'>
    readonly price: FieldRef<"equipment_method", 'Int'>
    readonly is_fixrate: FieldRef<"equipment_method", 'Int'>
    readonly is_active: FieldRef<"equipment_method", 'Int'>
    readonly is_publish: FieldRef<"equipment_method", 'Int'>
    readonly created_at: FieldRef<"equipment_method", 'DateTime'>
    readonly created_by: FieldRef<"equipment_method", 'String'>
    readonly updated_at: FieldRef<"equipment_method", 'DateTime'>
    readonly updated_by: FieldRef<"equipment_method", 'String'>
    readonly deleted_at: FieldRef<"equipment_method", 'DateTime'>
    readonly equipment_id: FieldRef<"equipment_method", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * equipment_method findUnique
   */
  export type equipment_methodFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_method to fetch.
     */
    where: equipment_methodWhereUniqueInput
  }


  /**
   * equipment_method findUniqueOrThrow
   */
  export type equipment_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_method to fetch.
     */
    where: equipment_methodWhereUniqueInput
  }


  /**
   * equipment_method findFirst
   */
  export type equipment_methodFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_method to fetch.
     */
    where?: equipment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_methods to fetch.
     */
    orderBy?: equipment_methodOrderByWithRelationInput | equipment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_methods.
     */
    cursor?: equipment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_methods.
     */
    distinct?: Equipment_methodScalarFieldEnum | Equipment_methodScalarFieldEnum[]
  }


  /**
   * equipment_method findFirstOrThrow
   */
  export type equipment_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_method to fetch.
     */
    where?: equipment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_methods to fetch.
     */
    orderBy?: equipment_methodOrderByWithRelationInput | equipment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_methods.
     */
    cursor?: equipment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_methods.
     */
    distinct?: Equipment_methodScalarFieldEnum | Equipment_methodScalarFieldEnum[]
  }


  /**
   * equipment_method findMany
   */
  export type equipment_methodFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_methods to fetch.
     */
    where?: equipment_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_methods to fetch.
     */
    orderBy?: equipment_methodOrderByWithRelationInput | equipment_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment_methods.
     */
    cursor?: equipment_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_methods.
     */
    skip?: number
    distinct?: Equipment_methodScalarFieldEnum | Equipment_methodScalarFieldEnum[]
  }


  /**
   * equipment_method create
   */
  export type equipment_methodCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment_method.
     */
    data: XOR<equipment_methodCreateInput, equipment_methodUncheckedCreateInput>
  }


  /**
   * equipment_method createMany
   */
  export type equipment_methodCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment_methods.
     */
    data: equipment_methodCreateManyInput | equipment_methodCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment_method update
   */
  export type equipment_methodUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment_method.
     */
    data: XOR<equipment_methodUpdateInput, equipment_methodUncheckedUpdateInput>
    /**
     * Choose, which equipment_method to update.
     */
    where: equipment_methodWhereUniqueInput
  }


  /**
   * equipment_method updateMany
   */
  export type equipment_methodUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment_methods.
     */
    data: XOR<equipment_methodUpdateManyMutationInput, equipment_methodUncheckedUpdateManyInput>
    /**
     * Filter which equipment_methods to update
     */
    where?: equipment_methodWhereInput
  }


  /**
   * equipment_method upsert
   */
  export type equipment_methodUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment_method to update in case it exists.
     */
    where: equipment_methodWhereUniqueInput
    /**
     * In case the equipment_method found by the `where` argument doesn't exist, create a new equipment_method with this data.
     */
    create: XOR<equipment_methodCreateInput, equipment_methodUncheckedCreateInput>
    /**
     * In case the equipment_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipment_methodUpdateInput, equipment_methodUncheckedUpdateInput>
  }


  /**
   * equipment_method delete
   */
  export type equipment_methodDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
    /**
     * Filter which equipment_method to delete.
     */
    where: equipment_methodWhereUniqueInput
  }


  /**
   * equipment_method deleteMany
   */
  export type equipment_methodDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_methods to delete
     */
    where?: equipment_methodWhereInput
  }


  /**
   * equipment_method.equipment_booking_method
   */
  export type equipment_method$equipment_booking_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    where?: equipment_booking_methodWhereInput
    orderBy?: equipment_booking_methodOrderByWithRelationInput | equipment_booking_methodOrderByWithRelationInput[]
    cursor?: equipment_booking_methodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Equipment_booking_methodScalarFieldEnum | Equipment_booking_methodScalarFieldEnum[]
  }


  /**
   * equipment_method without action
   */
  export type equipment_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_method
     */
    select?: equipment_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_methodInclude<ExtArgs> | null
  }



  /**
   * Model group
   */


  export type AggregateGroup = {
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  export type GroupAvgAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type GroupSumAggregateOutputType = {
    id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type GroupMinAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type GroupMaxAggregateOutputType = {
    id: number | null
    title_th: string | null
    title_en: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type GroupCountAggregateOutputType = {
    id: number
    title_th: number
    title_en: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type GroupAvgAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type GroupSumAggregateInputType = {
    id?: true
    is_active?: true
    is_publish?: true
  }

  export type GroupMinAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type GroupMaxAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type GroupCountAggregateInputType = {
    id?: true
    title_th?: true
    title_en?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type GroupAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which group to aggregate.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupMaxAggregateInputType
  }

  export type GetGroupAggregateType<T extends GroupAggregateArgs> = {
        [P in keyof T & keyof AggregateGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroup[P]>
      : GetScalarType<T[P], AggregateGroup[P]>
  }




  export type groupGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: groupWhereInput
    orderBy?: groupOrderByWithAggregationInput | groupOrderByWithAggregationInput[]
    by: GroupScalarFieldEnum[] | GroupScalarFieldEnum
    having?: groupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupCountAggregateInputType | true
    _avg?: GroupAvgAggregateInputType
    _sum?: GroupSumAggregateInputType
    _min?: GroupMinAggregateInputType
    _max?: GroupMaxAggregateInputType
  }


  export type GroupGroupByOutputType = {
    id: number
    title_th: string
    title_en: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: GroupCountAggregateOutputType | null
    _avg: GroupAvgAggregateOutputType | null
    _sum: GroupSumAggregateOutputType | null
    _min: GroupMinAggregateOutputType | null
    _max: GroupMaxAggregateOutputType | null
  }

  type GetGroupGroupByPayload<T extends groupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupGroupByOutputType[P]>
            : GetScalarType<T[P], GroupGroupByOutputType[P]>
        }
      >
    >


  export type groupSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    users?: boolean | group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["group"]>

  export type groupSelectScalar = {
    id?: boolean
    title_th?: boolean
    title_en?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type groupInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | group$usersArgs<ExtArgs>
    _count?: boolean | GroupCountOutputTypeArgs<ExtArgs>
  }


  type groupGetPayload<S extends boolean | null | undefined | groupArgs> = $Types.GetResult<groupPayload, S>

  type groupCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<groupFindManyArgs, 'select' | 'include'> & {
      select?: GroupCountAggregateInputType | true
    }

  export interface groupDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['group'], meta: { name: 'group' } }
    /**
     * Find zero or one Group that matches the filter.
     * @param {groupFindUniqueArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends groupFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, groupFindUniqueArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Group that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {groupFindUniqueOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends groupFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Group that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends groupFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, groupFindFirstArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Group that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindFirstOrThrowArgs} args - Arguments to find a Group
     * @example
     * // Get one Group
     * const group = await prisma.group.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends groupFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, groupFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.group.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.group.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupWithIdOnly = await prisma.group.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends groupFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<groupPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Group.
     * @param {groupCreateArgs} args - Arguments to create a Group.
     * @example
     * // Create one Group
     * const Group = await prisma.group.create({
     *   data: {
     *     // ... data to create a Group
     *   }
     * })
     * 
    **/
    create<T extends groupCreateArgs<ExtArgs>>(
      args: SelectSubset<T, groupCreateArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Groups.
     *     @param {groupCreateManyArgs} args - Arguments to create many Groups.
     *     @example
     *     // Create many Groups
     *     const group = await prisma.group.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends groupCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Group.
     * @param {groupDeleteArgs} args - Arguments to delete one Group.
     * @example
     * // Delete one Group
     * const Group = await prisma.group.delete({
     *   where: {
     *     // ... filter to delete one Group
     *   }
     * })
     * 
    **/
    delete<T extends groupDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, groupDeleteArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Group.
     * @param {groupUpdateArgs} args - Arguments to update one Group.
     * @example
     * // Update one Group
     * const group = await prisma.group.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends groupUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, groupUpdateArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {groupDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.group.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends groupDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, groupDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const group = await prisma.group.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends groupUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, groupUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Group.
     * @param {groupUpsertArgs} args - Arguments to update or create a Group.
     * @example
     * // Update or create a Group
     * const group = await prisma.group.upsert({
     *   create: {
     *     // ... data to create a Group
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Group we want to update
     *   }
     * })
    **/
    upsert<T extends groupUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, groupUpsertArgs<ExtArgs>>
    ): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.group.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupCountArgs>(
      args?: Subset<T, groupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupAggregateArgs>(args: Subset<T, GroupAggregateArgs>): Prisma.PrismaPromise<GetGroupAggregateType<T>>

    /**
     * Group by Group.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupGroupByArgs['orderBy'] }
        : { orderBy?: groupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the group model
   */
  readonly fields: groupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for group.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__groupClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    users<T extends group$usersArgs<ExtArgs> = {}>(args?: Subset<T, group$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the group model
   */ 
  interface groupFieldRefs {
    readonly id: FieldRef<"group", 'Int'>
    readonly title_th: FieldRef<"group", 'String'>
    readonly title_en: FieldRef<"group", 'String'>
    readonly is_active: FieldRef<"group", 'Int'>
    readonly is_publish: FieldRef<"group", 'Int'>
    readonly created_at: FieldRef<"group", 'DateTime'>
    readonly created_by: FieldRef<"group", 'String'>
    readonly updated_at: FieldRef<"group", 'DateTime'>
    readonly updated_by: FieldRef<"group", 'String'>
    readonly deleted_at: FieldRef<"group", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * group findUnique
   */
  export type groupFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }


  /**
   * group findUniqueOrThrow
   */
  export type groupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where: groupWhereUniqueInput
  }


  /**
   * group findFirst
   */
  export type groupFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * group findFirstOrThrow
   */
  export type groupFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which group to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * group findMany
   */
  export type groupFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupOrderByWithRelationInput | groupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupScalarFieldEnum | GroupScalarFieldEnum[]
  }


  /**
   * group create
   */
  export type groupCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to create a group.
     */
    data: XOR<groupCreateInput, groupUncheckedCreateInput>
  }


  /**
   * group createMany
   */
  export type groupCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupCreateManyInput | groupCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * group update
   */
  export type groupUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The data needed to update a group.
     */
    data: XOR<groupUpdateInput, groupUncheckedUpdateInput>
    /**
     * Choose, which group to update.
     */
    where: groupWhereUniqueInput
  }


  /**
   * group updateMany
   */
  export type groupUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupUpdateManyMutationInput, groupUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupWhereInput
  }


  /**
   * group upsert
   */
  export type groupUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * The filter to search for the group to update in case it exists.
     */
    where: groupWhereUniqueInput
    /**
     * In case the group found by the `where` argument doesn't exist, create a new group with this data.
     */
    create: XOR<groupCreateInput, groupUncheckedCreateInput>
    /**
     * In case the group was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupUpdateInput, groupUncheckedUpdateInput>
  }


  /**
   * group delete
   */
  export type groupDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
    /**
     * Filter which group to delete.
     */
    where: groupWhereUniqueInput
  }


  /**
   * group deleteMany
   */
  export type groupDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupWhereInput
  }


  /**
   * group.users
   */
  export type group$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    cursor?: userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * group without action
   */
  export type groupArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the group
     */
    select?: groupSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: groupInclude<ExtArgs> | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    group_id: number | null
    status: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    group_id: number | null
    status: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    group_id: number | null
    email: string | null
    secret_confirm_email: string | null
    password: string | null
    status: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    group_id: number | null
    email: string | null
    secret_confirm_email: string | null
    password: string | null
    status: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    group_id: number
    email: number
    secret_confirm_email: number
    password: number
    status: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    group_id?: true
    status?: true
    is_active?: true
    is_publish?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    group_id?: true
    status?: true
    is_active?: true
    is_publish?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    group_id?: true
    email?: true
    secret_confirm_email?: true
    password?: true
    status?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    group_id?: true
    email?: true
    secret_confirm_email?: true
    password?: true
    status?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    group_id?: true
    email?: true
    secret_confirm_email?: true
    password?: true
    status?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    group_id: number
    email: string
    secret_confirm_email: string | null
    password: string | null
    status: number
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    group_id?: boolean
    email?: boolean
    secret_confirm_email?: boolean
    password?: boolean
    status?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    group?: boolean | groupArgs<ExtArgs>
    profile?: boolean | user$profileArgs<ExtArgs>
    equipment_booking?: boolean | user$equipment_bookingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    group_id?: boolean
    email?: boolean
    secret_confirm_email?: boolean
    password?: boolean
    status?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type userInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    group?: boolean | groupArgs<ExtArgs>
    profile?: boolean | user$profileArgs<ExtArgs>
    equipment_booking?: boolean | user$equipment_bookingArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type userGetPayload<S extends boolean | null | undefined | userArgs> = $Types.GetResult<userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, userCreateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {userCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, userDeleteArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, userUpsertArgs<ExtArgs>>
    ): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    group<T extends groupArgs<ExtArgs> = {}>(args?: Subset<T, groupArgs<ExtArgs>>): Prisma__groupClient<$Types.GetResult<groupPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    profile<T extends user$profileArgs<ExtArgs> = {}>(args?: Subset<T, user$profileArgs<ExtArgs>>): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment_booking<T extends user$equipment_bookingArgs<ExtArgs> = {}>(args?: Subset<T, user$equipment_bookingArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the user model
   */ 
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'Int'>
    readonly group_id: FieldRef<"user", 'Int'>
    readonly email: FieldRef<"user", 'String'>
    readonly secret_confirm_email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly status: FieldRef<"user", 'Int'>
    readonly is_active: FieldRef<"user", 'Int'>
    readonly is_publish: FieldRef<"user", 'Int'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly created_by: FieldRef<"user", 'String'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly updated_by: FieldRef<"user", 'String'>
    readonly deleted_at: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.profile
   */
  export type user$profileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    where?: profileWhereInput
  }


  /**
   * user.equipment_booking
   */
  export type user$equipment_bookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    where?: equipment_bookingWhereInput
    orderBy?: equipment_bookingOrderByWithRelationInput | equipment_bookingOrderByWithRelationInput[]
    cursor?: equipment_bookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Equipment_bookingScalarFieldEnum | Equipment_bookingScalarFieldEnum[]
  }


  /**
   * user without action
   */
  export type userArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude<ExtArgs> | null
  }



  /**
   * Model profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    member_status: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    member_status: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    prefix: string | null
    firstname: string | null
    surname: string | null
    member_status: number | null
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_name: string | null
    invoice_address: string | null
    tax_id: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    prefix: string | null
    firstname: string | null
    surname: string | null
    member_status: number | null
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_name: string | null
    invoice_address: string | null
    tax_id: string | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    user_id: number
    prefix: number
    firstname: number
    surname: number
    member_status: number
    organization: number
    contact_address: number
    phone: number
    email: number
    invoice_name: number
    invoice_address: number
    tax_id: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    user_id?: true
    member_status?: true
    is_active?: true
    is_publish?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    user_id?: true
    member_status?: true
    is_active?: true
    is_publish?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    user_id?: true
    prefix?: true
    firstname?: true
    surname?: true
    member_status?: true
    organization?: true
    contact_address?: true
    phone?: true
    email?: true
    invoice_name?: true
    invoice_address?: true
    tax_id?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    user_id?: true
    prefix?: true
    firstname?: true
    surname?: true
    member_status?: true
    organization?: true
    contact_address?: true
    phone?: true
    email?: true
    invoice_name?: true
    invoice_address?: true
    tax_id?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    user_id?: true
    prefix?: true
    firstname?: true
    surname?: true
    member_status?: true
    organization?: true
    contact_address?: true
    phone?: true
    email?: true
    invoice_name?: true
    invoice_address?: true
    tax_id?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type profileGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: profileWhereInput
    orderBy?: profileOrderByWithAggregationInput | profileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: number
    user_id: number
    prefix: string | null
    firstname: string | null
    surname: string | null
    member_status: number
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_name: string | null
    invoice_address: string | null
    tax_id: string | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    prefix?: boolean
    firstname?: boolean
    surname?: boolean
    member_status?: boolean
    organization?: boolean
    contact_address?: boolean
    phone?: boolean
    email?: boolean
    invoice_name?: boolean
    invoice_address?: boolean
    tax_id?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    user?: boolean | userArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type profileSelectScalar = {
    id?: boolean
    user_id?: boolean
    prefix?: boolean
    firstname?: boolean
    surname?: boolean
    member_status?: boolean
    organization?: boolean
    contact_address?: boolean
    phone?: boolean
    email?: boolean
    invoice_name?: boolean
    invoice_address?: boolean
    tax_id?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type profileInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
  }


  type profileGetPayload<S extends boolean | null | undefined | profileArgs> = $Types.GetResult<profilePayload, S>

  type profileCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<profileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['profile'], meta: { name: 'profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends profileFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, profileFindUniqueArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends profileFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindFirstArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends profileFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<profilePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends profileCreateArgs<ExtArgs>>(
      args: SelectSubset<T, profileCreateArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Profiles.
     *     @param {profileCreateManyArgs} args - Arguments to create many Profiles.
     *     @example
     *     // Create many Profiles
     *     const profile = await prisma.profile.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends profileCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends profileDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, profileDeleteArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends profileUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpdateArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends profileDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, profileDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends profileUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends profileUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, profileUpsertArgs<ExtArgs>>
    ): Prisma__profileClient<$Types.GetResult<profilePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: profileGroupByArgs['orderBy'] }
        : { orderBy?: profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the profile model
   */
  readonly fields: profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__profileClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the profile model
   */ 
  interface profileFieldRefs {
    readonly id: FieldRef<"profile", 'Int'>
    readonly user_id: FieldRef<"profile", 'Int'>
    readonly prefix: FieldRef<"profile", 'String'>
    readonly firstname: FieldRef<"profile", 'String'>
    readonly surname: FieldRef<"profile", 'String'>
    readonly member_status: FieldRef<"profile", 'Int'>
    readonly organization: FieldRef<"profile", 'String'>
    readonly contact_address: FieldRef<"profile", 'String'>
    readonly phone: FieldRef<"profile", 'String'>
    readonly email: FieldRef<"profile", 'String'>
    readonly invoice_name: FieldRef<"profile", 'String'>
    readonly invoice_address: FieldRef<"profile", 'String'>
    readonly tax_id: FieldRef<"profile", 'String'>
    readonly is_active: FieldRef<"profile", 'Int'>
    readonly is_publish: FieldRef<"profile", 'Int'>
    readonly created_at: FieldRef<"profile", 'DateTime'>
    readonly created_by: FieldRef<"profile", 'String'>
    readonly updated_at: FieldRef<"profile", 'DateTime'>
    readonly updated_by: FieldRef<"profile", 'String'>
    readonly deleted_at: FieldRef<"profile", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * profile findUnique
   */
  export type profileFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile findFirst
   */
  export type profileFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * profile findMany
   */
  export type profileFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: profileOrderByWithRelationInput | profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }


  /**
   * profile create
   */
  export type profileCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }


  /**
   * profile createMany
   */
  export type profileCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many profiles.
     */
    data: profileCreateManyInput | profileCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * profile update
   */
  export type profileUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
  }


  /**
   * profile upsert
   */
  export type profileUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }


  /**
   * profile delete
   */
  export type profileDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
  }


  /**
   * profile without action
   */
  export type profileArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude<ExtArgs> | null
  }



  /**
   * Model equipment_booking
   */


  export type AggregateEquipment_booking = {
    _count: Equipment_bookingCountAggregateOutputType | null
    _avg: Equipment_bookingAvgAggregateOutputType | null
    _sum: Equipment_bookingSumAggregateOutputType | null
    _min: Equipment_bookingMinAggregateOutputType | null
    _max: Equipment_bookingMaxAggregateOutputType | null
  }

  export type Equipment_bookingAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    equipment_id: number | null
    period_time: number | null
    member_status: number | null
    price: number | null
    status_id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_bookingSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    equipment_id: number | null
    period_time: number | null
    member_status: number | null
    price: number | null
    status_id: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_bookingMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    equipment_id: number | null
    booking_date: Date | null
    period_time: number | null
    member_status: number | null
    example: string | null
    prefix: string | null
    firstname: string | null
    surname: string | null
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_address: string | null
    tax_id: string | null
    price: number | null
    reject_comment: string | null
    confirmed_date: Date | null
    status_id: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_bookingMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    equipment_id: number | null
    booking_date: Date | null
    period_time: number | null
    member_status: number | null
    example: string | null
    prefix: string | null
    firstname: string | null
    surname: string | null
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_address: string | null
    tax_id: string | null
    price: number | null
    reject_comment: string | null
    confirmed_date: Date | null
    status_id: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_bookingCountAggregateOutputType = {
    id: number
    user_id: number
    equipment_id: number
    booking_date: number
    period_time: number
    member_status: number
    example: number
    prefix: number
    firstname: number
    surname: number
    organization: number
    contact_address: number
    phone: number
    email: number
    invoice_address: number
    tax_id: number
    price: number
    reject_comment: number
    confirmed_date: number
    status_id: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type Equipment_bookingAvgAggregateInputType = {
    id?: true
    user_id?: true
    equipment_id?: true
    period_time?: true
    member_status?: true
    price?: true
    status_id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_bookingSumAggregateInputType = {
    id?: true
    user_id?: true
    equipment_id?: true
    period_time?: true
    member_status?: true
    price?: true
    status_id?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_bookingMinAggregateInputType = {
    id?: true
    user_id?: true
    equipment_id?: true
    booking_date?: true
    period_time?: true
    member_status?: true
    example?: true
    prefix?: true
    firstname?: true
    surname?: true
    organization?: true
    contact_address?: true
    phone?: true
    email?: true
    invoice_address?: true
    tax_id?: true
    price?: true
    reject_comment?: true
    confirmed_date?: true
    status_id?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_bookingMaxAggregateInputType = {
    id?: true
    user_id?: true
    equipment_id?: true
    booking_date?: true
    period_time?: true
    member_status?: true
    example?: true
    prefix?: true
    firstname?: true
    surname?: true
    organization?: true
    contact_address?: true
    phone?: true
    email?: true
    invoice_address?: true
    tax_id?: true
    price?: true
    reject_comment?: true
    confirmed_date?: true
    status_id?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_bookingCountAggregateInputType = {
    id?: true
    user_id?: true
    equipment_id?: true
    booking_date?: true
    period_time?: true
    member_status?: true
    example?: true
    prefix?: true
    firstname?: true
    surname?: true
    organization?: true
    contact_address?: true
    phone?: true
    email?: true
    invoice_address?: true
    tax_id?: true
    price?: true
    reject_comment?: true
    confirmed_date?: true
    status_id?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Equipment_bookingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_booking to aggregate.
     */
    where?: equipment_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_bookings to fetch.
     */
    orderBy?: equipment_bookingOrderByWithRelationInput | equipment_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipment_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment_bookings
    **/
    _count?: true | Equipment_bookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Equipment_bookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Equipment_bookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Equipment_bookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Equipment_bookingMaxAggregateInputType
  }

  export type GetEquipment_bookingAggregateType<T extends Equipment_bookingAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment_booking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment_booking[P]>
      : GetScalarType<T[P], AggregateEquipment_booking[P]>
  }




  export type equipment_bookingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_bookingWhereInput
    orderBy?: equipment_bookingOrderByWithAggregationInput | equipment_bookingOrderByWithAggregationInput[]
    by: Equipment_bookingScalarFieldEnum[] | Equipment_bookingScalarFieldEnum
    having?: equipment_bookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Equipment_bookingCountAggregateInputType | true
    _avg?: Equipment_bookingAvgAggregateInputType
    _sum?: Equipment_bookingSumAggregateInputType
    _min?: Equipment_bookingMinAggregateInputType
    _max?: Equipment_bookingMaxAggregateInputType
  }


  export type Equipment_bookingGroupByOutputType = {
    id: number
    user_id: number
    equipment_id: number
    booking_date: Date
    period_time: number
    member_status: number
    example: string | null
    prefix: string | null
    firstname: string | null
    surname: string | null
    organization: string | null
    contact_address: string | null
    phone: string | null
    email: string | null
    invoice_address: string | null
    tax_id: string | null
    price: number | null
    reject_comment: string | null
    confirmed_date: Date | null
    status_id: number
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: Equipment_bookingCountAggregateOutputType | null
    _avg: Equipment_bookingAvgAggregateOutputType | null
    _sum: Equipment_bookingSumAggregateOutputType | null
    _min: Equipment_bookingMinAggregateOutputType | null
    _max: Equipment_bookingMaxAggregateOutputType | null
  }

  type GetEquipment_bookingGroupByPayload<T extends equipment_bookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Equipment_bookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Equipment_bookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Equipment_bookingGroupByOutputType[P]>
            : GetScalarType<T[P], Equipment_bookingGroupByOutputType[P]>
        }
      >
    >


  export type equipment_bookingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    equipment_id?: boolean
    booking_date?: boolean
    period_time?: boolean
    member_status?: boolean
    example?: boolean
    prefix?: boolean
    firstname?: boolean
    surname?: boolean
    organization?: boolean
    contact_address?: boolean
    phone?: boolean
    email?: boolean
    invoice_address?: boolean
    tax_id?: boolean
    price?: boolean
    reject_comment?: boolean
    confirmed_date?: boolean
    status_id?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    user?: boolean | userArgs<ExtArgs>
    equipment?: boolean | equipmentArgs<ExtArgs>
    equipment_booking_method?: boolean | equipment_booking$equipment_booking_methodArgs<ExtArgs>
    _count?: boolean | Equipment_bookingCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["equipment_booking"]>

  export type equipment_bookingSelectScalar = {
    id?: boolean
    user_id?: boolean
    equipment_id?: boolean
    booking_date?: boolean
    period_time?: boolean
    member_status?: boolean
    example?: boolean
    prefix?: boolean
    firstname?: boolean
    surname?: boolean
    organization?: boolean
    contact_address?: boolean
    phone?: boolean
    email?: boolean
    invoice_address?: boolean
    tax_id?: boolean
    price?: boolean
    reject_comment?: boolean
    confirmed_date?: boolean
    status_id?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type equipment_bookingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | userArgs<ExtArgs>
    equipment?: boolean | equipmentArgs<ExtArgs>
    equipment_booking_method?: boolean | equipment_booking$equipment_booking_methodArgs<ExtArgs>
    _count?: boolean | Equipment_bookingCountOutputTypeArgs<ExtArgs>
  }


  type equipment_bookingGetPayload<S extends boolean | null | undefined | equipment_bookingArgs> = $Types.GetResult<equipment_bookingPayload, S>

  type equipment_bookingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipment_bookingFindManyArgs, 'select' | 'include'> & {
      select?: Equipment_bookingCountAggregateInputType | true
    }

  export interface equipment_bookingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment_booking'], meta: { name: 'equipment_booking' } }
    /**
     * Find zero or one Equipment_booking that matches the filter.
     * @param {equipment_bookingFindUniqueArgs} args - Arguments to find a Equipment_booking
     * @example
     * // Get one Equipment_booking
     * const equipment_booking = await prisma.equipment_booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipment_bookingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_bookingFindUniqueArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment_booking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipment_bookingFindUniqueOrThrowArgs} args - Arguments to find a Equipment_booking
     * @example
     * // Get one Equipment_booking
     * const equipment_booking = await prisma.equipment_booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipment_bookingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_bookingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment_booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_bookingFindFirstArgs} args - Arguments to find a Equipment_booking
     * @example
     * // Get one Equipment_booking
     * const equipment_booking = await prisma.equipment_booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipment_bookingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_bookingFindFirstArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment_booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_bookingFindFirstOrThrowArgs} args - Arguments to find a Equipment_booking
     * @example
     * // Get one Equipment_booking
     * const equipment_booking = await prisma.equipment_booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipment_bookingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_bookingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment_bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_bookingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment_bookings
     * const equipment_bookings = await prisma.equipment_booking.findMany()
     * 
     * // Get first 10 Equipment_bookings
     * const equipment_bookings = await prisma.equipment_booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipment_bookingWithIdOnly = await prisma.equipment_booking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipment_bookingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_bookingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment_booking.
     * @param {equipment_bookingCreateArgs} args - Arguments to create a Equipment_booking.
     * @example
     * // Create one Equipment_booking
     * const Equipment_booking = await prisma.equipment_booking.create({
     *   data: {
     *     // ... data to create a Equipment_booking
     *   }
     * })
     * 
    **/
    create<T extends equipment_bookingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_bookingCreateArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment_bookings.
     *     @param {equipment_bookingCreateManyArgs} args - Arguments to create many Equipment_bookings.
     *     @example
     *     // Create many Equipment_bookings
     *     const equipment_booking = await prisma.equipment_booking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipment_bookingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_bookingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment_booking.
     * @param {equipment_bookingDeleteArgs} args - Arguments to delete one Equipment_booking.
     * @example
     * // Delete one Equipment_booking
     * const Equipment_booking = await prisma.equipment_booking.delete({
     *   where: {
     *     // ... filter to delete one Equipment_booking
     *   }
     * })
     * 
    **/
    delete<T extends equipment_bookingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_bookingDeleteArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment_booking.
     * @param {equipment_bookingUpdateArgs} args - Arguments to update one Equipment_booking.
     * @example
     * // Update one Equipment_booking
     * const equipment_booking = await prisma.equipment_booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipment_bookingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_bookingUpdateArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment_bookings.
     * @param {equipment_bookingDeleteManyArgs} args - Arguments to filter Equipment_bookings to delete.
     * @example
     * // Delete a few Equipment_bookings
     * const { count } = await prisma.equipment_booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipment_bookingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_bookingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_bookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment_bookings
     * const equipment_booking = await prisma.equipment_booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipment_bookingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_bookingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment_booking.
     * @param {equipment_bookingUpsertArgs} args - Arguments to update or create a Equipment_booking.
     * @example
     * // Update or create a Equipment_booking
     * const equipment_booking = await prisma.equipment_booking.upsert({
     *   create: {
     *     // ... data to create a Equipment_booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment_booking we want to update
     *   }
     * })
    **/
    upsert<T extends equipment_bookingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_bookingUpsertArgs<ExtArgs>>
    ): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_bookingCountArgs} args - Arguments to filter Equipment_bookings to count.
     * @example
     * // Count the number of Equipment_bookings
     * const count = await prisma.equipment_booking.count({
     *   where: {
     *     // ... the filter for the Equipment_bookings we want to count
     *   }
     * })
    **/
    count<T extends equipment_bookingCountArgs>(
      args?: Subset<T, equipment_bookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Equipment_bookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment_booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Equipment_bookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Equipment_bookingAggregateArgs>(args: Subset<T, Equipment_bookingAggregateArgs>): Prisma.PrismaPromise<GetEquipment_bookingAggregateType<T>>

    /**
     * Group by Equipment_booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_bookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipment_bookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipment_bookingGroupByArgs['orderBy'] }
        : { orderBy?: equipment_bookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipment_bookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipment_bookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment_booking model
   */
  readonly fields: equipment_bookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment_booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipment_bookingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs<ExtArgs> = {}>(args?: Subset<T, userArgs<ExtArgs>>): Prisma__userClient<$Types.GetResult<userPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment<T extends equipmentArgs<ExtArgs> = {}>(args?: Subset<T, equipmentArgs<ExtArgs>>): Prisma__equipmentClient<$Types.GetResult<equipmentPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment_booking_method<T extends equipment_booking$equipment_booking_methodArgs<ExtArgs> = {}>(args?: Subset<T, equipment_booking$equipment_booking_methodArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment_booking model
   */ 
  interface equipment_bookingFieldRefs {
    readonly id: FieldRef<"equipment_booking", 'Int'>
    readonly user_id: FieldRef<"equipment_booking", 'Int'>
    readonly equipment_id: FieldRef<"equipment_booking", 'Int'>
    readonly booking_date: FieldRef<"equipment_booking", 'DateTime'>
    readonly period_time: FieldRef<"equipment_booking", 'Int'>
    readonly member_status: FieldRef<"equipment_booking", 'Int'>
    readonly example: FieldRef<"equipment_booking", 'String'>
    readonly prefix: FieldRef<"equipment_booking", 'String'>
    readonly firstname: FieldRef<"equipment_booking", 'String'>
    readonly surname: FieldRef<"equipment_booking", 'String'>
    readonly organization: FieldRef<"equipment_booking", 'String'>
    readonly contact_address: FieldRef<"equipment_booking", 'String'>
    readonly phone: FieldRef<"equipment_booking", 'String'>
    readonly email: FieldRef<"equipment_booking", 'String'>
    readonly invoice_address: FieldRef<"equipment_booking", 'String'>
    readonly tax_id: FieldRef<"equipment_booking", 'String'>
    readonly price: FieldRef<"equipment_booking", 'Int'>
    readonly reject_comment: FieldRef<"equipment_booking", 'String'>
    readonly confirmed_date: FieldRef<"equipment_booking", 'DateTime'>
    readonly status_id: FieldRef<"equipment_booking", 'Int'>
    readonly is_active: FieldRef<"equipment_booking", 'Int'>
    readonly is_publish: FieldRef<"equipment_booking", 'Int'>
    readonly created_at: FieldRef<"equipment_booking", 'DateTime'>
    readonly created_by: FieldRef<"equipment_booking", 'String'>
    readonly updated_at: FieldRef<"equipment_booking", 'DateTime'>
    readonly updated_by: FieldRef<"equipment_booking", 'String'>
    readonly deleted_at: FieldRef<"equipment_booking", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment_booking findUnique
   */
  export type equipment_bookingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking to fetch.
     */
    where: equipment_bookingWhereUniqueInput
  }


  /**
   * equipment_booking findUniqueOrThrow
   */
  export type equipment_bookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking to fetch.
     */
    where: equipment_bookingWhereUniqueInput
  }


  /**
   * equipment_booking findFirst
   */
  export type equipment_bookingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking to fetch.
     */
    where?: equipment_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_bookings to fetch.
     */
    orderBy?: equipment_bookingOrderByWithRelationInput | equipment_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_bookings.
     */
    cursor?: equipment_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_bookings.
     */
    distinct?: Equipment_bookingScalarFieldEnum | Equipment_bookingScalarFieldEnum[]
  }


  /**
   * equipment_booking findFirstOrThrow
   */
  export type equipment_bookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking to fetch.
     */
    where?: equipment_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_bookings to fetch.
     */
    orderBy?: equipment_bookingOrderByWithRelationInput | equipment_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_bookings.
     */
    cursor?: equipment_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_bookings.
     */
    distinct?: Equipment_bookingScalarFieldEnum | Equipment_bookingScalarFieldEnum[]
  }


  /**
   * equipment_booking findMany
   */
  export type equipment_bookingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * Filter, which equipment_bookings to fetch.
     */
    where?: equipment_bookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_bookings to fetch.
     */
    orderBy?: equipment_bookingOrderByWithRelationInput | equipment_bookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment_bookings.
     */
    cursor?: equipment_bookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_bookings.
     */
    skip?: number
    distinct?: Equipment_bookingScalarFieldEnum | Equipment_bookingScalarFieldEnum[]
  }


  /**
   * equipment_booking create
   */
  export type equipment_bookingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment_booking.
     */
    data: XOR<equipment_bookingCreateInput, equipment_bookingUncheckedCreateInput>
  }


  /**
   * equipment_booking createMany
   */
  export type equipment_bookingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment_bookings.
     */
    data: equipment_bookingCreateManyInput | equipment_bookingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment_booking update
   */
  export type equipment_bookingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment_booking.
     */
    data: XOR<equipment_bookingUpdateInput, equipment_bookingUncheckedUpdateInput>
    /**
     * Choose, which equipment_booking to update.
     */
    where: equipment_bookingWhereUniqueInput
  }


  /**
   * equipment_booking updateMany
   */
  export type equipment_bookingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment_bookings.
     */
    data: XOR<equipment_bookingUpdateManyMutationInput, equipment_bookingUncheckedUpdateManyInput>
    /**
     * Filter which equipment_bookings to update
     */
    where?: equipment_bookingWhereInput
  }


  /**
   * equipment_booking upsert
   */
  export type equipment_bookingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment_booking to update in case it exists.
     */
    where: equipment_bookingWhereUniqueInput
    /**
     * In case the equipment_booking found by the `where` argument doesn't exist, create a new equipment_booking with this data.
     */
    create: XOR<equipment_bookingCreateInput, equipment_bookingUncheckedCreateInput>
    /**
     * In case the equipment_booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipment_bookingUpdateInput, equipment_bookingUncheckedUpdateInput>
  }


  /**
   * equipment_booking delete
   */
  export type equipment_bookingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
    /**
     * Filter which equipment_booking to delete.
     */
    where: equipment_bookingWhereUniqueInput
  }


  /**
   * equipment_booking deleteMany
   */
  export type equipment_bookingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_bookings to delete
     */
    where?: equipment_bookingWhereInput
  }


  /**
   * equipment_booking.equipment_booking_method
   */
  export type equipment_booking$equipment_booking_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    where?: equipment_booking_methodWhereInput
    orderBy?: equipment_booking_methodOrderByWithRelationInput | equipment_booking_methodOrderByWithRelationInput[]
    cursor?: equipment_booking_methodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Equipment_booking_methodScalarFieldEnum | Equipment_booking_methodScalarFieldEnum[]
  }


  /**
   * equipment_booking without action
   */
  export type equipment_bookingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking
     */
    select?: equipment_bookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_bookingInclude<ExtArgs> | null
  }



  /**
   * Model equipment_booking_method
   */


  export type AggregateEquipment_booking_method = {
    _count: Equipment_booking_methodCountAggregateOutputType | null
    _avg: Equipment_booking_methodAvgAggregateOutputType | null
    _sum: Equipment_booking_methodSumAggregateOutputType | null
    _min: Equipment_booking_methodMinAggregateOutputType | null
    _max: Equipment_booking_methodMaxAggregateOutputType | null
  }

  export type Equipment_booking_methodAvgAggregateOutputType = {
    id: number | null
    equipment_booking_id: number | null
    equipment_method_id: number | null
    quantity: number | null
    price: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_booking_methodSumAggregateOutputType = {
    id: number | null
    equipment_booking_id: number | null
    equipment_method_id: number | null
    quantity: number | null
    price: number | null
    is_active: number | null
    is_publish: number | null
  }

  export type Equipment_booking_methodMinAggregateOutputType = {
    id: number | null
    equipment_booking_id: number | null
    equipment_method_id: number | null
    quantity: number | null
    price: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_booking_methodMaxAggregateOutputType = {
    id: number | null
    equipment_booking_id: number | null
    equipment_method_id: number | null
    quantity: number | null
    price: number | null
    is_active: number | null
    is_publish: number | null
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
  }

  export type Equipment_booking_methodCountAggregateOutputType = {
    id: number
    equipment_booking_id: number
    equipment_method_id: number
    quantity: number
    price: number
    is_active: number
    is_publish: number
    created_at: number
    created_by: number
    updated_at: number
    updated_by: number
    deleted_at: number
    _all: number
  }


  export type Equipment_booking_methodAvgAggregateInputType = {
    id?: true
    equipment_booking_id?: true
    equipment_method_id?: true
    quantity?: true
    price?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_booking_methodSumAggregateInputType = {
    id?: true
    equipment_booking_id?: true
    equipment_method_id?: true
    quantity?: true
    price?: true
    is_active?: true
    is_publish?: true
  }

  export type Equipment_booking_methodMinAggregateInputType = {
    id?: true
    equipment_booking_id?: true
    equipment_method_id?: true
    quantity?: true
    price?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_booking_methodMaxAggregateInputType = {
    id?: true
    equipment_booking_id?: true
    equipment_method_id?: true
    quantity?: true
    price?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
  }

  export type Equipment_booking_methodCountAggregateInputType = {
    id?: true
    equipment_booking_id?: true
    equipment_method_id?: true
    quantity?: true
    price?: true
    is_active?: true
    is_publish?: true
    created_at?: true
    created_by?: true
    updated_at?: true
    updated_by?: true
    deleted_at?: true
    _all?: true
  }

  export type Equipment_booking_methodAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_booking_method to aggregate.
     */
    where?: equipment_booking_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_booking_methods to fetch.
     */
    orderBy?: equipment_booking_methodOrderByWithRelationInput | equipment_booking_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipment_booking_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_booking_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_booking_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipment_booking_methods
    **/
    _count?: true | Equipment_booking_methodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Equipment_booking_methodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Equipment_booking_methodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Equipment_booking_methodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Equipment_booking_methodMaxAggregateInputType
  }

  export type GetEquipment_booking_methodAggregateType<T extends Equipment_booking_methodAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment_booking_method]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment_booking_method[P]>
      : GetScalarType<T[P], AggregateEquipment_booking_method[P]>
  }




  export type equipment_booking_methodGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: equipment_booking_methodWhereInput
    orderBy?: equipment_booking_methodOrderByWithAggregationInput | equipment_booking_methodOrderByWithAggregationInput[]
    by: Equipment_booking_methodScalarFieldEnum[] | Equipment_booking_methodScalarFieldEnum
    having?: equipment_booking_methodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Equipment_booking_methodCountAggregateInputType | true
    _avg?: Equipment_booking_methodAvgAggregateInputType
    _sum?: Equipment_booking_methodSumAggregateInputType
    _min?: Equipment_booking_methodMinAggregateInputType
    _max?: Equipment_booking_methodMaxAggregateInputType
  }


  export type Equipment_booking_methodGroupByOutputType = {
    id: number
    equipment_booking_id: number
    equipment_method_id: number
    quantity: number | null
    price: number | null
    is_active: number
    is_publish: number
    created_at: Date | null
    created_by: string | null
    updated_at: Date | null
    updated_by: string | null
    deleted_at: Date | null
    _count: Equipment_booking_methodCountAggregateOutputType | null
    _avg: Equipment_booking_methodAvgAggregateOutputType | null
    _sum: Equipment_booking_methodSumAggregateOutputType | null
    _min: Equipment_booking_methodMinAggregateOutputType | null
    _max: Equipment_booking_methodMaxAggregateOutputType | null
  }

  type GetEquipment_booking_methodGroupByPayload<T extends equipment_booking_methodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Equipment_booking_methodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Equipment_booking_methodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Equipment_booking_methodGroupByOutputType[P]>
            : GetScalarType<T[P], Equipment_booking_methodGroupByOutputType[P]>
        }
      >
    >


  export type equipment_booking_methodSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipment_booking_id?: boolean
    equipment_method_id?: boolean
    quantity?: boolean
    price?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
    equipment_booking?: boolean | equipment_bookingArgs<ExtArgs>
    equipment_method?: boolean | equipment_methodArgs<ExtArgs>
  }, ExtArgs["result"]["equipment_booking_method"]>

  export type equipment_booking_methodSelectScalar = {
    id?: boolean
    equipment_booking_id?: boolean
    equipment_method_id?: boolean
    quantity?: boolean
    price?: boolean
    is_active?: boolean
    is_publish?: boolean
    created_at?: boolean
    created_by?: boolean
    updated_at?: boolean
    updated_by?: boolean
    deleted_at?: boolean
  }

  export type equipment_booking_methodInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    equipment_booking?: boolean | equipment_bookingArgs<ExtArgs>
    equipment_method?: boolean | equipment_methodArgs<ExtArgs>
  }


  type equipment_booking_methodGetPayload<S extends boolean | null | undefined | equipment_booking_methodArgs> = $Types.GetResult<equipment_booking_methodPayload, S>

  type equipment_booking_methodCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<equipment_booking_methodFindManyArgs, 'select' | 'include'> & {
      select?: Equipment_booking_methodCountAggregateInputType | true
    }

  export interface equipment_booking_methodDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipment_booking_method'], meta: { name: 'equipment_booking_method' } }
    /**
     * Find zero or one Equipment_booking_method that matches the filter.
     * @param {equipment_booking_methodFindUniqueArgs} args - Arguments to find a Equipment_booking_method
     * @example
     * // Get one Equipment_booking_method
     * const equipment_booking_method = await prisma.equipment_booking_method.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends equipment_booking_methodFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_booking_methodFindUniqueArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Equipment_booking_method that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {equipment_booking_methodFindUniqueOrThrowArgs} args - Arguments to find a Equipment_booking_method
     * @example
     * // Get one Equipment_booking_method
     * const equipment_booking_method = await prisma.equipment_booking_method.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends equipment_booking_methodFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_booking_methodFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Equipment_booking_method that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_booking_methodFindFirstArgs} args - Arguments to find a Equipment_booking_method
     * @example
     * // Get one Equipment_booking_method
     * const equipment_booking_method = await prisma.equipment_booking_method.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends equipment_booking_methodFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_booking_methodFindFirstArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Equipment_booking_method that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_booking_methodFindFirstOrThrowArgs} args - Arguments to find a Equipment_booking_method
     * @example
     * // Get one Equipment_booking_method
     * const equipment_booking_method = await prisma.equipment_booking_method.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends equipment_booking_methodFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_booking_methodFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Equipment_booking_methods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_booking_methodFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment_booking_methods
     * const equipment_booking_methods = await prisma.equipment_booking_method.findMany()
     * 
     * // Get first 10 Equipment_booking_methods
     * const equipment_booking_methods = await prisma.equipment_booking_method.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipment_booking_methodWithIdOnly = await prisma.equipment_booking_method.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends equipment_booking_methodFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_booking_methodFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Equipment_booking_method.
     * @param {equipment_booking_methodCreateArgs} args - Arguments to create a Equipment_booking_method.
     * @example
     * // Create one Equipment_booking_method
     * const Equipment_booking_method = await prisma.equipment_booking_method.create({
     *   data: {
     *     // ... data to create a Equipment_booking_method
     *   }
     * })
     * 
    **/
    create<T extends equipment_booking_methodCreateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_booking_methodCreateArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Equipment_booking_methods.
     *     @param {equipment_booking_methodCreateManyArgs} args - Arguments to create many Equipment_booking_methods.
     *     @example
     *     // Create many Equipment_booking_methods
     *     const equipment_booking_method = await prisma.equipment_booking_method.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends equipment_booking_methodCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_booking_methodCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Equipment_booking_method.
     * @param {equipment_booking_methodDeleteArgs} args - Arguments to delete one Equipment_booking_method.
     * @example
     * // Delete one Equipment_booking_method
     * const Equipment_booking_method = await prisma.equipment_booking_method.delete({
     *   where: {
     *     // ... filter to delete one Equipment_booking_method
     *   }
     * })
     * 
    **/
    delete<T extends equipment_booking_methodDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_booking_methodDeleteArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Equipment_booking_method.
     * @param {equipment_booking_methodUpdateArgs} args - Arguments to update one Equipment_booking_method.
     * @example
     * // Update one Equipment_booking_method
     * const equipment_booking_method = await prisma.equipment_booking_method.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends equipment_booking_methodUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_booking_methodUpdateArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Equipment_booking_methods.
     * @param {equipment_booking_methodDeleteManyArgs} args - Arguments to filter Equipment_booking_methods to delete.
     * @example
     * // Delete a few Equipment_booking_methods
     * const { count } = await prisma.equipment_booking_method.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends equipment_booking_methodDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, equipment_booking_methodDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment_booking_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_booking_methodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment_booking_methods
     * const equipment_booking_method = await prisma.equipment_booking_method.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends equipment_booking_methodUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_booking_methodUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Equipment_booking_method.
     * @param {equipment_booking_methodUpsertArgs} args - Arguments to update or create a Equipment_booking_method.
     * @example
     * // Update or create a Equipment_booking_method
     * const equipment_booking_method = await prisma.equipment_booking_method.upsert({
     *   create: {
     *     // ... data to create a Equipment_booking_method
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment_booking_method we want to update
     *   }
     * })
    **/
    upsert<T extends equipment_booking_methodUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, equipment_booking_methodUpsertArgs<ExtArgs>>
    ): Prisma__equipment_booking_methodClient<$Types.GetResult<equipment_booking_methodPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Equipment_booking_methods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_booking_methodCountArgs} args - Arguments to filter Equipment_booking_methods to count.
     * @example
     * // Count the number of Equipment_booking_methods
     * const count = await prisma.equipment_booking_method.count({
     *   where: {
     *     // ... the filter for the Equipment_booking_methods we want to count
     *   }
     * })
    **/
    count<T extends equipment_booking_methodCountArgs>(
      args?: Subset<T, equipment_booking_methodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Equipment_booking_methodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment_booking_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Equipment_booking_methodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Equipment_booking_methodAggregateArgs>(args: Subset<T, Equipment_booking_methodAggregateArgs>): Prisma.PrismaPromise<GetEquipment_booking_methodAggregateType<T>>

    /**
     * Group by Equipment_booking_method.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipment_booking_methodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipment_booking_methodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipment_booking_methodGroupByArgs['orderBy'] }
        : { orderBy?: equipment_booking_methodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipment_booking_methodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipment_booking_methodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipment_booking_method model
   */
  readonly fields: equipment_booking_methodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipment_booking_method.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__equipment_booking_methodClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    equipment_booking<T extends equipment_bookingArgs<ExtArgs> = {}>(args?: Subset<T, equipment_bookingArgs<ExtArgs>>): Prisma__equipment_bookingClient<$Types.GetResult<equipment_bookingPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    equipment_method<T extends equipment_methodArgs<ExtArgs> = {}>(args?: Subset<T, equipment_methodArgs<ExtArgs>>): Prisma__equipment_methodClient<$Types.GetResult<equipment_methodPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the equipment_booking_method model
   */ 
  interface equipment_booking_methodFieldRefs {
    readonly id: FieldRef<"equipment_booking_method", 'Int'>
    readonly equipment_booking_id: FieldRef<"equipment_booking_method", 'Int'>
    readonly equipment_method_id: FieldRef<"equipment_booking_method", 'Int'>
    readonly quantity: FieldRef<"equipment_booking_method", 'Int'>
    readonly price: FieldRef<"equipment_booking_method", 'Int'>
    readonly is_active: FieldRef<"equipment_booking_method", 'Int'>
    readonly is_publish: FieldRef<"equipment_booking_method", 'Int'>
    readonly created_at: FieldRef<"equipment_booking_method", 'DateTime'>
    readonly created_by: FieldRef<"equipment_booking_method", 'String'>
    readonly updated_at: FieldRef<"equipment_booking_method", 'DateTime'>
    readonly updated_by: FieldRef<"equipment_booking_method", 'String'>
    readonly deleted_at: FieldRef<"equipment_booking_method", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * equipment_booking_method findUnique
   */
  export type equipment_booking_methodFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking_method to fetch.
     */
    where: equipment_booking_methodWhereUniqueInput
  }


  /**
   * equipment_booking_method findUniqueOrThrow
   */
  export type equipment_booking_methodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking_method to fetch.
     */
    where: equipment_booking_methodWhereUniqueInput
  }


  /**
   * equipment_booking_method findFirst
   */
  export type equipment_booking_methodFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking_method to fetch.
     */
    where?: equipment_booking_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_booking_methods to fetch.
     */
    orderBy?: equipment_booking_methodOrderByWithRelationInput | equipment_booking_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_booking_methods.
     */
    cursor?: equipment_booking_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_booking_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_booking_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_booking_methods.
     */
    distinct?: Equipment_booking_methodScalarFieldEnum | Equipment_booking_methodScalarFieldEnum[]
  }


  /**
   * equipment_booking_method findFirstOrThrow
   */
  export type equipment_booking_methodFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking_method to fetch.
     */
    where?: equipment_booking_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_booking_methods to fetch.
     */
    orderBy?: equipment_booking_methodOrderByWithRelationInput | equipment_booking_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipment_booking_methods.
     */
    cursor?: equipment_booking_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_booking_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_booking_methods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipment_booking_methods.
     */
    distinct?: Equipment_booking_methodScalarFieldEnum | Equipment_booking_methodScalarFieldEnum[]
  }


  /**
   * equipment_booking_method findMany
   */
  export type equipment_booking_methodFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * Filter, which equipment_booking_methods to fetch.
     */
    where?: equipment_booking_methodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipment_booking_methods to fetch.
     */
    orderBy?: equipment_booking_methodOrderByWithRelationInput | equipment_booking_methodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipment_booking_methods.
     */
    cursor?: equipment_booking_methodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipment_booking_methods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipment_booking_methods.
     */
    skip?: number
    distinct?: Equipment_booking_methodScalarFieldEnum | Equipment_booking_methodScalarFieldEnum[]
  }


  /**
   * equipment_booking_method create
   */
  export type equipment_booking_methodCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * The data needed to create a equipment_booking_method.
     */
    data: XOR<equipment_booking_methodCreateInput, equipment_booking_methodUncheckedCreateInput>
  }


  /**
   * equipment_booking_method createMany
   */
  export type equipment_booking_methodCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipment_booking_methods.
     */
    data: equipment_booking_methodCreateManyInput | equipment_booking_methodCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * equipment_booking_method update
   */
  export type equipment_booking_methodUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * The data needed to update a equipment_booking_method.
     */
    data: XOR<equipment_booking_methodUpdateInput, equipment_booking_methodUncheckedUpdateInput>
    /**
     * Choose, which equipment_booking_method to update.
     */
    where: equipment_booking_methodWhereUniqueInput
  }


  /**
   * equipment_booking_method updateMany
   */
  export type equipment_booking_methodUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipment_booking_methods.
     */
    data: XOR<equipment_booking_methodUpdateManyMutationInput, equipment_booking_methodUncheckedUpdateManyInput>
    /**
     * Filter which equipment_booking_methods to update
     */
    where?: equipment_booking_methodWhereInput
  }


  /**
   * equipment_booking_method upsert
   */
  export type equipment_booking_methodUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * The filter to search for the equipment_booking_method to update in case it exists.
     */
    where: equipment_booking_methodWhereUniqueInput
    /**
     * In case the equipment_booking_method found by the `where` argument doesn't exist, create a new equipment_booking_method with this data.
     */
    create: XOR<equipment_booking_methodCreateInput, equipment_booking_methodUncheckedCreateInput>
    /**
     * In case the equipment_booking_method was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipment_booking_methodUpdateInput, equipment_booking_methodUncheckedUpdateInput>
  }


  /**
   * equipment_booking_method delete
   */
  export type equipment_booking_methodDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
    /**
     * Filter which equipment_booking_method to delete.
     */
    where: equipment_booking_methodWhereUniqueInput
  }


  /**
   * equipment_booking_method deleteMany
   */
  export type equipment_booking_methodDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipment_booking_methods to delete
     */
    where?: equipment_booking_methodWhereInput
  }


  /**
   * equipment_booking_method without action
   */
  export type equipment_booking_methodArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipment_booking_method
     */
    select?: equipment_booking_methodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: equipment_booking_methodInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const News_typeScalarFieldEnum: {
    id: 'id',
    name_th: 'name_th',
    name_en: 'name_en',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type News_typeScalarFieldEnum = (typeof News_typeScalarFieldEnum)[keyof typeof News_typeScalarFieldEnum]


  export const NewsScalarFieldEnum: {
    id: 'id',
    news_type_id: 'news_type_id',
    title_th: 'title_th',
    title_en: 'title_en',
    detail_th: 'detail_th',
    detail_en: 'detail_en',
    news_file: 'news_file',
    is_active: 'is_active',
    is_publish: 'is_publish',
    count_views: 'count_views',
    created_news: 'created_news',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type NewsScalarFieldEnum = (typeof NewsScalarFieldEnum)[keyof typeof NewsScalarFieldEnum]


  export const BannerScalarFieldEnum: {
    id: 'id',
    title_th: 'title_th',
    title_en: 'title_en',
    banner_file: 'banner_file',
    banner_url: 'banner_url',
    is_active: 'is_active',
    is_publish: 'is_publish',
    count_views: 'count_views',
    created_banner: 'created_banner',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type BannerScalarFieldEnum = (typeof BannerScalarFieldEnum)[keyof typeof BannerScalarFieldEnum]


  export const AboutScalarFieldEnum: {
    id: 'id',
    title_th: 'title_th',
    title_en: 'title_en',
    detail_th: 'detail_th',
    detail_en: 'detail_en',
    is_active: 'is_active',
    is_publish: 'is_publish',
    count_views: 'count_views',
    created_about: 'created_about',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type AboutScalarFieldEnum = (typeof AboutScalarFieldEnum)[keyof typeof AboutScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    title_th: 'title_th',
    title_en: 'title_en',
    detail_th: 'detail_th',
    detail_en: 'detail_en',
    is_active: 'is_active',
    is_publish: 'is_publish',
    count_views: 'count_views',
    created_contact: 'created_contact',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name_th: 'name_th',
    name_en: 'name_en',
    level: 'level',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    department_id: 'department_id',
    prefix_th: 'prefix_th',
    prefix_en: 'prefix_en',
    firstname_th: 'firstname_th',
    firstname_en: 'firstname_en',
    surname_th: 'surname_th',
    surname_en: 'surname_en',
    position_th: 'position_th',
    position_en: 'position_en',
    position_level_th: 'position_level_th',
    position_level_en: 'position_level_en',
    phone: 'phone',
    email: 'email',
    level: 'level',
    team_file: 'team_file',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const News_galleryScalarFieldEnum: {
    id: 'id',
    news_id: 'news_id',
    secret_key: 'secret_key',
    news_gallery_file: 'news_gallery_file',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type News_galleryScalarFieldEnum = (typeof News_galleryScalarFieldEnum)[keyof typeof News_galleryScalarFieldEnum]


  export const Equipment_departmentScalarFieldEnum: {
    id: 'id',
    name_th: 'name_th',
    name_en: 'name_en',
    name_short: 'name_short',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type Equipment_departmentScalarFieldEnum = (typeof Equipment_departmentScalarFieldEnum)[keyof typeof Equipment_departmentScalarFieldEnum]


  export const Equipment_categoryScalarFieldEnum: {
    id: 'id',
    name_th: 'name_th',
    name_en: 'name_en',
    name_short: 'name_short',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type Equipment_categoryScalarFieldEnum = (typeof Equipment_categoryScalarFieldEnum)[keyof typeof Equipment_categoryScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    equipment_category_id: 'equipment_category_id',
    equipment_department_id: 'equipment_department_id',
    title_th: 'title_th',
    title_en: 'title_en',
    detail_th: 'detail_th',
    detail_en: 'detail_en',
    equipment_file: 'equipment_file',
    rate_file: 'rate_file',
    is_active: 'is_active',
    is_publish: 'is_publish',
    count_views: 'count_views',
    created_equipment: 'created_equipment',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const Equipment_galleryScalarFieldEnum: {
    id: 'id',
    equipment_id: 'equipment_id',
    secret_key: 'secret_key',
    equipment_gallery_file: 'equipment_gallery_file',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type Equipment_galleryScalarFieldEnum = (typeof Equipment_galleryScalarFieldEnum)[keyof typeof Equipment_galleryScalarFieldEnum]


  export const Equipment_methodScalarFieldEnum: {
    id: 'id',
    name_th: 'name_th',
    name_en: 'name_en',
    name_short: 'name_short',
    unit_th: 'unit_th',
    unit_en: 'unit_en',
    price: 'price',
    is_fixrate: 'is_fixrate',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at',
    equipment_id: 'equipment_id'
  };

  export type Equipment_methodScalarFieldEnum = (typeof Equipment_methodScalarFieldEnum)[keyof typeof Equipment_methodScalarFieldEnum]


  export const GroupScalarFieldEnum: {
    id: 'id',
    title_th: 'title_th',
    title_en: 'title_en',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type GroupScalarFieldEnum = (typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    email: 'email',
    secret_confirm_email: 'secret_confirm_email',
    password: 'password',
    status: 'status',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    prefix: 'prefix',
    firstname: 'firstname',
    surname: 'surname',
    member_status: 'member_status',
    organization: 'organization',
    contact_address: 'contact_address',
    phone: 'phone',
    email: 'email',
    invoice_name: 'invoice_name',
    invoice_address: 'invoice_address',
    tax_id: 'tax_id',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const Equipment_bookingScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    equipment_id: 'equipment_id',
    booking_date: 'booking_date',
    period_time: 'period_time',
    member_status: 'member_status',
    example: 'example',
    prefix: 'prefix',
    firstname: 'firstname',
    surname: 'surname',
    organization: 'organization',
    contact_address: 'contact_address',
    phone: 'phone',
    email: 'email',
    invoice_address: 'invoice_address',
    tax_id: 'tax_id',
    price: 'price',
    reject_comment: 'reject_comment',
    confirmed_date: 'confirmed_date',
    status_id: 'status_id',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type Equipment_bookingScalarFieldEnum = (typeof Equipment_bookingScalarFieldEnum)[keyof typeof Equipment_bookingScalarFieldEnum]


  export const Equipment_booking_methodScalarFieldEnum: {
    id: 'id',
    equipment_booking_id: 'equipment_booking_id',
    equipment_method_id: 'equipment_method_id',
    quantity: 'quantity',
    price: 'price',
    is_active: 'is_active',
    is_publish: 'is_publish',
    created_at: 'created_at',
    created_by: 'created_by',
    updated_at: 'updated_at',
    updated_by: 'updated_by',
    deleted_at: 'deleted_at'
  };

  export type Equipment_booking_methodScalarFieldEnum = (typeof Equipment_booking_methodScalarFieldEnum)[keyof typeof Equipment_booking_methodScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type news_typeWhereInput = {
    AND?: news_typeWhereInput | news_typeWhereInput[]
    OR?: news_typeWhereInput[]
    NOT?: news_typeWhereInput | news_typeWhereInput[]
    id?: IntFilter<"news_type"> | number
    name_th?: StringFilter<"news_type"> | string
    name_en?: StringNullableFilter<"news_type"> | string | null
    is_active?: IntFilter<"news_type"> | number
    is_publish?: IntFilter<"news_type"> | number
    created_at?: DateTimeNullableFilter<"news_type"> | Date | string | null
    created_by?: StringNullableFilter<"news_type"> | string | null
    updated_at?: DateTimeNullableFilter<"news_type"> | Date | string | null
    updated_by?: StringNullableFilter<"news_type"> | string | null
    deleted_at?: DateTimeNullableFilter<"news_type"> | Date | string | null
    news?: NewsListRelationFilter
  }

  export type news_typeOrderByWithRelationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    news?: newsOrderByRelationAggregateInput
  }

  export type news_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: news_typeWhereInput | news_typeWhereInput[]
    OR?: news_typeWhereInput[]
    NOT?: news_typeWhereInput | news_typeWhereInput[]
    name_th?: StringFilter<"news_type"> | string
    name_en?: StringNullableFilter<"news_type"> | string | null
    is_active?: IntFilter<"news_type"> | number
    is_publish?: IntFilter<"news_type"> | number
    created_at?: DateTimeNullableFilter<"news_type"> | Date | string | null
    created_by?: StringNullableFilter<"news_type"> | string | null
    updated_at?: DateTimeNullableFilter<"news_type"> | Date | string | null
    updated_by?: StringNullableFilter<"news_type"> | string | null
    deleted_at?: DateTimeNullableFilter<"news_type"> | Date | string | null
    news?: NewsListRelationFilter
  }, "id">

  export type news_typeOrderByWithAggregationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: news_typeCountOrderByAggregateInput
    _avg?: news_typeAvgOrderByAggregateInput
    _max?: news_typeMaxOrderByAggregateInput
    _min?: news_typeMinOrderByAggregateInput
    _sum?: news_typeSumOrderByAggregateInput
  }

  export type news_typeScalarWhereWithAggregatesInput = {
    AND?: news_typeScalarWhereWithAggregatesInput | news_typeScalarWhereWithAggregatesInput[]
    OR?: news_typeScalarWhereWithAggregatesInput[]
    NOT?: news_typeScalarWhereWithAggregatesInput | news_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"news_type"> | number
    name_th?: StringWithAggregatesFilter<"news_type"> | string
    name_en?: StringNullableWithAggregatesFilter<"news_type"> | string | null
    is_active?: IntWithAggregatesFilter<"news_type"> | number
    is_publish?: IntWithAggregatesFilter<"news_type"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"news_type"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"news_type"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"news_type"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"news_type"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"news_type"> | Date | string | null
  }

  export type newsWhereInput = {
    AND?: newsWhereInput | newsWhereInput[]
    OR?: newsWhereInput[]
    NOT?: newsWhereInput | newsWhereInput[]
    id?: IntFilter<"news"> | number
    news_type_id?: IntFilter<"news"> | number
    title_th?: StringFilter<"news"> | string
    title_en?: StringNullableFilter<"news"> | string | null
    detail_th?: StringNullableFilter<"news"> | string | null
    detail_en?: StringNullableFilter<"news"> | string | null
    news_file?: StringNullableFilter<"news"> | string | null
    is_active?: IntFilter<"news"> | number
    is_publish?: IntFilter<"news"> | number
    count_views?: IntFilter<"news"> | number
    created_news?: DateTimeFilter<"news"> | Date | string
    created_at?: DateTimeNullableFilter<"news"> | Date | string | null
    created_by?: StringNullableFilter<"news"> | string | null
    updated_at?: DateTimeNullableFilter<"news"> | Date | string | null
    updated_by?: StringNullableFilter<"news"> | string | null
    deleted_at?: DateTimeNullableFilter<"news"> | Date | string | null
    news_type?: XOR<News_typeRelationFilter, news_typeWhereInput>
  }

  export type newsOrderByWithRelationInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    news_file?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_news?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    news_type?: news_typeOrderByWithRelationInput
  }

  export type newsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: newsWhereInput | newsWhereInput[]
    OR?: newsWhereInput[]
    NOT?: newsWhereInput | newsWhereInput[]
    news_type_id?: IntFilter<"news"> | number
    title_th?: StringFilter<"news"> | string
    title_en?: StringNullableFilter<"news"> | string | null
    detail_th?: StringNullableFilter<"news"> | string | null
    detail_en?: StringNullableFilter<"news"> | string | null
    news_file?: StringNullableFilter<"news"> | string | null
    is_active?: IntFilter<"news"> | number
    is_publish?: IntFilter<"news"> | number
    count_views?: IntFilter<"news"> | number
    created_news?: DateTimeFilter<"news"> | Date | string
    created_at?: DateTimeNullableFilter<"news"> | Date | string | null
    created_by?: StringNullableFilter<"news"> | string | null
    updated_at?: DateTimeNullableFilter<"news"> | Date | string | null
    updated_by?: StringNullableFilter<"news"> | string | null
    deleted_at?: DateTimeNullableFilter<"news"> | Date | string | null
    news_type?: XOR<News_typeRelationFilter, news_typeWhereInput>
  }, "id">

  export type newsOrderByWithAggregationInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    news_file?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_news?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: newsCountOrderByAggregateInput
    _avg?: newsAvgOrderByAggregateInput
    _max?: newsMaxOrderByAggregateInput
    _min?: newsMinOrderByAggregateInput
    _sum?: newsSumOrderByAggregateInput
  }

  export type newsScalarWhereWithAggregatesInput = {
    AND?: newsScalarWhereWithAggregatesInput | newsScalarWhereWithAggregatesInput[]
    OR?: newsScalarWhereWithAggregatesInput[]
    NOT?: newsScalarWhereWithAggregatesInput | newsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"news"> | number
    news_type_id?: IntWithAggregatesFilter<"news"> | number
    title_th?: StringWithAggregatesFilter<"news"> | string
    title_en?: StringNullableWithAggregatesFilter<"news"> | string | null
    detail_th?: StringNullableWithAggregatesFilter<"news"> | string | null
    detail_en?: StringNullableWithAggregatesFilter<"news"> | string | null
    news_file?: StringNullableWithAggregatesFilter<"news"> | string | null
    is_active?: IntWithAggregatesFilter<"news"> | number
    is_publish?: IntWithAggregatesFilter<"news"> | number
    count_views?: IntWithAggregatesFilter<"news"> | number
    created_news?: DateTimeWithAggregatesFilter<"news"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"news"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"news"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"news"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"news"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"news"> | Date | string | null
  }

  export type bannerWhereInput = {
    AND?: bannerWhereInput | bannerWhereInput[]
    OR?: bannerWhereInput[]
    NOT?: bannerWhereInput | bannerWhereInput[]
    id?: IntFilter<"banner"> | number
    title_th?: StringFilter<"banner"> | string
    title_en?: StringNullableFilter<"banner"> | string | null
    banner_file?: StringNullableFilter<"banner"> | string | null
    banner_url?: StringNullableFilter<"banner"> | string | null
    is_active?: IntFilter<"banner"> | number
    is_publish?: IntFilter<"banner"> | number
    count_views?: IntFilter<"banner"> | number
    created_banner?: DateTimeFilter<"banner"> | Date | string
    created_at?: DateTimeNullableFilter<"banner"> | Date | string | null
    created_by?: StringNullableFilter<"banner"> | string | null
    updated_at?: DateTimeNullableFilter<"banner"> | Date | string | null
    updated_by?: StringNullableFilter<"banner"> | string | null
    deleted_at?: DateTimeNullableFilter<"banner"> | Date | string | null
  }

  export type bannerOrderByWithRelationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    banner_file?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_banner?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type bannerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bannerWhereInput | bannerWhereInput[]
    OR?: bannerWhereInput[]
    NOT?: bannerWhereInput | bannerWhereInput[]
    title_th?: StringFilter<"banner"> | string
    title_en?: StringNullableFilter<"banner"> | string | null
    banner_file?: StringNullableFilter<"banner"> | string | null
    banner_url?: StringNullableFilter<"banner"> | string | null
    is_active?: IntFilter<"banner"> | number
    is_publish?: IntFilter<"banner"> | number
    count_views?: IntFilter<"banner"> | number
    created_banner?: DateTimeFilter<"banner"> | Date | string
    created_at?: DateTimeNullableFilter<"banner"> | Date | string | null
    created_by?: StringNullableFilter<"banner"> | string | null
    updated_at?: DateTimeNullableFilter<"banner"> | Date | string | null
    updated_by?: StringNullableFilter<"banner"> | string | null
    deleted_at?: DateTimeNullableFilter<"banner"> | Date | string | null
  }, "id">

  export type bannerOrderByWithAggregationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    banner_file?: SortOrderInput | SortOrder
    banner_url?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_banner?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: bannerCountOrderByAggregateInput
    _avg?: bannerAvgOrderByAggregateInput
    _max?: bannerMaxOrderByAggregateInput
    _min?: bannerMinOrderByAggregateInput
    _sum?: bannerSumOrderByAggregateInput
  }

  export type bannerScalarWhereWithAggregatesInput = {
    AND?: bannerScalarWhereWithAggregatesInput | bannerScalarWhereWithAggregatesInput[]
    OR?: bannerScalarWhereWithAggregatesInput[]
    NOT?: bannerScalarWhereWithAggregatesInput | bannerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"banner"> | number
    title_th?: StringWithAggregatesFilter<"banner"> | string
    title_en?: StringNullableWithAggregatesFilter<"banner"> | string | null
    banner_file?: StringNullableWithAggregatesFilter<"banner"> | string | null
    banner_url?: StringNullableWithAggregatesFilter<"banner"> | string | null
    is_active?: IntWithAggregatesFilter<"banner"> | number
    is_publish?: IntWithAggregatesFilter<"banner"> | number
    count_views?: IntWithAggregatesFilter<"banner"> | number
    created_banner?: DateTimeWithAggregatesFilter<"banner"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"banner"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"banner"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"banner"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"banner"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"banner"> | Date | string | null
  }

  export type aboutWhereInput = {
    AND?: aboutWhereInput | aboutWhereInput[]
    OR?: aboutWhereInput[]
    NOT?: aboutWhereInput | aboutWhereInput[]
    id?: IntFilter<"about"> | number
    title_th?: StringFilter<"about"> | string
    title_en?: StringNullableFilter<"about"> | string | null
    detail_th?: StringNullableFilter<"about"> | string | null
    detail_en?: StringNullableFilter<"about"> | string | null
    is_active?: IntFilter<"about"> | number
    is_publish?: IntFilter<"about"> | number
    count_views?: IntFilter<"about"> | number
    created_about?: DateTimeFilter<"about"> | Date | string
    created_at?: DateTimeNullableFilter<"about"> | Date | string | null
    created_by?: StringNullableFilter<"about"> | string | null
    updated_at?: DateTimeNullableFilter<"about"> | Date | string | null
    updated_by?: StringNullableFilter<"about"> | string | null
    deleted_at?: DateTimeNullableFilter<"about"> | Date | string | null
  }

  export type aboutOrderByWithRelationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_about?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type aboutWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: aboutWhereInput | aboutWhereInput[]
    OR?: aboutWhereInput[]
    NOT?: aboutWhereInput | aboutWhereInput[]
    title_th?: StringFilter<"about"> | string
    title_en?: StringNullableFilter<"about"> | string | null
    detail_th?: StringNullableFilter<"about"> | string | null
    detail_en?: StringNullableFilter<"about"> | string | null
    is_active?: IntFilter<"about"> | number
    is_publish?: IntFilter<"about"> | number
    count_views?: IntFilter<"about"> | number
    created_about?: DateTimeFilter<"about"> | Date | string
    created_at?: DateTimeNullableFilter<"about"> | Date | string | null
    created_by?: StringNullableFilter<"about"> | string | null
    updated_at?: DateTimeNullableFilter<"about"> | Date | string | null
    updated_by?: StringNullableFilter<"about"> | string | null
    deleted_at?: DateTimeNullableFilter<"about"> | Date | string | null
  }, "id">

  export type aboutOrderByWithAggregationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_about?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: aboutCountOrderByAggregateInput
    _avg?: aboutAvgOrderByAggregateInput
    _max?: aboutMaxOrderByAggregateInput
    _min?: aboutMinOrderByAggregateInput
    _sum?: aboutSumOrderByAggregateInput
  }

  export type aboutScalarWhereWithAggregatesInput = {
    AND?: aboutScalarWhereWithAggregatesInput | aboutScalarWhereWithAggregatesInput[]
    OR?: aboutScalarWhereWithAggregatesInput[]
    NOT?: aboutScalarWhereWithAggregatesInput | aboutScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"about"> | number
    title_th?: StringWithAggregatesFilter<"about"> | string
    title_en?: StringNullableWithAggregatesFilter<"about"> | string | null
    detail_th?: StringNullableWithAggregatesFilter<"about"> | string | null
    detail_en?: StringNullableWithAggregatesFilter<"about"> | string | null
    is_active?: IntWithAggregatesFilter<"about"> | number
    is_publish?: IntWithAggregatesFilter<"about"> | number
    count_views?: IntWithAggregatesFilter<"about"> | number
    created_about?: DateTimeWithAggregatesFilter<"about"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"about"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"about"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"about"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"about"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"about"> | Date | string | null
  }

  export type contactWhereInput = {
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    id?: IntFilter<"contact"> | number
    title_th?: StringFilter<"contact"> | string
    title_en?: StringNullableFilter<"contact"> | string | null
    detail_th?: StringNullableFilter<"contact"> | string | null
    detail_en?: StringNullableFilter<"contact"> | string | null
    is_active?: IntFilter<"contact"> | number
    is_publish?: IntFilter<"contact"> | number
    count_views?: IntFilter<"contact"> | number
    created_contact?: DateTimeFilter<"contact"> | Date | string
    created_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    created_by?: StringNullableFilter<"contact"> | string | null
    updated_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    updated_by?: StringNullableFilter<"contact"> | string | null
    deleted_at?: DateTimeNullableFilter<"contact"> | Date | string | null
  }

  export type contactOrderByWithRelationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_contact?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type contactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: contactWhereInput | contactWhereInput[]
    OR?: contactWhereInput[]
    NOT?: contactWhereInput | contactWhereInput[]
    title_th?: StringFilter<"contact"> | string
    title_en?: StringNullableFilter<"contact"> | string | null
    detail_th?: StringNullableFilter<"contact"> | string | null
    detail_en?: StringNullableFilter<"contact"> | string | null
    is_active?: IntFilter<"contact"> | number
    is_publish?: IntFilter<"contact"> | number
    count_views?: IntFilter<"contact"> | number
    created_contact?: DateTimeFilter<"contact"> | Date | string
    created_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    created_by?: StringNullableFilter<"contact"> | string | null
    updated_at?: DateTimeNullableFilter<"contact"> | Date | string | null
    updated_by?: StringNullableFilter<"contact"> | string | null
    deleted_at?: DateTimeNullableFilter<"contact"> | Date | string | null
  }, "id">

  export type contactOrderByWithAggregationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_contact?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: contactCountOrderByAggregateInput
    _avg?: contactAvgOrderByAggregateInput
    _max?: contactMaxOrderByAggregateInput
    _min?: contactMinOrderByAggregateInput
    _sum?: contactSumOrderByAggregateInput
  }

  export type contactScalarWhereWithAggregatesInput = {
    AND?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    OR?: contactScalarWhereWithAggregatesInput[]
    NOT?: contactScalarWhereWithAggregatesInput | contactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"contact"> | number
    title_th?: StringWithAggregatesFilter<"contact"> | string
    title_en?: StringNullableWithAggregatesFilter<"contact"> | string | null
    detail_th?: StringNullableWithAggregatesFilter<"contact"> | string | null
    detail_en?: StringNullableWithAggregatesFilter<"contact"> | string | null
    is_active?: IntWithAggregatesFilter<"contact"> | number
    is_publish?: IntWithAggregatesFilter<"contact"> | number
    count_views?: IntWithAggregatesFilter<"contact"> | number
    created_contact?: DateTimeWithAggregatesFilter<"contact"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"contact"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"contact"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"contact"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"contact"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"contact"> | Date | string | null
  }

  export type departmentWhereInput = {
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    id?: IntFilter<"department"> | number
    name_th?: StringFilter<"department"> | string
    name_en?: StringNullableFilter<"department"> | string | null
    level?: IntFilter<"department"> | number
    is_active?: IntFilter<"department"> | number
    is_publish?: IntFilter<"department"> | number
    created_at?: DateTimeNullableFilter<"department"> | Date | string | null
    created_by?: StringNullableFilter<"department"> | string | null
    updated_at?: DateTimeNullableFilter<"department"> | Date | string | null
    updated_by?: StringNullableFilter<"department"> | string | null
    deleted_at?: DateTimeNullableFilter<"department"> | Date | string | null
    team?: TeamListRelationFilter
  }

  export type departmentOrderByWithRelationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    team?: teamOrderByRelationAggregateInput
  }

  export type departmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: departmentWhereInput | departmentWhereInput[]
    OR?: departmentWhereInput[]
    NOT?: departmentWhereInput | departmentWhereInput[]
    name_th?: StringFilter<"department"> | string
    name_en?: StringNullableFilter<"department"> | string | null
    level?: IntFilter<"department"> | number
    is_active?: IntFilter<"department"> | number
    is_publish?: IntFilter<"department"> | number
    created_at?: DateTimeNullableFilter<"department"> | Date | string | null
    created_by?: StringNullableFilter<"department"> | string | null
    updated_at?: DateTimeNullableFilter<"department"> | Date | string | null
    updated_by?: StringNullableFilter<"department"> | string | null
    deleted_at?: DateTimeNullableFilter<"department"> | Date | string | null
    team?: TeamListRelationFilter
  }, "id">

  export type departmentOrderByWithAggregationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: departmentCountOrderByAggregateInput
    _avg?: departmentAvgOrderByAggregateInput
    _max?: departmentMaxOrderByAggregateInput
    _min?: departmentMinOrderByAggregateInput
    _sum?: departmentSumOrderByAggregateInput
  }

  export type departmentScalarWhereWithAggregatesInput = {
    AND?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    OR?: departmentScalarWhereWithAggregatesInput[]
    NOT?: departmentScalarWhereWithAggregatesInput | departmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"department"> | number
    name_th?: StringWithAggregatesFilter<"department"> | string
    name_en?: StringNullableWithAggregatesFilter<"department"> | string | null
    level?: IntWithAggregatesFilter<"department"> | number
    is_active?: IntWithAggregatesFilter<"department"> | number
    is_publish?: IntWithAggregatesFilter<"department"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"department"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"department"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"department"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"department"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"department"> | Date | string | null
  }

  export type teamWhereInput = {
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    id?: IntFilter<"team"> | number
    department_id?: IntFilter<"team"> | number
    prefix_th?: StringNullableFilter<"team"> | string | null
    prefix_en?: StringNullableFilter<"team"> | string | null
    firstname_th?: StringNullableFilter<"team"> | string | null
    firstname_en?: StringNullableFilter<"team"> | string | null
    surname_th?: StringNullableFilter<"team"> | string | null
    surname_en?: StringNullableFilter<"team"> | string | null
    position_th?: StringNullableFilter<"team"> | string | null
    position_en?: StringNullableFilter<"team"> | string | null
    position_level_th?: StringNullableFilter<"team"> | string | null
    position_level_en?: StringNullableFilter<"team"> | string | null
    phone?: StringFilter<"team"> | string
    email?: StringFilter<"team"> | string
    level?: IntFilter<"team"> | number
    team_file?: StringNullableFilter<"team"> | string | null
    is_active?: IntFilter<"team"> | number
    is_publish?: IntFilter<"team"> | number
    created_at?: DateTimeNullableFilter<"team"> | Date | string | null
    created_by?: StringNullableFilter<"team"> | string | null
    updated_at?: DateTimeNullableFilter<"team"> | Date | string | null
    updated_by?: StringNullableFilter<"team"> | string | null
    deleted_at?: DateTimeNullableFilter<"team"> | Date | string | null
    department?: XOR<DepartmentRelationFilter, departmentWhereInput>
  }

  export type teamOrderByWithRelationInput = {
    id?: SortOrder
    department_id?: SortOrder
    prefix_th?: SortOrderInput | SortOrder
    prefix_en?: SortOrderInput | SortOrder
    firstname_th?: SortOrderInput | SortOrder
    firstname_en?: SortOrderInput | SortOrder
    surname_th?: SortOrderInput | SortOrder
    surname_en?: SortOrderInput | SortOrder
    position_th?: SortOrderInput | SortOrder
    position_en?: SortOrderInput | SortOrder
    position_level_th?: SortOrderInput | SortOrder
    position_level_en?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrder
    level?: SortOrder
    team_file?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    department?: departmentOrderByWithRelationInput
  }

  export type teamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    department_id?: IntFilter<"team"> | number
    prefix_th?: StringNullableFilter<"team"> | string | null
    prefix_en?: StringNullableFilter<"team"> | string | null
    firstname_th?: StringNullableFilter<"team"> | string | null
    firstname_en?: StringNullableFilter<"team"> | string | null
    surname_th?: StringNullableFilter<"team"> | string | null
    surname_en?: StringNullableFilter<"team"> | string | null
    position_th?: StringNullableFilter<"team"> | string | null
    position_en?: StringNullableFilter<"team"> | string | null
    position_level_th?: StringNullableFilter<"team"> | string | null
    position_level_en?: StringNullableFilter<"team"> | string | null
    phone?: StringFilter<"team"> | string
    email?: StringFilter<"team"> | string
    level?: IntFilter<"team"> | number
    team_file?: StringNullableFilter<"team"> | string | null
    is_active?: IntFilter<"team"> | number
    is_publish?: IntFilter<"team"> | number
    created_at?: DateTimeNullableFilter<"team"> | Date | string | null
    created_by?: StringNullableFilter<"team"> | string | null
    updated_at?: DateTimeNullableFilter<"team"> | Date | string | null
    updated_by?: StringNullableFilter<"team"> | string | null
    deleted_at?: DateTimeNullableFilter<"team"> | Date | string | null
    department?: XOR<DepartmentRelationFilter, departmentWhereInput>
  }, "id">

  export type teamOrderByWithAggregationInput = {
    id?: SortOrder
    department_id?: SortOrder
    prefix_th?: SortOrderInput | SortOrder
    prefix_en?: SortOrderInput | SortOrder
    firstname_th?: SortOrderInput | SortOrder
    firstname_en?: SortOrderInput | SortOrder
    surname_th?: SortOrderInput | SortOrder
    surname_en?: SortOrderInput | SortOrder
    position_th?: SortOrderInput | SortOrder
    position_en?: SortOrderInput | SortOrder
    position_level_th?: SortOrderInput | SortOrder
    position_level_en?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrder
    level?: SortOrder
    team_file?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: teamCountOrderByAggregateInput
    _avg?: teamAvgOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
    _sum?: teamSumOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    OR?: teamScalarWhereWithAggregatesInput[]
    NOT?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"team"> | number
    department_id?: IntWithAggregatesFilter<"team"> | number
    prefix_th?: StringNullableWithAggregatesFilter<"team"> | string | null
    prefix_en?: StringNullableWithAggregatesFilter<"team"> | string | null
    firstname_th?: StringNullableWithAggregatesFilter<"team"> | string | null
    firstname_en?: StringNullableWithAggregatesFilter<"team"> | string | null
    surname_th?: StringNullableWithAggregatesFilter<"team"> | string | null
    surname_en?: StringNullableWithAggregatesFilter<"team"> | string | null
    position_th?: StringNullableWithAggregatesFilter<"team"> | string | null
    position_en?: StringNullableWithAggregatesFilter<"team"> | string | null
    position_level_th?: StringNullableWithAggregatesFilter<"team"> | string | null
    position_level_en?: StringNullableWithAggregatesFilter<"team"> | string | null
    phone?: StringWithAggregatesFilter<"team"> | string
    email?: StringWithAggregatesFilter<"team"> | string
    level?: IntWithAggregatesFilter<"team"> | number
    team_file?: StringNullableWithAggregatesFilter<"team"> | string | null
    is_active?: IntWithAggregatesFilter<"team"> | number
    is_publish?: IntWithAggregatesFilter<"team"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"team"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"team"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"team"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"team"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"team"> | Date | string | null
  }

  export type news_galleryWhereInput = {
    AND?: news_galleryWhereInput | news_galleryWhereInput[]
    OR?: news_galleryWhereInput[]
    NOT?: news_galleryWhereInput | news_galleryWhereInput[]
    id?: IntFilter<"news_gallery"> | number
    news_id?: IntNullableFilter<"news_gallery"> | number | null
    secret_key?: StringFilter<"news_gallery"> | string
    news_gallery_file?: StringFilter<"news_gallery"> | string
    is_active?: IntFilter<"news_gallery"> | number
    is_publish?: IntFilter<"news_gallery"> | number
    created_at?: DateTimeNullableFilter<"news_gallery"> | Date | string | null
    created_by?: StringFilter<"news_gallery"> | string
    updated_at?: DateTimeNullableFilter<"news_gallery"> | Date | string | null
    updated_by?: StringNullableFilter<"news_gallery"> | string | null
    deleted_at?: DateTimeNullableFilter<"news_gallery"> | Date | string | null
  }

  export type news_galleryOrderByWithRelationInput = {
    id?: SortOrder
    news_id?: SortOrderInput | SortOrder
    secret_key?: SortOrder
    news_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type news_galleryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: news_galleryWhereInput | news_galleryWhereInput[]
    OR?: news_galleryWhereInput[]
    NOT?: news_galleryWhereInput | news_galleryWhereInput[]
    news_id?: IntNullableFilter<"news_gallery"> | number | null
    secret_key?: StringFilter<"news_gallery"> | string
    news_gallery_file?: StringFilter<"news_gallery"> | string
    is_active?: IntFilter<"news_gallery"> | number
    is_publish?: IntFilter<"news_gallery"> | number
    created_at?: DateTimeNullableFilter<"news_gallery"> | Date | string | null
    created_by?: StringFilter<"news_gallery"> | string
    updated_at?: DateTimeNullableFilter<"news_gallery"> | Date | string | null
    updated_by?: StringNullableFilter<"news_gallery"> | string | null
    deleted_at?: DateTimeNullableFilter<"news_gallery"> | Date | string | null
  }, "id">

  export type news_galleryOrderByWithAggregationInput = {
    id?: SortOrder
    news_id?: SortOrderInput | SortOrder
    secret_key?: SortOrder
    news_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: news_galleryCountOrderByAggregateInput
    _avg?: news_galleryAvgOrderByAggregateInput
    _max?: news_galleryMaxOrderByAggregateInput
    _min?: news_galleryMinOrderByAggregateInput
    _sum?: news_gallerySumOrderByAggregateInput
  }

  export type news_galleryScalarWhereWithAggregatesInput = {
    AND?: news_galleryScalarWhereWithAggregatesInput | news_galleryScalarWhereWithAggregatesInput[]
    OR?: news_galleryScalarWhereWithAggregatesInput[]
    NOT?: news_galleryScalarWhereWithAggregatesInput | news_galleryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"news_gallery"> | number
    news_id?: IntNullableWithAggregatesFilter<"news_gallery"> | number | null
    secret_key?: StringWithAggregatesFilter<"news_gallery"> | string
    news_gallery_file?: StringWithAggregatesFilter<"news_gallery"> | string
    is_active?: IntWithAggregatesFilter<"news_gallery"> | number
    is_publish?: IntWithAggregatesFilter<"news_gallery"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"news_gallery"> | Date | string | null
    created_by?: StringWithAggregatesFilter<"news_gallery"> | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"news_gallery"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"news_gallery"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"news_gallery"> | Date | string | null
  }

  export type equipment_departmentWhereInput = {
    AND?: equipment_departmentWhereInput | equipment_departmentWhereInput[]
    OR?: equipment_departmentWhereInput[]
    NOT?: equipment_departmentWhereInput | equipment_departmentWhereInput[]
    id?: IntFilter<"equipment_department"> | number
    name_th?: StringNullableFilter<"equipment_department"> | string | null
    name_en?: StringNullableFilter<"equipment_department"> | string | null
    name_short?: StringNullableFilter<"equipment_department"> | string | null
    is_active?: IntFilter<"equipment_department"> | number
    is_publish?: IntFilter<"equipment_department"> | number
    created_at?: DateTimeNullableFilter<"equipment_department"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_department"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_department"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_department"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_department"> | Date | string | null
    equipments?: EquipmentListRelationFilter
  }

  export type equipment_departmentOrderByWithRelationInput = {
    id?: SortOrder
    name_th?: SortOrderInput | SortOrder
    name_en?: SortOrderInput | SortOrder
    name_short?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    equipments?: equipmentOrderByRelationAggregateInput
  }

  export type equipment_departmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipment_departmentWhereInput | equipment_departmentWhereInput[]
    OR?: equipment_departmentWhereInput[]
    NOT?: equipment_departmentWhereInput | equipment_departmentWhereInput[]
    name_th?: StringNullableFilter<"equipment_department"> | string | null
    name_en?: StringNullableFilter<"equipment_department"> | string | null
    name_short?: StringNullableFilter<"equipment_department"> | string | null
    is_active?: IntFilter<"equipment_department"> | number
    is_publish?: IntFilter<"equipment_department"> | number
    created_at?: DateTimeNullableFilter<"equipment_department"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_department"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_department"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_department"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_department"> | Date | string | null
    equipments?: EquipmentListRelationFilter
  }, "id">

  export type equipment_departmentOrderByWithAggregationInput = {
    id?: SortOrder
    name_th?: SortOrderInput | SortOrder
    name_en?: SortOrderInput | SortOrder
    name_short?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: equipment_departmentCountOrderByAggregateInput
    _avg?: equipment_departmentAvgOrderByAggregateInput
    _max?: equipment_departmentMaxOrderByAggregateInput
    _min?: equipment_departmentMinOrderByAggregateInput
    _sum?: equipment_departmentSumOrderByAggregateInput
  }

  export type equipment_departmentScalarWhereWithAggregatesInput = {
    AND?: equipment_departmentScalarWhereWithAggregatesInput | equipment_departmentScalarWhereWithAggregatesInput[]
    OR?: equipment_departmentScalarWhereWithAggregatesInput[]
    NOT?: equipment_departmentScalarWhereWithAggregatesInput | equipment_departmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment_department"> | number
    name_th?: StringNullableWithAggregatesFilter<"equipment_department"> | string | null
    name_en?: StringNullableWithAggregatesFilter<"equipment_department"> | string | null
    name_short?: StringNullableWithAggregatesFilter<"equipment_department"> | string | null
    is_active?: IntWithAggregatesFilter<"equipment_department"> | number
    is_publish?: IntWithAggregatesFilter<"equipment_department"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment_department"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"equipment_department"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment_department"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment_department"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment_department"> | Date | string | null
  }

  export type equipment_categoryWhereInput = {
    AND?: equipment_categoryWhereInput | equipment_categoryWhereInput[]
    OR?: equipment_categoryWhereInput[]
    NOT?: equipment_categoryWhereInput | equipment_categoryWhereInput[]
    id?: IntFilter<"equipment_category"> | number
    name_th?: StringFilter<"equipment_category"> | string
    name_en?: StringNullableFilter<"equipment_category"> | string | null
    name_short?: StringNullableFilter<"equipment_category"> | string | null
    is_active?: IntFilter<"equipment_category"> | number
    is_publish?: IntFilter<"equipment_category"> | number
    created_at?: DateTimeNullableFilter<"equipment_category"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_category"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_category"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_category"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_category"> | Date | string | null
    equipments?: EquipmentListRelationFilter
  }

  export type equipment_categoryOrderByWithRelationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    name_short?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    equipments?: equipmentOrderByRelationAggregateInput
  }

  export type equipment_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipment_categoryWhereInput | equipment_categoryWhereInput[]
    OR?: equipment_categoryWhereInput[]
    NOT?: equipment_categoryWhereInput | equipment_categoryWhereInput[]
    name_th?: StringFilter<"equipment_category"> | string
    name_en?: StringNullableFilter<"equipment_category"> | string | null
    name_short?: StringNullableFilter<"equipment_category"> | string | null
    is_active?: IntFilter<"equipment_category"> | number
    is_publish?: IntFilter<"equipment_category"> | number
    created_at?: DateTimeNullableFilter<"equipment_category"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_category"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_category"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_category"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_category"> | Date | string | null
    equipments?: EquipmentListRelationFilter
  }, "id">

  export type equipment_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    name_short?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: equipment_categoryCountOrderByAggregateInput
    _avg?: equipment_categoryAvgOrderByAggregateInput
    _max?: equipment_categoryMaxOrderByAggregateInput
    _min?: equipment_categoryMinOrderByAggregateInput
    _sum?: equipment_categorySumOrderByAggregateInput
  }

  export type equipment_categoryScalarWhereWithAggregatesInput = {
    AND?: equipment_categoryScalarWhereWithAggregatesInput | equipment_categoryScalarWhereWithAggregatesInput[]
    OR?: equipment_categoryScalarWhereWithAggregatesInput[]
    NOT?: equipment_categoryScalarWhereWithAggregatesInput | equipment_categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment_category"> | number
    name_th?: StringWithAggregatesFilter<"equipment_category"> | string
    name_en?: StringNullableWithAggregatesFilter<"equipment_category"> | string | null
    name_short?: StringNullableWithAggregatesFilter<"equipment_category"> | string | null
    is_active?: IntWithAggregatesFilter<"equipment_category"> | number
    is_publish?: IntWithAggregatesFilter<"equipment_category"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment_category"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"equipment_category"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment_category"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment_category"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment_category"> | Date | string | null
  }

  export type equipmentWhereInput = {
    AND?: equipmentWhereInput | equipmentWhereInput[]
    OR?: equipmentWhereInput[]
    NOT?: equipmentWhereInput | equipmentWhereInput[]
    id?: IntFilter<"equipment"> | number
    equipment_category_id?: IntFilter<"equipment"> | number
    equipment_department_id?: IntFilter<"equipment"> | number
    title_th?: StringFilter<"equipment"> | string
    title_en?: StringNullableFilter<"equipment"> | string | null
    detail_th?: StringNullableFilter<"equipment"> | string | null
    detail_en?: StringNullableFilter<"equipment"> | string | null
    equipment_file?: StringNullableFilter<"equipment"> | string | null
    rate_file?: StringNullableFilter<"equipment"> | string | null
    is_active?: IntFilter<"equipment"> | number
    is_publish?: IntFilter<"equipment"> | number
    count_views?: IntFilter<"equipment"> | number
    created_equipment?: DateTimeFilter<"equipment"> | Date | string
    created_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    created_by?: StringNullableFilter<"equipment"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    equipment_category?: XOR<Equipment_categoryRelationFilter, equipment_categoryWhereInput>
    equipment_department?: XOR<Equipment_departmentRelationFilter, equipment_departmentWhereInput>
    equipment_method?: Equipment_methodListRelationFilter
    equipment_booking?: Equipment_bookingListRelationFilter
  }

  export type equipmentOrderByWithRelationInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    equipment_file?: SortOrderInput | SortOrder
    rate_file?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_equipment?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    equipment_category?: equipment_categoryOrderByWithRelationInput
    equipment_department?: equipment_departmentOrderByWithRelationInput
    equipment_method?: equipment_methodOrderByRelationAggregateInput
    equipment_booking?: equipment_bookingOrderByRelationAggregateInput
  }

  export type equipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipmentWhereInput | equipmentWhereInput[]
    OR?: equipmentWhereInput[]
    NOT?: equipmentWhereInput | equipmentWhereInput[]
    equipment_category_id?: IntFilter<"equipment"> | number
    equipment_department_id?: IntFilter<"equipment"> | number
    title_th?: StringFilter<"equipment"> | string
    title_en?: StringNullableFilter<"equipment"> | string | null
    detail_th?: StringNullableFilter<"equipment"> | string | null
    detail_en?: StringNullableFilter<"equipment"> | string | null
    equipment_file?: StringNullableFilter<"equipment"> | string | null
    rate_file?: StringNullableFilter<"equipment"> | string | null
    is_active?: IntFilter<"equipment"> | number
    is_publish?: IntFilter<"equipment"> | number
    count_views?: IntFilter<"equipment"> | number
    created_equipment?: DateTimeFilter<"equipment"> | Date | string
    created_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    created_by?: StringNullableFilter<"equipment"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    equipment_category?: XOR<Equipment_categoryRelationFilter, equipment_categoryWhereInput>
    equipment_department?: XOR<Equipment_departmentRelationFilter, equipment_departmentWhereInput>
    equipment_method?: Equipment_methodListRelationFilter
    equipment_booking?: Equipment_bookingListRelationFilter
  }, "id">

  export type equipmentOrderByWithAggregationInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    detail_th?: SortOrderInput | SortOrder
    detail_en?: SortOrderInput | SortOrder
    equipment_file?: SortOrderInput | SortOrder
    rate_file?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_equipment?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: equipmentCountOrderByAggregateInput
    _avg?: equipmentAvgOrderByAggregateInput
    _max?: equipmentMaxOrderByAggregateInput
    _min?: equipmentMinOrderByAggregateInput
    _sum?: equipmentSumOrderByAggregateInput
  }

  export type equipmentScalarWhereWithAggregatesInput = {
    AND?: equipmentScalarWhereWithAggregatesInput | equipmentScalarWhereWithAggregatesInput[]
    OR?: equipmentScalarWhereWithAggregatesInput[]
    NOT?: equipmentScalarWhereWithAggregatesInput | equipmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment"> | number
    equipment_category_id?: IntWithAggregatesFilter<"equipment"> | number
    equipment_department_id?: IntWithAggregatesFilter<"equipment"> | number
    title_th?: StringWithAggregatesFilter<"equipment"> | string
    title_en?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    detail_th?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    detail_en?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    equipment_file?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    rate_file?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    is_active?: IntWithAggregatesFilter<"equipment"> | number
    is_publish?: IntWithAggregatesFilter<"equipment"> | number
    count_views?: IntWithAggregatesFilter<"equipment"> | number
    created_equipment?: DateTimeWithAggregatesFilter<"equipment"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment"> | Date | string | null
  }

  export type equipment_galleryWhereInput = {
    AND?: equipment_galleryWhereInput | equipment_galleryWhereInput[]
    OR?: equipment_galleryWhereInput[]
    NOT?: equipment_galleryWhereInput | equipment_galleryWhereInput[]
    id?: IntFilter<"equipment_gallery"> | number
    equipment_id?: IntNullableFilter<"equipment_gallery"> | number | null
    secret_key?: StringFilter<"equipment_gallery"> | string
    equipment_gallery_file?: StringFilter<"equipment_gallery"> | string
    is_active?: IntFilter<"equipment_gallery"> | number
    is_publish?: IntFilter<"equipment_gallery"> | number
    created_at?: DateTimeNullableFilter<"equipment_gallery"> | Date | string | null
    created_by?: StringFilter<"equipment_gallery"> | string
    updated_at?: DateTimeNullableFilter<"equipment_gallery"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_gallery"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_gallery"> | Date | string | null
  }

  export type equipment_galleryOrderByWithRelationInput = {
    id?: SortOrder
    equipment_id?: SortOrderInput | SortOrder
    secret_key?: SortOrder
    equipment_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
  }

  export type equipment_galleryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipment_galleryWhereInput | equipment_galleryWhereInput[]
    OR?: equipment_galleryWhereInput[]
    NOT?: equipment_galleryWhereInput | equipment_galleryWhereInput[]
    equipment_id?: IntNullableFilter<"equipment_gallery"> | number | null
    secret_key?: StringFilter<"equipment_gallery"> | string
    equipment_gallery_file?: StringFilter<"equipment_gallery"> | string
    is_active?: IntFilter<"equipment_gallery"> | number
    is_publish?: IntFilter<"equipment_gallery"> | number
    created_at?: DateTimeNullableFilter<"equipment_gallery"> | Date | string | null
    created_by?: StringFilter<"equipment_gallery"> | string
    updated_at?: DateTimeNullableFilter<"equipment_gallery"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_gallery"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_gallery"> | Date | string | null
  }, "id">

  export type equipment_galleryOrderByWithAggregationInput = {
    id?: SortOrder
    equipment_id?: SortOrderInput | SortOrder
    secret_key?: SortOrder
    equipment_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: equipment_galleryCountOrderByAggregateInput
    _avg?: equipment_galleryAvgOrderByAggregateInput
    _max?: equipment_galleryMaxOrderByAggregateInput
    _min?: equipment_galleryMinOrderByAggregateInput
    _sum?: equipment_gallerySumOrderByAggregateInput
  }

  export type equipment_galleryScalarWhereWithAggregatesInput = {
    AND?: equipment_galleryScalarWhereWithAggregatesInput | equipment_galleryScalarWhereWithAggregatesInput[]
    OR?: equipment_galleryScalarWhereWithAggregatesInput[]
    NOT?: equipment_galleryScalarWhereWithAggregatesInput | equipment_galleryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment_gallery"> | number
    equipment_id?: IntNullableWithAggregatesFilter<"equipment_gallery"> | number | null
    secret_key?: StringWithAggregatesFilter<"equipment_gallery"> | string
    equipment_gallery_file?: StringWithAggregatesFilter<"equipment_gallery"> | string
    is_active?: IntWithAggregatesFilter<"equipment_gallery"> | number
    is_publish?: IntWithAggregatesFilter<"equipment_gallery"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment_gallery"> | Date | string | null
    created_by?: StringWithAggregatesFilter<"equipment_gallery"> | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment_gallery"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment_gallery"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment_gallery"> | Date | string | null
  }

  export type equipment_methodWhereInput = {
    AND?: equipment_methodWhereInput | equipment_methodWhereInput[]
    OR?: equipment_methodWhereInput[]
    NOT?: equipment_methodWhereInput | equipment_methodWhereInput[]
    id?: IntFilter<"equipment_method"> | number
    name_th?: StringFilter<"equipment_method"> | string
    name_en?: StringNullableFilter<"equipment_method"> | string | null
    name_short?: StringNullableFilter<"equipment_method"> | string | null
    unit_th?: StringNullableFilter<"equipment_method"> | string | null
    unit_en?: StringNullableFilter<"equipment_method"> | string | null
    price?: IntNullableFilter<"equipment_method"> | number | null
    is_fixrate?: IntNullableFilter<"equipment_method"> | number | null
    is_active?: IntFilter<"equipment_method"> | number
    is_publish?: IntFilter<"equipment_method"> | number
    created_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_method"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_method"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    equipment_id?: IntFilter<"equipment_method"> | number
    equipment?: XOR<EquipmentRelationFilter, equipmentWhereInput>
    equipment_booking_method?: Equipment_booking_methodListRelationFilter
  }

  export type equipment_methodOrderByWithRelationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    name_short?: SortOrderInput | SortOrder
    unit_th?: SortOrderInput | SortOrder
    unit_en?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    is_fixrate?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    equipment_id?: SortOrder
    equipment?: equipmentOrderByWithRelationInput
    equipment_booking_method?: equipment_booking_methodOrderByRelationAggregateInput
  }

  export type equipment_methodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipment_methodWhereInput | equipment_methodWhereInput[]
    OR?: equipment_methodWhereInput[]
    NOT?: equipment_methodWhereInput | equipment_methodWhereInput[]
    name_th?: StringFilter<"equipment_method"> | string
    name_en?: StringNullableFilter<"equipment_method"> | string | null
    name_short?: StringNullableFilter<"equipment_method"> | string | null
    unit_th?: StringNullableFilter<"equipment_method"> | string | null
    unit_en?: StringNullableFilter<"equipment_method"> | string | null
    price?: IntNullableFilter<"equipment_method"> | number | null
    is_fixrate?: IntNullableFilter<"equipment_method"> | number | null
    is_active?: IntFilter<"equipment_method"> | number
    is_publish?: IntFilter<"equipment_method"> | number
    created_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_method"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_method"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    equipment_id?: IntFilter<"equipment_method"> | number
    equipment?: XOR<EquipmentRelationFilter, equipmentWhereInput>
    equipment_booking_method?: Equipment_booking_methodListRelationFilter
  }, "id">

  export type equipment_methodOrderByWithAggregationInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrderInput | SortOrder
    name_short?: SortOrderInput | SortOrder
    unit_th?: SortOrderInput | SortOrder
    unit_en?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    is_fixrate?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    equipment_id?: SortOrder
    _count?: equipment_methodCountOrderByAggregateInput
    _avg?: equipment_methodAvgOrderByAggregateInput
    _max?: equipment_methodMaxOrderByAggregateInput
    _min?: equipment_methodMinOrderByAggregateInput
    _sum?: equipment_methodSumOrderByAggregateInput
  }

  export type equipment_methodScalarWhereWithAggregatesInput = {
    AND?: equipment_methodScalarWhereWithAggregatesInput | equipment_methodScalarWhereWithAggregatesInput[]
    OR?: equipment_methodScalarWhereWithAggregatesInput[]
    NOT?: equipment_methodScalarWhereWithAggregatesInput | equipment_methodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment_method"> | number
    name_th?: StringWithAggregatesFilter<"equipment_method"> | string
    name_en?: StringNullableWithAggregatesFilter<"equipment_method"> | string | null
    name_short?: StringNullableWithAggregatesFilter<"equipment_method"> | string | null
    unit_th?: StringNullableWithAggregatesFilter<"equipment_method"> | string | null
    unit_en?: StringNullableWithAggregatesFilter<"equipment_method"> | string | null
    price?: IntNullableWithAggregatesFilter<"equipment_method"> | number | null
    is_fixrate?: IntNullableWithAggregatesFilter<"equipment_method"> | number | null
    is_active?: IntWithAggregatesFilter<"equipment_method"> | number
    is_publish?: IntWithAggregatesFilter<"equipment_method"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment_method"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"equipment_method"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment_method"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment_method"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment_method"> | Date | string | null
    equipment_id?: IntWithAggregatesFilter<"equipment_method"> | number
  }

  export type groupWhereInput = {
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    id?: IntFilter<"group"> | number
    title_th?: StringFilter<"group"> | string
    title_en?: StringNullableFilter<"group"> | string | null
    is_active?: IntFilter<"group"> | number
    is_publish?: IntFilter<"group"> | number
    created_at?: DateTimeNullableFilter<"group"> | Date | string | null
    created_by?: StringNullableFilter<"group"> | string | null
    updated_at?: DateTimeNullableFilter<"group"> | Date | string | null
    updated_by?: StringNullableFilter<"group"> | string | null
    deleted_at?: DateTimeNullableFilter<"group"> | Date | string | null
    users?: UserListRelationFilter
  }

  export type groupOrderByWithRelationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: userOrderByRelationAggregateInput
  }

  export type groupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: groupWhereInput | groupWhereInput[]
    OR?: groupWhereInput[]
    NOT?: groupWhereInput | groupWhereInput[]
    title_th?: StringFilter<"group"> | string
    title_en?: StringNullableFilter<"group"> | string | null
    is_active?: IntFilter<"group"> | number
    is_publish?: IntFilter<"group"> | number
    created_at?: DateTimeNullableFilter<"group"> | Date | string | null
    created_by?: StringNullableFilter<"group"> | string | null
    updated_at?: DateTimeNullableFilter<"group"> | Date | string | null
    updated_by?: StringNullableFilter<"group"> | string | null
    deleted_at?: DateTimeNullableFilter<"group"> | Date | string | null
    users?: UserListRelationFilter
  }, "id">

  export type groupOrderByWithAggregationInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: groupCountOrderByAggregateInput
    _avg?: groupAvgOrderByAggregateInput
    _max?: groupMaxOrderByAggregateInput
    _min?: groupMinOrderByAggregateInput
    _sum?: groupSumOrderByAggregateInput
  }

  export type groupScalarWhereWithAggregatesInput = {
    AND?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    OR?: groupScalarWhereWithAggregatesInput[]
    NOT?: groupScalarWhereWithAggregatesInput | groupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"group"> | number
    title_th?: StringWithAggregatesFilter<"group"> | string
    title_en?: StringNullableWithAggregatesFilter<"group"> | string | null
    is_active?: IntWithAggregatesFilter<"group"> | number
    is_publish?: IntWithAggregatesFilter<"group"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"group"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"group"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"group"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"group"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"group"> | Date | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: IntFilter<"user"> | number
    group_id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    secret_confirm_email?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    status?: IntFilter<"user"> | number
    is_active?: IntFilter<"user"> | number
    is_publish?: IntFilter<"user"> | number
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    created_by?: StringNullableFilter<"user"> | string | null
    updated_at?: DateTimeNullableFilter<"user"> | Date | string | null
    updated_by?: StringNullableFilter<"user"> | string | null
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    group?: XOR<GroupRelationFilter, groupWhereInput>
    profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    equipment_booking?: Equipment_bookingListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    email?: SortOrder
    secret_confirm_email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    group?: groupOrderByWithRelationInput
    profile?: profileOrderByWithRelationInput
    equipment_booking?: equipment_bookingOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    group_id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    secret_confirm_email?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    status?: IntFilter<"user"> | number
    is_active?: IntFilter<"user"> | number
    is_publish?: IntFilter<"user"> | number
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    created_by?: StringNullableFilter<"user"> | string | null
    updated_at?: DateTimeNullableFilter<"user"> | Date | string | null
    updated_by?: StringNullableFilter<"user"> | string | null
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
    group?: XOR<GroupRelationFilter, groupWhereInput>
    profile?: XOR<ProfileNullableRelationFilter, profileWhereInput> | null
    equipment_booking?: Equipment_bookingListRelationFilter
  }, "id">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    email?: SortOrder
    secret_confirm_email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _avg?: userAvgOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
    _sum?: userSumOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user"> | number
    group_id?: IntWithAggregatesFilter<"user"> | number
    email?: StringWithAggregatesFilter<"user"> | string
    secret_confirm_email?: StringNullableWithAggregatesFilter<"user"> | string | null
    password?: StringNullableWithAggregatesFilter<"user"> | string | null
    status?: IntWithAggregatesFilter<"user"> | number
    is_active?: IntWithAggregatesFilter<"user"> | number
    is_publish?: IntWithAggregatesFilter<"user"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"user"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"user"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"user"> | Date | string | null
  }

  export type profileWhereInput = {
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    id?: IntFilter<"profile"> | number
    user_id?: IntFilter<"profile"> | number
    prefix?: StringNullableFilter<"profile"> | string | null
    firstname?: StringNullableFilter<"profile"> | string | null
    surname?: StringNullableFilter<"profile"> | string | null
    member_status?: IntFilter<"profile"> | number
    organization?: StringNullableFilter<"profile"> | string | null
    contact_address?: StringNullableFilter<"profile"> | string | null
    phone?: StringNullableFilter<"profile"> | string | null
    email?: StringNullableFilter<"profile"> | string | null
    invoice_name?: StringNullableFilter<"profile"> | string | null
    invoice_address?: StringNullableFilter<"profile"> | string | null
    tax_id?: StringNullableFilter<"profile"> | string | null
    is_active?: IntFilter<"profile"> | number
    is_publish?: IntFilter<"profile"> | number
    created_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    created_by?: StringNullableFilter<"profile"> | string | null
    updated_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    updated_by?: StringNullableFilter<"profile"> | string | null
    deleted_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type profileOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    prefix?: SortOrderInput | SortOrder
    firstname?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    member_status?: SortOrder
    organization?: SortOrderInput | SortOrder
    contact_address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    invoice_name?: SortOrderInput | SortOrder
    invoice_address?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type profileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id?: number
    AND?: profileWhereInput | profileWhereInput[]
    OR?: profileWhereInput[]
    NOT?: profileWhereInput | profileWhereInput[]
    prefix?: StringNullableFilter<"profile"> | string | null
    firstname?: StringNullableFilter<"profile"> | string | null
    surname?: StringNullableFilter<"profile"> | string | null
    member_status?: IntFilter<"profile"> | number
    organization?: StringNullableFilter<"profile"> | string | null
    contact_address?: StringNullableFilter<"profile"> | string | null
    phone?: StringNullableFilter<"profile"> | string | null
    email?: StringNullableFilter<"profile"> | string | null
    invoice_name?: StringNullableFilter<"profile"> | string | null
    invoice_address?: StringNullableFilter<"profile"> | string | null
    tax_id?: StringNullableFilter<"profile"> | string | null
    is_active?: IntFilter<"profile"> | number
    is_publish?: IntFilter<"profile"> | number
    created_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    created_by?: StringNullableFilter<"profile"> | string | null
    updated_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    updated_by?: StringNullableFilter<"profile"> | string | null
    deleted_at?: DateTimeNullableFilter<"profile"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
  }, "id" | "user_id">

  export type profileOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    prefix?: SortOrderInput | SortOrder
    firstname?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    member_status?: SortOrder
    organization?: SortOrderInput | SortOrder
    contact_address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    invoice_name?: SortOrderInput | SortOrder
    invoice_address?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: profileCountOrderByAggregateInput
    _avg?: profileAvgOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
    _sum?: profileSumOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    OR?: profileScalarWhereWithAggregatesInput[]
    NOT?: profileScalarWhereWithAggregatesInput | profileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"profile"> | number
    user_id?: IntWithAggregatesFilter<"profile"> | number
    prefix?: StringNullableWithAggregatesFilter<"profile"> | string | null
    firstname?: StringNullableWithAggregatesFilter<"profile"> | string | null
    surname?: StringNullableWithAggregatesFilter<"profile"> | string | null
    member_status?: IntWithAggregatesFilter<"profile"> | number
    organization?: StringNullableWithAggregatesFilter<"profile"> | string | null
    contact_address?: StringNullableWithAggregatesFilter<"profile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"profile"> | string | null
    email?: StringNullableWithAggregatesFilter<"profile"> | string | null
    invoice_name?: StringNullableWithAggregatesFilter<"profile"> | string | null
    invoice_address?: StringNullableWithAggregatesFilter<"profile"> | string | null
    tax_id?: StringNullableWithAggregatesFilter<"profile"> | string | null
    is_active?: IntWithAggregatesFilter<"profile"> | number
    is_publish?: IntWithAggregatesFilter<"profile"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"profile"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"profile"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"profile"> | Date | string | null
  }

  export type equipment_bookingWhereInput = {
    AND?: equipment_bookingWhereInput | equipment_bookingWhereInput[]
    OR?: equipment_bookingWhereInput[]
    NOT?: equipment_bookingWhereInput | equipment_bookingWhereInput[]
    id?: IntFilter<"equipment_booking"> | number
    user_id?: IntFilter<"equipment_booking"> | number
    equipment_id?: IntFilter<"equipment_booking"> | number
    booking_date?: DateTimeFilter<"equipment_booking"> | Date | string
    period_time?: IntFilter<"equipment_booking"> | number
    member_status?: IntFilter<"equipment_booking"> | number
    example?: StringNullableFilter<"equipment_booking"> | string | null
    prefix?: StringNullableFilter<"equipment_booking"> | string | null
    firstname?: StringNullableFilter<"equipment_booking"> | string | null
    surname?: StringNullableFilter<"equipment_booking"> | string | null
    organization?: StringNullableFilter<"equipment_booking"> | string | null
    contact_address?: StringNullableFilter<"equipment_booking"> | string | null
    phone?: StringNullableFilter<"equipment_booking"> | string | null
    email?: StringNullableFilter<"equipment_booking"> | string | null
    invoice_address?: StringNullableFilter<"equipment_booking"> | string | null
    tax_id?: StringNullableFilter<"equipment_booking"> | string | null
    price?: IntNullableFilter<"equipment_booking"> | number | null
    reject_comment?: StringNullableFilter<"equipment_booking"> | string | null
    confirmed_date?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    status_id?: IntFilter<"equipment_booking"> | number
    is_active?: IntFilter<"equipment_booking"> | number
    is_publish?: IntFilter<"equipment_booking"> | number
    created_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_booking"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_booking"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    equipment?: XOR<EquipmentRelationFilter, equipmentWhereInput>
    equipment_booking_method?: Equipment_booking_methodListRelationFilter
  }

  export type equipment_bookingOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    booking_date?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    example?: SortOrderInput | SortOrder
    prefix?: SortOrderInput | SortOrder
    firstname?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    contact_address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    invoice_address?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    reject_comment?: SortOrderInput | SortOrder
    confirmed_date?: SortOrderInput | SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    equipment?: equipmentOrderByWithRelationInput
    equipment_booking_method?: equipment_booking_methodOrderByRelationAggregateInput
  }

  export type equipment_bookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipment_bookingWhereInput | equipment_bookingWhereInput[]
    OR?: equipment_bookingWhereInput[]
    NOT?: equipment_bookingWhereInput | equipment_bookingWhereInput[]
    user_id?: IntFilter<"equipment_booking"> | number
    equipment_id?: IntFilter<"equipment_booking"> | number
    booking_date?: DateTimeFilter<"equipment_booking"> | Date | string
    period_time?: IntFilter<"equipment_booking"> | number
    member_status?: IntFilter<"equipment_booking"> | number
    example?: StringNullableFilter<"equipment_booking"> | string | null
    prefix?: StringNullableFilter<"equipment_booking"> | string | null
    firstname?: StringNullableFilter<"equipment_booking"> | string | null
    surname?: StringNullableFilter<"equipment_booking"> | string | null
    organization?: StringNullableFilter<"equipment_booking"> | string | null
    contact_address?: StringNullableFilter<"equipment_booking"> | string | null
    phone?: StringNullableFilter<"equipment_booking"> | string | null
    email?: StringNullableFilter<"equipment_booking"> | string | null
    invoice_address?: StringNullableFilter<"equipment_booking"> | string | null
    tax_id?: StringNullableFilter<"equipment_booking"> | string | null
    price?: IntNullableFilter<"equipment_booking"> | number | null
    reject_comment?: StringNullableFilter<"equipment_booking"> | string | null
    confirmed_date?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    status_id?: IntFilter<"equipment_booking"> | number
    is_active?: IntFilter<"equipment_booking"> | number
    is_publish?: IntFilter<"equipment_booking"> | number
    created_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_booking"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_booking"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    user?: XOR<UserRelationFilter, userWhereInput>
    equipment?: XOR<EquipmentRelationFilter, equipmentWhereInput>
    equipment_booking_method?: Equipment_booking_methodListRelationFilter
  }, "id">

  export type equipment_bookingOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    booking_date?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    example?: SortOrderInput | SortOrder
    prefix?: SortOrderInput | SortOrder
    firstname?: SortOrderInput | SortOrder
    surname?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    contact_address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    invoice_address?: SortOrderInput | SortOrder
    tax_id?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    reject_comment?: SortOrderInput | SortOrder
    confirmed_date?: SortOrderInput | SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: equipment_bookingCountOrderByAggregateInput
    _avg?: equipment_bookingAvgOrderByAggregateInput
    _max?: equipment_bookingMaxOrderByAggregateInput
    _min?: equipment_bookingMinOrderByAggregateInput
    _sum?: equipment_bookingSumOrderByAggregateInput
  }

  export type equipment_bookingScalarWhereWithAggregatesInput = {
    AND?: equipment_bookingScalarWhereWithAggregatesInput | equipment_bookingScalarWhereWithAggregatesInput[]
    OR?: equipment_bookingScalarWhereWithAggregatesInput[]
    NOT?: equipment_bookingScalarWhereWithAggregatesInput | equipment_bookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment_booking"> | number
    user_id?: IntWithAggregatesFilter<"equipment_booking"> | number
    equipment_id?: IntWithAggregatesFilter<"equipment_booking"> | number
    booking_date?: DateTimeWithAggregatesFilter<"equipment_booking"> | Date | string
    period_time?: IntWithAggregatesFilter<"equipment_booking"> | number
    member_status?: IntWithAggregatesFilter<"equipment_booking"> | number
    example?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    prefix?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    firstname?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    surname?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    organization?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    contact_address?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    phone?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    email?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    invoice_address?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    tax_id?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    price?: IntNullableWithAggregatesFilter<"equipment_booking"> | number | null
    reject_comment?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    confirmed_date?: DateTimeNullableWithAggregatesFilter<"equipment_booking"> | Date | string | null
    status_id?: IntWithAggregatesFilter<"equipment_booking"> | number
    is_active?: IntWithAggregatesFilter<"equipment_booking"> | number
    is_publish?: IntWithAggregatesFilter<"equipment_booking"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment_booking"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment_booking"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment_booking"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment_booking"> | Date | string | null
  }

  export type equipment_booking_methodWhereInput = {
    AND?: equipment_booking_methodWhereInput | equipment_booking_methodWhereInput[]
    OR?: equipment_booking_methodWhereInput[]
    NOT?: equipment_booking_methodWhereInput | equipment_booking_methodWhereInput[]
    id?: IntFilter<"equipment_booking_method"> | number
    equipment_booking_id?: IntFilter<"equipment_booking_method"> | number
    equipment_method_id?: IntFilter<"equipment_booking_method"> | number
    quantity?: IntNullableFilter<"equipment_booking_method"> | number | null
    price?: IntNullableFilter<"equipment_booking_method"> | number | null
    is_active?: IntFilter<"equipment_booking_method"> | number
    is_publish?: IntFilter<"equipment_booking_method"> | number
    created_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_booking_method"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_booking_method"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    equipment_booking?: XOR<Equipment_bookingRelationFilter, equipment_bookingWhereInput>
    equipment_method?: XOR<Equipment_methodRelationFilter, equipment_methodWhereInput>
  }

  export type equipment_booking_methodOrderByWithRelationInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    equipment_booking?: equipment_bookingOrderByWithRelationInput
    equipment_method?: equipment_methodOrderByWithRelationInput
  }

  export type equipment_booking_methodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipment_booking_methodWhereInput | equipment_booking_methodWhereInput[]
    OR?: equipment_booking_methodWhereInput[]
    NOT?: equipment_booking_methodWhereInput | equipment_booking_methodWhereInput[]
    equipment_booking_id?: IntFilter<"equipment_booking_method"> | number
    equipment_method_id?: IntFilter<"equipment_booking_method"> | number
    quantity?: IntNullableFilter<"equipment_booking_method"> | number | null
    price?: IntNullableFilter<"equipment_booking_method"> | number | null
    is_active?: IntFilter<"equipment_booking_method"> | number
    is_publish?: IntFilter<"equipment_booking_method"> | number
    created_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_booking_method"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_booking_method"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    equipment_booking?: XOR<Equipment_bookingRelationFilter, equipment_bookingWhereInput>
    equipment_method?: XOR<Equipment_methodRelationFilter, equipment_methodWhereInput>
  }, "id">

  export type equipment_booking_methodOrderByWithAggregationInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    updated_by?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: equipment_booking_methodCountOrderByAggregateInput
    _avg?: equipment_booking_methodAvgOrderByAggregateInput
    _max?: equipment_booking_methodMaxOrderByAggregateInput
    _min?: equipment_booking_methodMinOrderByAggregateInput
    _sum?: equipment_booking_methodSumOrderByAggregateInput
  }

  export type equipment_booking_methodScalarWhereWithAggregatesInput = {
    AND?: equipment_booking_methodScalarWhereWithAggregatesInput | equipment_booking_methodScalarWhereWithAggregatesInput[]
    OR?: equipment_booking_methodScalarWhereWithAggregatesInput[]
    NOT?: equipment_booking_methodScalarWhereWithAggregatesInput | equipment_booking_methodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipment_booking_method"> | number
    equipment_booking_id?: IntWithAggregatesFilter<"equipment_booking_method"> | number
    equipment_method_id?: IntWithAggregatesFilter<"equipment_booking_method"> | number
    quantity?: IntNullableWithAggregatesFilter<"equipment_booking_method"> | number | null
    price?: IntNullableWithAggregatesFilter<"equipment_booking_method"> | number | null
    is_active?: IntWithAggregatesFilter<"equipment_booking_method"> | number
    is_publish?: IntWithAggregatesFilter<"equipment_booking_method"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"equipment_booking_method"> | Date | string | null
    created_by?: StringNullableWithAggregatesFilter<"equipment_booking_method"> | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"equipment_booking_method"> | Date | string | null
    updated_by?: StringNullableWithAggregatesFilter<"equipment_booking_method"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"equipment_booking_method"> | Date | string | null
  }

  export type news_typeCreateInput = {
    name_th: string
    name_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    news?: newsCreateNestedManyWithoutNews_typeInput
  }

  export type news_typeUncheckedCreateInput = {
    id?: number
    name_th: string
    name_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    news?: newsUncheckedCreateNestedManyWithoutNews_typeInput
  }

  export type news_typeUpdateInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    news?: newsUpdateManyWithoutNews_typeNestedInput
  }

  export type news_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    news?: newsUncheckedUpdateManyWithoutNews_typeNestedInput
  }

  export type news_typeCreateManyInput = {
    id?: number
    name_th: string
    name_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type news_typeUpdateManyMutationInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsCreateInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    news_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_news: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    news_type: news_typeCreateNestedOneWithoutNewsInput
  }

  export type newsUncheckedCreateInput = {
    id?: number
    news_type_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    news_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_news: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type newsUpdateInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    news_type?: news_typeUpdateOneRequiredWithoutNewsNestedInput
  }

  export type newsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    news_type_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsCreateManyInput = {
    id?: number
    news_type_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    news_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_news: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type newsUpdateManyMutationInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    news_type_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bannerCreateInput = {
    title_th: string
    title_en?: string | null
    banner_file?: string | null
    banner_url?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_banner: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type bannerUncheckedCreateInput = {
    id?: number
    title_th: string
    title_en?: string | null
    banner_file?: string | null
    banner_url?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_banner: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type bannerUpdateInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    banner_file?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_banner?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bannerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    banner_file?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_banner?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bannerCreateManyInput = {
    id?: number
    title_th: string
    title_en?: string | null
    banner_file?: string | null
    banner_url?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_banner: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type bannerUpdateManyMutationInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    banner_file?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_banner?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bannerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    banner_file?: NullableStringFieldUpdateOperationsInput | string | null
    banner_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_banner?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aboutCreateInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_about: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type aboutUncheckedCreateInput = {
    id?: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_about: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type aboutUpdateInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_about?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aboutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_about?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aboutCreateManyInput = {
    id?: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_about: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type aboutUpdateManyMutationInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_about?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type aboutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_about?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactCreateInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_contact: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type contactUncheckedCreateInput = {
    id?: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_contact: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type contactUpdateInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_contact?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_contact?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactCreateManyInput = {
    id?: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_contact: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type contactUpdateManyMutationInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_contact?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_contact?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type departmentCreateInput = {
    name_th: string
    name_en?: string | null
    level: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    team?: teamCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUncheckedCreateInput = {
    id?: number
    name_th: string
    name_en?: string | null
    level: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    team?: teamUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type departmentUpdateInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: teamUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: teamUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type departmentCreateManyInput = {
    id?: number
    name_th: string
    name_en?: string | null
    level: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type departmentUpdateManyMutationInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type departmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamCreateInput = {
    prefix_th?: string | null
    prefix_en?: string | null
    firstname_th?: string | null
    firstname_en?: string | null
    surname_th?: string | null
    surname_en?: string | null
    position_th?: string | null
    position_en?: string | null
    position_level_th?: string | null
    position_level_en?: string | null
    phone: string
    email: string
    level: number
    team_file?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    department: departmentCreateNestedOneWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    id?: number
    department_id: number
    prefix_th?: string | null
    prefix_en?: string | null
    firstname_th?: string | null
    firstname_en?: string | null
    surname_th?: string | null
    surname_en?: string | null
    position_th?: string | null
    position_en?: string | null
    position_level_th?: string | null
    position_level_en?: string | null
    phone: string
    email: string
    level: number
    team_file?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type teamUpdateInput = {
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    department?: departmentUpdateOneRequiredWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamCreateManyInput = {
    id?: number
    department_id: number
    prefix_th?: string | null
    prefix_en?: string | null
    firstname_th?: string | null
    firstname_en?: string | null
    surname_th?: string | null
    surname_en?: string | null
    position_th?: string | null
    position_en?: string | null
    position_level_th?: string | null
    position_level_en?: string | null
    phone: string
    email: string
    level: number
    team_file?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type teamUpdateManyMutationInput = {
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    department_id?: IntFieldUpdateOperationsInput | number
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_galleryCreateInput = {
    news_id?: number | null
    secret_key: string
    news_gallery_file: string
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by: string
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type news_galleryUncheckedCreateInput = {
    id?: number
    news_id?: number | null
    secret_key: string
    news_gallery_file: string
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by: string
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type news_galleryUpdateInput = {
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    news_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_galleryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    news_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_galleryCreateManyInput = {
    id?: number
    news_id?: number | null
    secret_key: string
    news_gallery_file: string
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by: string
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type news_galleryUpdateManyMutationInput = {
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    news_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_galleryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    news_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    news_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_departmentCreateInput = {
    name_th?: string | null
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipments?: equipmentCreateNestedManyWithoutEquipment_departmentInput
  }

  export type equipment_departmentUncheckedCreateInput = {
    id?: number
    name_th?: string | null
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipments?: equipmentUncheckedCreateNestedManyWithoutEquipment_departmentInput
  }

  export type equipment_departmentUpdateInput = {
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipments?: equipmentUpdateManyWithoutEquipment_departmentNestedInput
  }

  export type equipment_departmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipments?: equipmentUncheckedUpdateManyWithoutEquipment_departmentNestedInput
  }

  export type equipment_departmentCreateManyInput = {
    id?: number
    name_th?: string | null
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_departmentUpdateManyMutationInput = {
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_departmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_categoryCreateInput = {
    name_th: string
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipments?: equipmentCreateNestedManyWithoutEquipment_categoryInput
  }

  export type equipment_categoryUncheckedCreateInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipments?: equipmentUncheckedCreateNestedManyWithoutEquipment_categoryInput
  }

  export type equipment_categoryUpdateInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipments?: equipmentUpdateManyWithoutEquipment_categoryNestedInput
  }

  export type equipment_categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipments?: equipmentUncheckedUpdateManyWithoutEquipment_categoryNestedInput
  }

  export type equipment_categoryCreateManyInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_categoryUpdateManyMutationInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipmentCreateInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_category: equipment_categoryCreateNestedOneWithoutEquipmentsInput
    equipment_department: equipment_departmentCreateNestedOneWithoutEquipmentsInput
    equipment_method?: equipment_methodCreateNestedManyWithoutEquipmentInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUncheckedCreateInput = {
    id?: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_method?: equipment_methodUncheckedCreateNestedManyWithoutEquipmentInput
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUpdateInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_category?: equipment_categoryUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_department?: equipment_departmentUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_method?: equipment_methodUpdateManyWithoutEquipmentNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_category_id?: IntFieldUpdateOperationsInput | number
    equipment_department_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_method?: equipment_methodUncheckedUpdateManyWithoutEquipmentNestedInput
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentCreateManyInput = {
    id?: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipmentUpdateManyMutationInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_category_id?: IntFieldUpdateOperationsInput | number
    equipment_department_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_galleryCreateInput = {
    equipment_id?: number | null
    secret_key: string
    equipment_gallery_file: string
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by: string
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_galleryUncheckedCreateInput = {
    id?: number
    equipment_id?: number | null
    secret_key: string
    equipment_gallery_file: string
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by: string
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_galleryUpdateInput = {
    equipment_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    equipment_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_galleryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    equipment_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_galleryCreateManyInput = {
    id?: number
    equipment_id?: number | null
    secret_key: string
    equipment_gallery_file: string
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by: string
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_galleryUpdateManyMutationInput = {
    equipment_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    equipment_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_galleryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_id?: NullableIntFieldUpdateOperationsInput | number | null
    secret_key?: StringFieldUpdateOperationsInput | string
    equipment_gallery_file?: StringFieldUpdateOperationsInput | string
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_methodCreateInput = {
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment: equipmentCreateNestedOneWithoutEquipment_methodInput
    equipment_booking_method?: equipment_booking_methodCreateNestedManyWithoutEquipment_methodInput
  }

  export type equipment_methodUncheckedCreateInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_id: number
    equipment_booking_method?: equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_methodInput
  }

  export type equipment_methodUpdateInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: equipmentUpdateOneRequiredWithoutEquipment_methodNestedInput
    equipment_booking_method?: equipment_booking_methodUpdateManyWithoutEquipment_methodNestedInput
  }

  export type equipment_methodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_id?: IntFieldUpdateOperationsInput | number
    equipment_booking_method?: equipment_booking_methodUncheckedUpdateManyWithoutEquipment_methodNestedInput
  }

  export type equipment_methodCreateManyInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_id: number
  }

  export type equipment_methodUpdateManyMutationInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_methodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_id?: IntFieldUpdateOperationsInput | number
  }

  export type groupCreateInput = {
    title_th: string
    title_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    users?: userCreateNestedManyWithoutGroupInput
  }

  export type groupUncheckedCreateInput = {
    id?: number
    title_th: string
    title_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    users?: userUncheckedCreateNestedManyWithoutGroupInput
  }

  export type groupUpdateInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUpdateManyWithoutGroupNestedInput
  }

  export type groupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: userUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type groupCreateManyInput = {
    id?: number
    title_th: string
    title_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type groupUpdateManyMutationInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateInput = {
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    group: groupCreateNestedOneWithoutUsersInput
    profile?: profileCreateNestedOneWithoutUserInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: number
    group_id: number
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: groupUpdateOneRequiredWithoutUsersNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: number
    group_id: number
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type userUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileCreateInput = {
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    member_status: number
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_name?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutProfileInput
  }

  export type profileUncheckedCreateInput = {
    id?: number
    user_id: number
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    member_status: number
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_name?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type profileUpdateInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    member_status?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    member_status?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileCreateManyInput = {
    id?: number
    user_id: number
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    member_status: number
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_name?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type profileUpdateManyMutationInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    member_status?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    member_status?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_bookingCreateInput = {
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutEquipment_bookingInput
    equipment: equipmentCreateNestedOneWithoutEquipment_bookingInput
    equipment_booking_method?: equipment_booking_methodCreateNestedManyWithoutEquipment_bookingInput
  }

  export type equipment_bookingUncheckedCreateInput = {
    id?: number
    user_id: number
    equipment_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_bookingInput
  }

  export type equipment_bookingUpdateInput = {
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutEquipment_bookingNestedInput
    equipment?: equipmentUpdateOneRequiredWithoutEquipment_bookingNestedInput
    equipment_booking_method?: equipment_booking_methodUpdateManyWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    equipment_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedUpdateManyWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingCreateManyInput = {
    id?: number
    user_id: number
    equipment_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_bookingUpdateManyMutationInput = {
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_bookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    equipment_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodCreateInput = {
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking: equipment_bookingCreateNestedOneWithoutEquipment_booking_methodInput
    equipment_method: equipment_methodCreateNestedOneWithoutEquipment_booking_methodInput
  }

  export type equipment_booking_methodUncheckedCreateInput = {
    id?: number
    equipment_booking_id: number
    equipment_method_id: number
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_booking_methodUpdateInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking?: equipment_bookingUpdateOneRequiredWithoutEquipment_booking_methodNestedInput
    equipment_method?: equipment_methodUpdateOneRequiredWithoutEquipment_booking_methodNestedInput
  }

  export type equipment_booking_methodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_booking_id?: IntFieldUpdateOperationsInput | number
    equipment_method_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodCreateManyInput = {
    id?: number
    equipment_booking_id: number
    equipment_method_id: number
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_booking_methodUpdateManyMutationInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_booking_id?: IntFieldUpdateOperationsInput | number
    equipment_method_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NewsListRelationFilter = {
    every?: newsWhereInput
    some?: newsWhereInput
    none?: newsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type newsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type news_typeCountOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type news_typeAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type news_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type news_typeMinOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type news_typeSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type News_typeRelationFilter = {
    is?: news_typeWhereInput
    isNot?: news_typeWhereInput
  }

  export type newsCountOrderByAggregateInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    news_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_news?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type newsAvgOrderByAggregateInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type newsMaxOrderByAggregateInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    news_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_news?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type newsMinOrderByAggregateInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    news_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_news?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type newsSumOrderByAggregateInput = {
    id?: SortOrder
    news_type_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type bannerCountOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    banner_file?: SortOrder
    banner_url?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_banner?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type bannerAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type bannerMaxOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    banner_file?: SortOrder
    banner_url?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_banner?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type bannerMinOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    banner_file?: SortOrder
    banner_url?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_banner?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type bannerSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type aboutCountOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_about?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type aboutAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type aboutMaxOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_about?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type aboutMinOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_about?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type aboutSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type contactCountOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_contact?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type contactMaxOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_contact?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactMinOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_contact?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type contactSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type TeamListRelationFilter = {
    every?: teamWhereInput
    some?: teamWhereInput
    none?: teamWhereInput
  }

  export type teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type departmentCountOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type departmentAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type departmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type departmentMinOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type departmentSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type DepartmentRelationFilter = {
    is?: departmentWhereInput
    isNot?: departmentWhereInput
  }

  export type teamCountOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    prefix_th?: SortOrder
    prefix_en?: SortOrder
    firstname_th?: SortOrder
    firstname_en?: SortOrder
    surname_th?: SortOrder
    surname_en?: SortOrder
    position_th?: SortOrder
    position_en?: SortOrder
    position_level_th?: SortOrder
    position_level_en?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    level?: SortOrder
    team_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type teamAvgOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    prefix_th?: SortOrder
    prefix_en?: SortOrder
    firstname_th?: SortOrder
    firstname_en?: SortOrder
    surname_th?: SortOrder
    surname_en?: SortOrder
    position_th?: SortOrder
    position_en?: SortOrder
    position_level_th?: SortOrder
    position_level_en?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    level?: SortOrder
    team_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    prefix_th?: SortOrder
    prefix_en?: SortOrder
    firstname_th?: SortOrder
    firstname_en?: SortOrder
    surname_th?: SortOrder
    surname_en?: SortOrder
    position_th?: SortOrder
    position_en?: SortOrder
    position_level_th?: SortOrder
    position_level_en?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    level?: SortOrder
    team_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type teamSumOrderByAggregateInput = {
    id?: SortOrder
    department_id?: SortOrder
    level?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type news_galleryCountOrderByAggregateInput = {
    id?: SortOrder
    news_id?: SortOrder
    secret_key?: SortOrder
    news_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type news_galleryAvgOrderByAggregateInput = {
    id?: SortOrder
    news_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type news_galleryMaxOrderByAggregateInput = {
    id?: SortOrder
    news_id?: SortOrder
    secret_key?: SortOrder
    news_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type news_galleryMinOrderByAggregateInput = {
    id?: SortOrder
    news_id?: SortOrder
    secret_key?: SortOrder
    news_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type news_gallerySumOrderByAggregateInput = {
    id?: SortOrder
    news_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EquipmentListRelationFilter = {
    every?: equipmentWhereInput
    some?: equipmentWhereInput
    none?: equipmentWhereInput
  }

  export type equipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipment_departmentCountOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_departmentAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_departmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_departmentMinOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_departmentSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_categorySumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type Equipment_categoryRelationFilter = {
    is?: equipment_categoryWhereInput
    isNot?: equipment_categoryWhereInput
  }

  export type Equipment_departmentRelationFilter = {
    is?: equipment_departmentWhereInput
    isNot?: equipment_departmentWhereInput
  }

  export type Equipment_methodListRelationFilter = {
    every?: equipment_methodWhereInput
    some?: equipment_methodWhereInput
    none?: equipment_methodWhereInput
  }

  export type Equipment_bookingListRelationFilter = {
    every?: equipment_bookingWhereInput
    some?: equipment_bookingWhereInput
    none?: equipment_bookingWhereInput
  }

  export type equipment_methodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipment_bookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipmentCountOrderByAggregateInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    equipment_file?: SortOrder
    rate_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_equipment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipmentAvgOrderByAggregateInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type equipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    equipment_file?: SortOrder
    rate_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_equipment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipmentMinOrderByAggregateInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    detail_th?: SortOrder
    detail_en?: SortOrder
    equipment_file?: SortOrder
    rate_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
    created_equipment?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipmentSumOrderByAggregateInput = {
    id?: SortOrder
    equipment_category_id?: SortOrder
    equipment_department_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    count_views?: SortOrder
  }

  export type equipment_galleryCountOrderByAggregateInput = {
    id?: SortOrder
    equipment_id?: SortOrder
    secret_key?: SortOrder
    equipment_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_galleryAvgOrderByAggregateInput = {
    id?: SortOrder
    equipment_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_galleryMaxOrderByAggregateInput = {
    id?: SortOrder
    equipment_id?: SortOrder
    secret_key?: SortOrder
    equipment_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_galleryMinOrderByAggregateInput = {
    id?: SortOrder
    equipment_id?: SortOrder
    secret_key?: SortOrder
    equipment_gallery_file?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_gallerySumOrderByAggregateInput = {
    id?: SortOrder
    equipment_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type EquipmentRelationFilter = {
    is?: equipmentWhereInput
    isNot?: equipmentWhereInput
  }

  export type Equipment_booking_methodListRelationFilter = {
    every?: equipment_booking_methodWhereInput
    some?: equipment_booking_methodWhereInput
    none?: equipment_booking_methodWhereInput
  }

  export type equipment_booking_methodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipment_methodCountOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    unit_th?: SortOrder
    unit_en?: SortOrder
    price?: SortOrder
    is_fixrate?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
    equipment_id?: SortOrder
  }

  export type equipment_methodAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    is_fixrate?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    equipment_id?: SortOrder
  }

  export type equipment_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    unit_th?: SortOrder
    unit_en?: SortOrder
    price?: SortOrder
    is_fixrate?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
    equipment_id?: SortOrder
  }

  export type equipment_methodMinOrderByAggregateInput = {
    id?: SortOrder
    name_th?: SortOrder
    name_en?: SortOrder
    name_short?: SortOrder
    unit_th?: SortOrder
    unit_en?: SortOrder
    price?: SortOrder
    is_fixrate?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
    equipment_id?: SortOrder
  }

  export type equipment_methodSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    is_fixrate?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    equipment_id?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: userWhereInput
    some?: userWhereInput
    none?: userWhereInput
  }

  export type userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type groupCountOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type groupAvgOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type groupMaxOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type groupMinOrderByAggregateInput = {
    id?: SortOrder
    title_th?: SortOrder
    title_en?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type groupSumOrderByAggregateInput = {
    id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type GroupRelationFilter = {
    is?: groupWhereInput
    isNot?: groupWhereInput
  }

  export type ProfileNullableRelationFilter = {
    is?: profileWhereInput | null
    isNot?: profileWhereInput | null
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    email?: SortOrder
    secret_confirm_email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type userAvgOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    email?: SortOrder
    secret_confirm_email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    email?: SortOrder
    secret_confirm_email?: SortOrder
    password?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type userSumOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type profileCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    prefix?: SortOrder
    firstname?: SortOrder
    surname?: SortOrder
    member_status?: SortOrder
    organization?: SortOrder
    contact_address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    invoice_name?: SortOrder
    invoice_address?: SortOrder
    tax_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    member_status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    prefix?: SortOrder
    firstname?: SortOrder
    surname?: SortOrder
    member_status?: SortOrder
    organization?: SortOrder
    contact_address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    invoice_name?: SortOrder
    invoice_address?: SortOrder
    tax_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    prefix?: SortOrder
    firstname?: SortOrder
    surname?: SortOrder
    member_status?: SortOrder
    organization?: SortOrder
    contact_address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    invoice_name?: SortOrder
    invoice_address?: SortOrder
    tax_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type profileSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    member_status?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_bookingCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    booking_date?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    example?: SortOrder
    prefix?: SortOrder
    firstname?: SortOrder
    surname?: SortOrder
    organization?: SortOrder
    contact_address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    invoice_address?: SortOrder
    tax_id?: SortOrder
    price?: SortOrder
    reject_comment?: SortOrder
    confirmed_date?: SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_bookingAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    price?: SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_bookingMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    booking_date?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    example?: SortOrder
    prefix?: SortOrder
    firstname?: SortOrder
    surname?: SortOrder
    organization?: SortOrder
    contact_address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    invoice_address?: SortOrder
    tax_id?: SortOrder
    price?: SortOrder
    reject_comment?: SortOrder
    confirmed_date?: SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_bookingMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    booking_date?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    example?: SortOrder
    prefix?: SortOrder
    firstname?: SortOrder
    surname?: SortOrder
    organization?: SortOrder
    contact_address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    invoice_address?: SortOrder
    tax_id?: SortOrder
    price?: SortOrder
    reject_comment?: SortOrder
    confirmed_date?: SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_bookingSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    equipment_id?: SortOrder
    period_time?: SortOrder
    member_status?: SortOrder
    price?: SortOrder
    status_id?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type Equipment_bookingRelationFilter = {
    is?: equipment_bookingWhereInput
    isNot?: equipment_bookingWhereInput
  }

  export type Equipment_methodRelationFilter = {
    is?: equipment_methodWhereInput
    isNot?: equipment_methodWhereInput
  }

  export type equipment_booking_methodCountOrderByAggregateInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_booking_methodAvgOrderByAggregateInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type equipment_booking_methodMaxOrderByAggregateInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_booking_methodMinOrderByAggregateInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    updated_at?: SortOrder
    updated_by?: SortOrder
    deleted_at?: SortOrder
  }

  export type equipment_booking_methodSumOrderByAggregateInput = {
    id?: SortOrder
    equipment_booking_id?: SortOrder
    equipment_method_id?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    is_active?: SortOrder
    is_publish?: SortOrder
  }

  export type newsCreateNestedManyWithoutNews_typeInput = {
    create?: XOR<newsCreateWithoutNews_typeInput, newsUncheckedCreateWithoutNews_typeInput> | newsCreateWithoutNews_typeInput[] | newsUncheckedCreateWithoutNews_typeInput[]
    connectOrCreate?: newsCreateOrConnectWithoutNews_typeInput | newsCreateOrConnectWithoutNews_typeInput[]
    createMany?: newsCreateManyNews_typeInputEnvelope
    connect?: newsWhereUniqueInput | newsWhereUniqueInput[]
  }

  export type newsUncheckedCreateNestedManyWithoutNews_typeInput = {
    create?: XOR<newsCreateWithoutNews_typeInput, newsUncheckedCreateWithoutNews_typeInput> | newsCreateWithoutNews_typeInput[] | newsUncheckedCreateWithoutNews_typeInput[]
    connectOrCreate?: newsCreateOrConnectWithoutNews_typeInput | newsCreateOrConnectWithoutNews_typeInput[]
    createMany?: newsCreateManyNews_typeInputEnvelope
    connect?: newsWhereUniqueInput | newsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type newsUpdateManyWithoutNews_typeNestedInput = {
    create?: XOR<newsCreateWithoutNews_typeInput, newsUncheckedCreateWithoutNews_typeInput> | newsCreateWithoutNews_typeInput[] | newsUncheckedCreateWithoutNews_typeInput[]
    connectOrCreate?: newsCreateOrConnectWithoutNews_typeInput | newsCreateOrConnectWithoutNews_typeInput[]
    upsert?: newsUpsertWithWhereUniqueWithoutNews_typeInput | newsUpsertWithWhereUniqueWithoutNews_typeInput[]
    createMany?: newsCreateManyNews_typeInputEnvelope
    set?: newsWhereUniqueInput | newsWhereUniqueInput[]
    disconnect?: newsWhereUniqueInput | newsWhereUniqueInput[]
    delete?: newsWhereUniqueInput | newsWhereUniqueInput[]
    connect?: newsWhereUniqueInput | newsWhereUniqueInput[]
    update?: newsUpdateWithWhereUniqueWithoutNews_typeInput | newsUpdateWithWhereUniqueWithoutNews_typeInput[]
    updateMany?: newsUpdateManyWithWhereWithoutNews_typeInput | newsUpdateManyWithWhereWithoutNews_typeInput[]
    deleteMany?: newsScalarWhereInput | newsScalarWhereInput[]
  }

  export type newsUncheckedUpdateManyWithoutNews_typeNestedInput = {
    create?: XOR<newsCreateWithoutNews_typeInput, newsUncheckedCreateWithoutNews_typeInput> | newsCreateWithoutNews_typeInput[] | newsUncheckedCreateWithoutNews_typeInput[]
    connectOrCreate?: newsCreateOrConnectWithoutNews_typeInput | newsCreateOrConnectWithoutNews_typeInput[]
    upsert?: newsUpsertWithWhereUniqueWithoutNews_typeInput | newsUpsertWithWhereUniqueWithoutNews_typeInput[]
    createMany?: newsCreateManyNews_typeInputEnvelope
    set?: newsWhereUniqueInput | newsWhereUniqueInput[]
    disconnect?: newsWhereUniqueInput | newsWhereUniqueInput[]
    delete?: newsWhereUniqueInput | newsWhereUniqueInput[]
    connect?: newsWhereUniqueInput | newsWhereUniqueInput[]
    update?: newsUpdateWithWhereUniqueWithoutNews_typeInput | newsUpdateWithWhereUniqueWithoutNews_typeInput[]
    updateMany?: newsUpdateManyWithWhereWithoutNews_typeInput | newsUpdateManyWithWhereWithoutNews_typeInput[]
    deleteMany?: newsScalarWhereInput | newsScalarWhereInput[]
  }

  export type news_typeCreateNestedOneWithoutNewsInput = {
    create?: XOR<news_typeCreateWithoutNewsInput, news_typeUncheckedCreateWithoutNewsInput>
    connectOrCreate?: news_typeCreateOrConnectWithoutNewsInput
    connect?: news_typeWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type news_typeUpdateOneRequiredWithoutNewsNestedInput = {
    create?: XOR<news_typeCreateWithoutNewsInput, news_typeUncheckedCreateWithoutNewsInput>
    connectOrCreate?: news_typeCreateOrConnectWithoutNewsInput
    upsert?: news_typeUpsertWithoutNewsInput
    connect?: news_typeWhereUniqueInput
    update?: XOR<XOR<news_typeUpdateToOneWithWhereWithoutNewsInput, news_typeUpdateWithoutNewsInput>, news_typeUncheckedUpdateWithoutNewsInput>
  }

  export type teamCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<teamCreateWithoutDepartmentInput, teamUncheckedCreateWithoutDepartmentInput> | teamCreateWithoutDepartmentInput[] | teamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDepartmentInput | teamCreateOrConnectWithoutDepartmentInput[]
    createMany?: teamCreateManyDepartmentInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<teamCreateWithoutDepartmentInput, teamUncheckedCreateWithoutDepartmentInput> | teamCreateWithoutDepartmentInput[] | teamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDepartmentInput | teamCreateOrConnectWithoutDepartmentInput[]
    createMany?: teamCreateManyDepartmentInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type teamUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<teamCreateWithoutDepartmentInput, teamUncheckedCreateWithoutDepartmentInput> | teamCreateWithoutDepartmentInput[] | teamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDepartmentInput | teamCreateOrConnectWithoutDepartmentInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutDepartmentInput | teamUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: teamCreateManyDepartmentInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutDepartmentInput | teamUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: teamUpdateManyWithWhereWithoutDepartmentInput | teamUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<teamCreateWithoutDepartmentInput, teamUncheckedCreateWithoutDepartmentInput> | teamCreateWithoutDepartmentInput[] | teamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: teamCreateOrConnectWithoutDepartmentInput | teamCreateOrConnectWithoutDepartmentInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutDepartmentInput | teamUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: teamCreateManyDepartmentInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutDepartmentInput | teamUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: teamUpdateManyWithWhereWithoutDepartmentInput | teamUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type departmentCreateNestedOneWithoutTeamInput = {
    create?: XOR<departmentCreateWithoutTeamInput, departmentUncheckedCreateWithoutTeamInput>
    connectOrCreate?: departmentCreateOrConnectWithoutTeamInput
    connect?: departmentWhereUniqueInput
  }

  export type departmentUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<departmentCreateWithoutTeamInput, departmentUncheckedCreateWithoutTeamInput>
    connectOrCreate?: departmentCreateOrConnectWithoutTeamInput
    upsert?: departmentUpsertWithoutTeamInput
    connect?: departmentWhereUniqueInput
    update?: XOR<XOR<departmentUpdateToOneWithWhereWithoutTeamInput, departmentUpdateWithoutTeamInput>, departmentUncheckedUpdateWithoutTeamInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type equipmentCreateNestedManyWithoutEquipment_departmentInput = {
    create?: XOR<equipmentCreateWithoutEquipment_departmentInput, equipmentUncheckedCreateWithoutEquipment_departmentInput> | equipmentCreateWithoutEquipment_departmentInput[] | equipmentUncheckedCreateWithoutEquipment_departmentInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_departmentInput | equipmentCreateOrConnectWithoutEquipment_departmentInput[]
    createMany?: equipmentCreateManyEquipment_departmentInputEnvelope
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
  }

  export type equipmentUncheckedCreateNestedManyWithoutEquipment_departmentInput = {
    create?: XOR<equipmentCreateWithoutEquipment_departmentInput, equipmentUncheckedCreateWithoutEquipment_departmentInput> | equipmentCreateWithoutEquipment_departmentInput[] | equipmentUncheckedCreateWithoutEquipment_departmentInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_departmentInput | equipmentCreateOrConnectWithoutEquipment_departmentInput[]
    createMany?: equipmentCreateManyEquipment_departmentInputEnvelope
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
  }

  export type equipmentUpdateManyWithoutEquipment_departmentNestedInput = {
    create?: XOR<equipmentCreateWithoutEquipment_departmentInput, equipmentUncheckedCreateWithoutEquipment_departmentInput> | equipmentCreateWithoutEquipment_departmentInput[] | equipmentUncheckedCreateWithoutEquipment_departmentInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_departmentInput | equipmentCreateOrConnectWithoutEquipment_departmentInput[]
    upsert?: equipmentUpsertWithWhereUniqueWithoutEquipment_departmentInput | equipmentUpsertWithWhereUniqueWithoutEquipment_departmentInput[]
    createMany?: equipmentCreateManyEquipment_departmentInputEnvelope
    set?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    disconnect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    delete?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    update?: equipmentUpdateWithWhereUniqueWithoutEquipment_departmentInput | equipmentUpdateWithWhereUniqueWithoutEquipment_departmentInput[]
    updateMany?: equipmentUpdateManyWithWhereWithoutEquipment_departmentInput | equipmentUpdateManyWithWhereWithoutEquipment_departmentInput[]
    deleteMany?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
  }

  export type equipmentUncheckedUpdateManyWithoutEquipment_departmentNestedInput = {
    create?: XOR<equipmentCreateWithoutEquipment_departmentInput, equipmentUncheckedCreateWithoutEquipment_departmentInput> | equipmentCreateWithoutEquipment_departmentInput[] | equipmentUncheckedCreateWithoutEquipment_departmentInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_departmentInput | equipmentCreateOrConnectWithoutEquipment_departmentInput[]
    upsert?: equipmentUpsertWithWhereUniqueWithoutEquipment_departmentInput | equipmentUpsertWithWhereUniqueWithoutEquipment_departmentInput[]
    createMany?: equipmentCreateManyEquipment_departmentInputEnvelope
    set?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    disconnect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    delete?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    update?: equipmentUpdateWithWhereUniqueWithoutEquipment_departmentInput | equipmentUpdateWithWhereUniqueWithoutEquipment_departmentInput[]
    updateMany?: equipmentUpdateManyWithWhereWithoutEquipment_departmentInput | equipmentUpdateManyWithWhereWithoutEquipment_departmentInput[]
    deleteMany?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
  }

  export type equipmentCreateNestedManyWithoutEquipment_categoryInput = {
    create?: XOR<equipmentCreateWithoutEquipment_categoryInput, equipmentUncheckedCreateWithoutEquipment_categoryInput> | equipmentCreateWithoutEquipment_categoryInput[] | equipmentUncheckedCreateWithoutEquipment_categoryInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_categoryInput | equipmentCreateOrConnectWithoutEquipment_categoryInput[]
    createMany?: equipmentCreateManyEquipment_categoryInputEnvelope
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
  }

  export type equipmentUncheckedCreateNestedManyWithoutEquipment_categoryInput = {
    create?: XOR<equipmentCreateWithoutEquipment_categoryInput, equipmentUncheckedCreateWithoutEquipment_categoryInput> | equipmentCreateWithoutEquipment_categoryInput[] | equipmentUncheckedCreateWithoutEquipment_categoryInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_categoryInput | equipmentCreateOrConnectWithoutEquipment_categoryInput[]
    createMany?: equipmentCreateManyEquipment_categoryInputEnvelope
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
  }

  export type equipmentUpdateManyWithoutEquipment_categoryNestedInput = {
    create?: XOR<equipmentCreateWithoutEquipment_categoryInput, equipmentUncheckedCreateWithoutEquipment_categoryInput> | equipmentCreateWithoutEquipment_categoryInput[] | equipmentUncheckedCreateWithoutEquipment_categoryInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_categoryInput | equipmentCreateOrConnectWithoutEquipment_categoryInput[]
    upsert?: equipmentUpsertWithWhereUniqueWithoutEquipment_categoryInput | equipmentUpsertWithWhereUniqueWithoutEquipment_categoryInput[]
    createMany?: equipmentCreateManyEquipment_categoryInputEnvelope
    set?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    disconnect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    delete?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    update?: equipmentUpdateWithWhereUniqueWithoutEquipment_categoryInput | equipmentUpdateWithWhereUniqueWithoutEquipment_categoryInput[]
    updateMany?: equipmentUpdateManyWithWhereWithoutEquipment_categoryInput | equipmentUpdateManyWithWhereWithoutEquipment_categoryInput[]
    deleteMany?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
  }

  export type equipmentUncheckedUpdateManyWithoutEquipment_categoryNestedInput = {
    create?: XOR<equipmentCreateWithoutEquipment_categoryInput, equipmentUncheckedCreateWithoutEquipment_categoryInput> | equipmentCreateWithoutEquipment_categoryInput[] | equipmentUncheckedCreateWithoutEquipment_categoryInput[]
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_categoryInput | equipmentCreateOrConnectWithoutEquipment_categoryInput[]
    upsert?: equipmentUpsertWithWhereUniqueWithoutEquipment_categoryInput | equipmentUpsertWithWhereUniqueWithoutEquipment_categoryInput[]
    createMany?: equipmentCreateManyEquipment_categoryInputEnvelope
    set?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    disconnect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    delete?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    connect?: equipmentWhereUniqueInput | equipmentWhereUniqueInput[]
    update?: equipmentUpdateWithWhereUniqueWithoutEquipment_categoryInput | equipmentUpdateWithWhereUniqueWithoutEquipment_categoryInput[]
    updateMany?: equipmentUpdateManyWithWhereWithoutEquipment_categoryInput | equipmentUpdateManyWithWhereWithoutEquipment_categoryInput[]
    deleteMany?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
  }

  export type equipment_categoryCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<equipment_categoryCreateWithoutEquipmentsInput, equipment_categoryUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: equipment_categoryCreateOrConnectWithoutEquipmentsInput
    connect?: equipment_categoryWhereUniqueInput
  }

  export type equipment_departmentCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<equipment_departmentCreateWithoutEquipmentsInput, equipment_departmentUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: equipment_departmentCreateOrConnectWithoutEquipmentsInput
    connect?: equipment_departmentWhereUniqueInput
  }

  export type equipment_methodCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<equipment_methodCreateWithoutEquipmentInput, equipment_methodUncheckedCreateWithoutEquipmentInput> | equipment_methodCreateWithoutEquipmentInput[] | equipment_methodUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_methodCreateOrConnectWithoutEquipmentInput | equipment_methodCreateOrConnectWithoutEquipmentInput[]
    createMany?: equipment_methodCreateManyEquipmentInputEnvelope
    connect?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
  }

  export type equipment_bookingCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<equipment_bookingCreateWithoutEquipmentInput, equipment_bookingUncheckedCreateWithoutEquipmentInput> | equipment_bookingCreateWithoutEquipmentInput[] | equipment_bookingUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutEquipmentInput | equipment_bookingCreateOrConnectWithoutEquipmentInput[]
    createMany?: equipment_bookingCreateManyEquipmentInputEnvelope
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
  }

  export type equipment_methodUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<equipment_methodCreateWithoutEquipmentInput, equipment_methodUncheckedCreateWithoutEquipmentInput> | equipment_methodCreateWithoutEquipmentInput[] | equipment_methodUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_methodCreateOrConnectWithoutEquipmentInput | equipment_methodCreateOrConnectWithoutEquipmentInput[]
    createMany?: equipment_methodCreateManyEquipmentInputEnvelope
    connect?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
  }

  export type equipment_bookingUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<equipment_bookingCreateWithoutEquipmentInput, equipment_bookingUncheckedCreateWithoutEquipmentInput> | equipment_bookingCreateWithoutEquipmentInput[] | equipment_bookingUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutEquipmentInput | equipment_bookingCreateOrConnectWithoutEquipmentInput[]
    createMany?: equipment_bookingCreateManyEquipmentInputEnvelope
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
  }

  export type equipment_categoryUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<equipment_categoryCreateWithoutEquipmentsInput, equipment_categoryUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: equipment_categoryCreateOrConnectWithoutEquipmentsInput
    upsert?: equipment_categoryUpsertWithoutEquipmentsInput
    connect?: equipment_categoryWhereUniqueInput
    update?: XOR<XOR<equipment_categoryUpdateToOneWithWhereWithoutEquipmentsInput, equipment_categoryUpdateWithoutEquipmentsInput>, equipment_categoryUncheckedUpdateWithoutEquipmentsInput>
  }

  export type equipment_departmentUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<equipment_departmentCreateWithoutEquipmentsInput, equipment_departmentUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: equipment_departmentCreateOrConnectWithoutEquipmentsInput
    upsert?: equipment_departmentUpsertWithoutEquipmentsInput
    connect?: equipment_departmentWhereUniqueInput
    update?: XOR<XOR<equipment_departmentUpdateToOneWithWhereWithoutEquipmentsInput, equipment_departmentUpdateWithoutEquipmentsInput>, equipment_departmentUncheckedUpdateWithoutEquipmentsInput>
  }

  export type equipment_methodUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<equipment_methodCreateWithoutEquipmentInput, equipment_methodUncheckedCreateWithoutEquipmentInput> | equipment_methodCreateWithoutEquipmentInput[] | equipment_methodUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_methodCreateOrConnectWithoutEquipmentInput | equipment_methodCreateOrConnectWithoutEquipmentInput[]
    upsert?: equipment_methodUpsertWithWhereUniqueWithoutEquipmentInput | equipment_methodUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: equipment_methodCreateManyEquipmentInputEnvelope
    set?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    disconnect?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    delete?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    connect?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    update?: equipment_methodUpdateWithWhereUniqueWithoutEquipmentInput | equipment_methodUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: equipment_methodUpdateManyWithWhereWithoutEquipmentInput | equipment_methodUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: equipment_methodScalarWhereInput | equipment_methodScalarWhereInput[]
  }

  export type equipment_bookingUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<equipment_bookingCreateWithoutEquipmentInput, equipment_bookingUncheckedCreateWithoutEquipmentInput> | equipment_bookingCreateWithoutEquipmentInput[] | equipment_bookingUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutEquipmentInput | equipment_bookingCreateOrConnectWithoutEquipmentInput[]
    upsert?: equipment_bookingUpsertWithWhereUniqueWithoutEquipmentInput | equipment_bookingUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: equipment_bookingCreateManyEquipmentInputEnvelope
    set?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    disconnect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    delete?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    update?: equipment_bookingUpdateWithWhereUniqueWithoutEquipmentInput | equipment_bookingUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: equipment_bookingUpdateManyWithWhereWithoutEquipmentInput | equipment_bookingUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: equipment_bookingScalarWhereInput | equipment_bookingScalarWhereInput[]
  }

  export type equipment_methodUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<equipment_methodCreateWithoutEquipmentInput, equipment_methodUncheckedCreateWithoutEquipmentInput> | equipment_methodCreateWithoutEquipmentInput[] | equipment_methodUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_methodCreateOrConnectWithoutEquipmentInput | equipment_methodCreateOrConnectWithoutEquipmentInput[]
    upsert?: equipment_methodUpsertWithWhereUniqueWithoutEquipmentInput | equipment_methodUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: equipment_methodCreateManyEquipmentInputEnvelope
    set?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    disconnect?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    delete?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    connect?: equipment_methodWhereUniqueInput | equipment_methodWhereUniqueInput[]
    update?: equipment_methodUpdateWithWhereUniqueWithoutEquipmentInput | equipment_methodUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: equipment_methodUpdateManyWithWhereWithoutEquipmentInput | equipment_methodUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: equipment_methodScalarWhereInput | equipment_methodScalarWhereInput[]
  }

  export type equipment_bookingUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<equipment_bookingCreateWithoutEquipmentInput, equipment_bookingUncheckedCreateWithoutEquipmentInput> | equipment_bookingCreateWithoutEquipmentInput[] | equipment_bookingUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutEquipmentInput | equipment_bookingCreateOrConnectWithoutEquipmentInput[]
    upsert?: equipment_bookingUpsertWithWhereUniqueWithoutEquipmentInput | equipment_bookingUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: equipment_bookingCreateManyEquipmentInputEnvelope
    set?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    disconnect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    delete?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    update?: equipment_bookingUpdateWithWhereUniqueWithoutEquipmentInput | equipment_bookingUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: equipment_bookingUpdateManyWithWhereWithoutEquipmentInput | equipment_bookingUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: equipment_bookingScalarWhereInput | equipment_bookingScalarWhereInput[]
  }

  export type equipmentCreateNestedOneWithoutEquipment_methodInput = {
    create?: XOR<equipmentCreateWithoutEquipment_methodInput, equipmentUncheckedCreateWithoutEquipment_methodInput>
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_methodInput
    connect?: equipmentWhereUniqueInput
  }

  export type equipment_booking_methodCreateNestedManyWithoutEquipment_methodInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_methodInput, equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput> | equipment_booking_methodCreateWithoutEquipment_methodInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput | equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_methodInputEnvelope
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
  }

  export type equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_methodInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_methodInput, equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput> | equipment_booking_methodCreateWithoutEquipment_methodInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput | equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_methodInputEnvelope
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
  }

  export type equipmentUpdateOneRequiredWithoutEquipment_methodNestedInput = {
    create?: XOR<equipmentCreateWithoutEquipment_methodInput, equipmentUncheckedCreateWithoutEquipment_methodInput>
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_methodInput
    upsert?: equipmentUpsertWithoutEquipment_methodInput
    connect?: equipmentWhereUniqueInput
    update?: XOR<XOR<equipmentUpdateToOneWithWhereWithoutEquipment_methodInput, equipmentUpdateWithoutEquipment_methodInput>, equipmentUncheckedUpdateWithoutEquipment_methodInput>
  }

  export type equipment_booking_methodUpdateManyWithoutEquipment_methodNestedInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_methodInput, equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput> | equipment_booking_methodCreateWithoutEquipment_methodInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput | equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput[]
    upsert?: equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_methodInput | equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_methodInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_methodInputEnvelope
    set?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    disconnect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    delete?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    update?: equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_methodInput | equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_methodInput[]
    updateMany?: equipment_booking_methodUpdateManyWithWhereWithoutEquipment_methodInput | equipment_booking_methodUpdateManyWithWhereWithoutEquipment_methodInput[]
    deleteMany?: equipment_booking_methodScalarWhereInput | equipment_booking_methodScalarWhereInput[]
  }

  export type equipment_booking_methodUncheckedUpdateManyWithoutEquipment_methodNestedInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_methodInput, equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput> | equipment_booking_methodCreateWithoutEquipment_methodInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput | equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput[]
    upsert?: equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_methodInput | equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_methodInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_methodInputEnvelope
    set?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    disconnect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    delete?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    update?: equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_methodInput | equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_methodInput[]
    updateMany?: equipment_booking_methodUpdateManyWithWhereWithoutEquipment_methodInput | equipment_booking_methodUpdateManyWithWhereWithoutEquipment_methodInput[]
    deleteMany?: equipment_booking_methodScalarWhereInput | equipment_booking_methodScalarWhereInput[]
  }

  export type userCreateNestedManyWithoutGroupInput = {
    create?: XOR<userCreateWithoutGroupInput, userUncheckedCreateWithoutGroupInput> | userCreateWithoutGroupInput[] | userUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userCreateOrConnectWithoutGroupInput | userCreateOrConnectWithoutGroupInput[]
    createMany?: userCreateManyGroupInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<userCreateWithoutGroupInput, userUncheckedCreateWithoutGroupInput> | userCreateWithoutGroupInput[] | userUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userCreateOrConnectWithoutGroupInput | userCreateOrConnectWithoutGroupInput[]
    createMany?: userCreateManyGroupInputEnvelope
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
  }

  export type userUpdateManyWithoutGroupNestedInput = {
    create?: XOR<userCreateWithoutGroupInput, userUncheckedCreateWithoutGroupInput> | userCreateWithoutGroupInput[] | userUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userCreateOrConnectWithoutGroupInput | userCreateOrConnectWithoutGroupInput[]
    upsert?: userUpsertWithWhereUniqueWithoutGroupInput | userUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: userCreateManyGroupInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutGroupInput | userUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: userUpdateManyWithWhereWithoutGroupInput | userUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type userUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<userCreateWithoutGroupInput, userUncheckedCreateWithoutGroupInput> | userCreateWithoutGroupInput[] | userUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: userCreateOrConnectWithoutGroupInput | userCreateOrConnectWithoutGroupInput[]
    upsert?: userUpsertWithWhereUniqueWithoutGroupInput | userUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: userCreateManyGroupInputEnvelope
    set?: userWhereUniqueInput | userWhereUniqueInput[]
    disconnect?: userWhereUniqueInput | userWhereUniqueInput[]
    delete?: userWhereUniqueInput | userWhereUniqueInput[]
    connect?: userWhereUniqueInput | userWhereUniqueInput[]
    update?: userUpdateWithWhereUniqueWithoutGroupInput | userUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: userUpdateManyWithWhereWithoutGroupInput | userUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: userScalarWhereInput | userScalarWhereInput[]
  }

  export type groupCreateNestedOneWithoutUsersInput = {
    create?: XOR<groupCreateWithoutUsersInput, groupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: groupCreateOrConnectWithoutUsersInput
    connect?: groupWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type equipment_bookingCreateNestedManyWithoutUserInput = {
    create?: XOR<equipment_bookingCreateWithoutUserInput, equipment_bookingUncheckedCreateWithoutUserInput> | equipment_bookingCreateWithoutUserInput[] | equipment_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutUserInput | equipment_bookingCreateOrConnectWithoutUserInput[]
    createMany?: equipment_bookingCreateManyUserInputEnvelope
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
  }

  export type profileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type equipment_bookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<equipment_bookingCreateWithoutUserInput, equipment_bookingUncheckedCreateWithoutUserInput> | equipment_bookingCreateWithoutUserInput[] | equipment_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutUserInput | equipment_bookingCreateOrConnectWithoutUserInput[]
    createMany?: equipment_bookingCreateManyUserInputEnvelope
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
  }

  export type groupUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<groupCreateWithoutUsersInput, groupUncheckedCreateWithoutUsersInput>
    connectOrCreate?: groupCreateOrConnectWithoutUsersInput
    upsert?: groupUpsertWithoutUsersInput
    connect?: groupWhereUniqueInput
    update?: XOR<XOR<groupUpdateToOneWithWhereWithoutUsersInput, groupUpdateWithoutUsersInput>, groupUncheckedUpdateWithoutUsersInput>
  }

  export type profileUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type equipment_bookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<equipment_bookingCreateWithoutUserInput, equipment_bookingUncheckedCreateWithoutUserInput> | equipment_bookingCreateWithoutUserInput[] | equipment_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutUserInput | equipment_bookingCreateOrConnectWithoutUserInput[]
    upsert?: equipment_bookingUpsertWithWhereUniqueWithoutUserInput | equipment_bookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: equipment_bookingCreateManyUserInputEnvelope
    set?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    disconnect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    delete?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    update?: equipment_bookingUpdateWithWhereUniqueWithoutUserInput | equipment_bookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: equipment_bookingUpdateManyWithWhereWithoutUserInput | equipment_bookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: equipment_bookingScalarWhereInput | equipment_bookingScalarWhereInput[]
  }

  export type profileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: profileWhereInput | boolean
    delete?: profileWhereInput | boolean
    connect?: profileWhereUniqueInput
    update?: XOR<XOR<profileUpdateToOneWithWhereWithoutUserInput, profileUpdateWithoutUserInput>, profileUncheckedUpdateWithoutUserInput>
  }

  export type equipment_bookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<equipment_bookingCreateWithoutUserInput, equipment_bookingUncheckedCreateWithoutUserInput> | equipment_bookingCreateWithoutUserInput[] | equipment_bookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutUserInput | equipment_bookingCreateOrConnectWithoutUserInput[]
    upsert?: equipment_bookingUpsertWithWhereUniqueWithoutUserInput | equipment_bookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: equipment_bookingCreateManyUserInputEnvelope
    set?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    disconnect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    delete?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    connect?: equipment_bookingWhereUniqueInput | equipment_bookingWhereUniqueInput[]
    update?: equipment_bookingUpdateWithWhereUniqueWithoutUserInput | equipment_bookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: equipment_bookingUpdateManyWithWhereWithoutUserInput | equipment_bookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: equipment_bookingScalarWhereInput | equipment_bookingScalarWhereInput[]
  }

  export type userCreateNestedOneWithoutProfileInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    upsert?: userUpsertWithoutProfileInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutProfileInput, userUpdateWithoutProfileInput>, userUncheckedUpdateWithoutProfileInput>
  }

  export type userCreateNestedOneWithoutEquipment_bookingInput = {
    create?: XOR<userCreateWithoutEquipment_bookingInput, userUncheckedCreateWithoutEquipment_bookingInput>
    connectOrCreate?: userCreateOrConnectWithoutEquipment_bookingInput
    connect?: userWhereUniqueInput
  }

  export type equipmentCreateNestedOneWithoutEquipment_bookingInput = {
    create?: XOR<equipmentCreateWithoutEquipment_bookingInput, equipmentUncheckedCreateWithoutEquipment_bookingInput>
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_bookingInput
    connect?: equipmentWhereUniqueInput
  }

  export type equipment_booking_methodCreateNestedManyWithoutEquipment_bookingInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput> | equipment_booking_methodCreateWithoutEquipment_bookingInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput | equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_bookingInputEnvelope
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
  }

  export type equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_bookingInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput> | equipment_booking_methodCreateWithoutEquipment_bookingInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput | equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_bookingInputEnvelope
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
  }

  export type userUpdateOneRequiredWithoutEquipment_bookingNestedInput = {
    create?: XOR<userCreateWithoutEquipment_bookingInput, userUncheckedCreateWithoutEquipment_bookingInput>
    connectOrCreate?: userCreateOrConnectWithoutEquipment_bookingInput
    upsert?: userUpsertWithoutEquipment_bookingInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutEquipment_bookingInput, userUpdateWithoutEquipment_bookingInput>, userUncheckedUpdateWithoutEquipment_bookingInput>
  }

  export type equipmentUpdateOneRequiredWithoutEquipment_bookingNestedInput = {
    create?: XOR<equipmentCreateWithoutEquipment_bookingInput, equipmentUncheckedCreateWithoutEquipment_bookingInput>
    connectOrCreate?: equipmentCreateOrConnectWithoutEquipment_bookingInput
    upsert?: equipmentUpsertWithoutEquipment_bookingInput
    connect?: equipmentWhereUniqueInput
    update?: XOR<XOR<equipmentUpdateToOneWithWhereWithoutEquipment_bookingInput, equipmentUpdateWithoutEquipment_bookingInput>, equipmentUncheckedUpdateWithoutEquipment_bookingInput>
  }

  export type equipment_booking_methodUpdateManyWithoutEquipment_bookingNestedInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput> | equipment_booking_methodCreateWithoutEquipment_bookingInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput | equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput[]
    upsert?: equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_bookingInput | equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_bookingInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_bookingInputEnvelope
    set?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    disconnect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    delete?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    update?: equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_bookingInput | equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_bookingInput[]
    updateMany?: equipment_booking_methodUpdateManyWithWhereWithoutEquipment_bookingInput | equipment_booking_methodUpdateManyWithWhereWithoutEquipment_bookingInput[]
    deleteMany?: equipment_booking_methodScalarWhereInput | equipment_booking_methodScalarWhereInput[]
  }

  export type equipment_booking_methodUncheckedUpdateManyWithoutEquipment_bookingNestedInput = {
    create?: XOR<equipment_booking_methodCreateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput> | equipment_booking_methodCreateWithoutEquipment_bookingInput[] | equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput[]
    connectOrCreate?: equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput | equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput[]
    upsert?: equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_bookingInput | equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_bookingInput[]
    createMany?: equipment_booking_methodCreateManyEquipment_bookingInputEnvelope
    set?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    disconnect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    delete?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    connect?: equipment_booking_methodWhereUniqueInput | equipment_booking_methodWhereUniqueInput[]
    update?: equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_bookingInput | equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_bookingInput[]
    updateMany?: equipment_booking_methodUpdateManyWithWhereWithoutEquipment_bookingInput | equipment_booking_methodUpdateManyWithWhereWithoutEquipment_bookingInput[]
    deleteMany?: equipment_booking_methodScalarWhereInput | equipment_booking_methodScalarWhereInput[]
  }

  export type equipment_bookingCreateNestedOneWithoutEquipment_booking_methodInput = {
    create?: XOR<equipment_bookingCreateWithoutEquipment_booking_methodInput, equipment_bookingUncheckedCreateWithoutEquipment_booking_methodInput>
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutEquipment_booking_methodInput
    connect?: equipment_bookingWhereUniqueInput
  }

  export type equipment_methodCreateNestedOneWithoutEquipment_booking_methodInput = {
    create?: XOR<equipment_methodCreateWithoutEquipment_booking_methodInput, equipment_methodUncheckedCreateWithoutEquipment_booking_methodInput>
    connectOrCreate?: equipment_methodCreateOrConnectWithoutEquipment_booking_methodInput
    connect?: equipment_methodWhereUniqueInput
  }

  export type equipment_bookingUpdateOneRequiredWithoutEquipment_booking_methodNestedInput = {
    create?: XOR<equipment_bookingCreateWithoutEquipment_booking_methodInput, equipment_bookingUncheckedCreateWithoutEquipment_booking_methodInput>
    connectOrCreate?: equipment_bookingCreateOrConnectWithoutEquipment_booking_methodInput
    upsert?: equipment_bookingUpsertWithoutEquipment_booking_methodInput
    connect?: equipment_bookingWhereUniqueInput
    update?: XOR<XOR<equipment_bookingUpdateToOneWithWhereWithoutEquipment_booking_methodInput, equipment_bookingUpdateWithoutEquipment_booking_methodInput>, equipment_bookingUncheckedUpdateWithoutEquipment_booking_methodInput>
  }

  export type equipment_methodUpdateOneRequiredWithoutEquipment_booking_methodNestedInput = {
    create?: XOR<equipment_methodCreateWithoutEquipment_booking_methodInput, equipment_methodUncheckedCreateWithoutEquipment_booking_methodInput>
    connectOrCreate?: equipment_methodCreateOrConnectWithoutEquipment_booking_methodInput
    upsert?: equipment_methodUpsertWithoutEquipment_booking_methodInput
    connect?: equipment_methodWhereUniqueInput
    update?: XOR<XOR<equipment_methodUpdateToOneWithWhereWithoutEquipment_booking_methodInput, equipment_methodUpdateWithoutEquipment_booking_methodInput>, equipment_methodUncheckedUpdateWithoutEquipment_booking_methodInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type newsCreateWithoutNews_typeInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    news_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_news: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type newsUncheckedCreateWithoutNews_typeInput = {
    id?: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    news_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_news: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type newsCreateOrConnectWithoutNews_typeInput = {
    where: newsWhereUniqueInput
    create: XOR<newsCreateWithoutNews_typeInput, newsUncheckedCreateWithoutNews_typeInput>
  }

  export type newsCreateManyNews_typeInputEnvelope = {
    data: newsCreateManyNews_typeInput | newsCreateManyNews_typeInput[]
    skipDuplicates?: boolean
  }

  export type newsUpsertWithWhereUniqueWithoutNews_typeInput = {
    where: newsWhereUniqueInput
    update: XOR<newsUpdateWithoutNews_typeInput, newsUncheckedUpdateWithoutNews_typeInput>
    create: XOR<newsCreateWithoutNews_typeInput, newsUncheckedCreateWithoutNews_typeInput>
  }

  export type newsUpdateWithWhereUniqueWithoutNews_typeInput = {
    where: newsWhereUniqueInput
    data: XOR<newsUpdateWithoutNews_typeInput, newsUncheckedUpdateWithoutNews_typeInput>
  }

  export type newsUpdateManyWithWhereWithoutNews_typeInput = {
    where: newsScalarWhereInput
    data: XOR<newsUpdateManyMutationInput, newsUncheckedUpdateManyWithoutNews_typeInput>
  }

  export type newsScalarWhereInput = {
    AND?: newsScalarWhereInput | newsScalarWhereInput[]
    OR?: newsScalarWhereInput[]
    NOT?: newsScalarWhereInput | newsScalarWhereInput[]
    id?: IntFilter<"news"> | number
    news_type_id?: IntFilter<"news"> | number
    title_th?: StringFilter<"news"> | string
    title_en?: StringNullableFilter<"news"> | string | null
    detail_th?: StringNullableFilter<"news"> | string | null
    detail_en?: StringNullableFilter<"news"> | string | null
    news_file?: StringNullableFilter<"news"> | string | null
    is_active?: IntFilter<"news"> | number
    is_publish?: IntFilter<"news"> | number
    count_views?: IntFilter<"news"> | number
    created_news?: DateTimeFilter<"news"> | Date | string
    created_at?: DateTimeNullableFilter<"news"> | Date | string | null
    created_by?: StringNullableFilter<"news"> | string | null
    updated_at?: DateTimeNullableFilter<"news"> | Date | string | null
    updated_by?: StringNullableFilter<"news"> | string | null
    deleted_at?: DateTimeNullableFilter<"news"> | Date | string | null
  }

  export type news_typeCreateWithoutNewsInput = {
    name_th: string
    name_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type news_typeUncheckedCreateWithoutNewsInput = {
    id?: number
    name_th: string
    name_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type news_typeCreateOrConnectWithoutNewsInput = {
    where: news_typeWhereUniqueInput
    create: XOR<news_typeCreateWithoutNewsInput, news_typeUncheckedCreateWithoutNewsInput>
  }

  export type news_typeUpsertWithoutNewsInput = {
    update: XOR<news_typeUpdateWithoutNewsInput, news_typeUncheckedUpdateWithoutNewsInput>
    create: XOR<news_typeCreateWithoutNewsInput, news_typeUncheckedCreateWithoutNewsInput>
    where?: news_typeWhereInput
  }

  export type news_typeUpdateToOneWithWhereWithoutNewsInput = {
    where?: news_typeWhereInput
    data: XOR<news_typeUpdateWithoutNewsInput, news_typeUncheckedUpdateWithoutNewsInput>
  }

  export type news_typeUpdateWithoutNewsInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type news_typeUncheckedUpdateWithoutNewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamCreateWithoutDepartmentInput = {
    prefix_th?: string | null
    prefix_en?: string | null
    firstname_th?: string | null
    firstname_en?: string | null
    surname_th?: string | null
    surname_en?: string | null
    position_th?: string | null
    position_en?: string | null
    position_level_th?: string | null
    position_level_en?: string | null
    phone: string
    email: string
    level: number
    team_file?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type teamUncheckedCreateWithoutDepartmentInput = {
    id?: number
    prefix_th?: string | null
    prefix_en?: string | null
    firstname_th?: string | null
    firstname_en?: string | null
    surname_th?: string | null
    surname_en?: string | null
    position_th?: string | null
    position_en?: string | null
    position_level_th?: string | null
    position_level_en?: string | null
    phone: string
    email: string
    level: number
    team_file?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type teamCreateOrConnectWithoutDepartmentInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutDepartmentInput, teamUncheckedCreateWithoutDepartmentInput>
  }

  export type teamCreateManyDepartmentInputEnvelope = {
    data: teamCreateManyDepartmentInput | teamCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type teamUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutDepartmentInput, teamUncheckedUpdateWithoutDepartmentInput>
    create: XOR<teamCreateWithoutDepartmentInput, teamUncheckedCreateWithoutDepartmentInput>
  }

  export type teamUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutDepartmentInput, teamUncheckedUpdateWithoutDepartmentInput>
  }

  export type teamUpdateManyWithWhereWithoutDepartmentInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type teamScalarWhereInput = {
    AND?: teamScalarWhereInput | teamScalarWhereInput[]
    OR?: teamScalarWhereInput[]
    NOT?: teamScalarWhereInput | teamScalarWhereInput[]
    id?: IntFilter<"team"> | number
    department_id?: IntFilter<"team"> | number
    prefix_th?: StringNullableFilter<"team"> | string | null
    prefix_en?: StringNullableFilter<"team"> | string | null
    firstname_th?: StringNullableFilter<"team"> | string | null
    firstname_en?: StringNullableFilter<"team"> | string | null
    surname_th?: StringNullableFilter<"team"> | string | null
    surname_en?: StringNullableFilter<"team"> | string | null
    position_th?: StringNullableFilter<"team"> | string | null
    position_en?: StringNullableFilter<"team"> | string | null
    position_level_th?: StringNullableFilter<"team"> | string | null
    position_level_en?: StringNullableFilter<"team"> | string | null
    phone?: StringFilter<"team"> | string
    email?: StringFilter<"team"> | string
    level?: IntFilter<"team"> | number
    team_file?: StringNullableFilter<"team"> | string | null
    is_active?: IntFilter<"team"> | number
    is_publish?: IntFilter<"team"> | number
    created_at?: DateTimeNullableFilter<"team"> | Date | string | null
    created_by?: StringNullableFilter<"team"> | string | null
    updated_at?: DateTimeNullableFilter<"team"> | Date | string | null
    updated_by?: StringNullableFilter<"team"> | string | null
    deleted_at?: DateTimeNullableFilter<"team"> | Date | string | null
  }

  export type departmentCreateWithoutTeamInput = {
    name_th: string
    name_en?: string | null
    level: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type departmentUncheckedCreateWithoutTeamInput = {
    id?: number
    name_th: string
    name_en?: string | null
    level: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type departmentCreateOrConnectWithoutTeamInput = {
    where: departmentWhereUniqueInput
    create: XOR<departmentCreateWithoutTeamInput, departmentUncheckedCreateWithoutTeamInput>
  }

  export type departmentUpsertWithoutTeamInput = {
    update: XOR<departmentUpdateWithoutTeamInput, departmentUncheckedUpdateWithoutTeamInput>
    create: XOR<departmentCreateWithoutTeamInput, departmentUncheckedCreateWithoutTeamInput>
    where?: departmentWhereInput
  }

  export type departmentUpdateToOneWithWhereWithoutTeamInput = {
    where?: departmentWhereInput
    data: XOR<departmentUpdateWithoutTeamInput, departmentUncheckedUpdateWithoutTeamInput>
  }

  export type departmentUpdateWithoutTeamInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type departmentUncheckedUpdateWithoutTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    level?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipmentCreateWithoutEquipment_departmentInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_category: equipment_categoryCreateNestedOneWithoutEquipmentsInput
    equipment_method?: equipment_methodCreateNestedManyWithoutEquipmentInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUncheckedCreateWithoutEquipment_departmentInput = {
    id?: number
    equipment_category_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_method?: equipment_methodUncheckedCreateNestedManyWithoutEquipmentInput
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentCreateOrConnectWithoutEquipment_departmentInput = {
    where: equipmentWhereUniqueInput
    create: XOR<equipmentCreateWithoutEquipment_departmentInput, equipmentUncheckedCreateWithoutEquipment_departmentInput>
  }

  export type equipmentCreateManyEquipment_departmentInputEnvelope = {
    data: equipmentCreateManyEquipment_departmentInput | equipmentCreateManyEquipment_departmentInput[]
    skipDuplicates?: boolean
  }

  export type equipmentUpsertWithWhereUniqueWithoutEquipment_departmentInput = {
    where: equipmentWhereUniqueInput
    update: XOR<equipmentUpdateWithoutEquipment_departmentInput, equipmentUncheckedUpdateWithoutEquipment_departmentInput>
    create: XOR<equipmentCreateWithoutEquipment_departmentInput, equipmentUncheckedCreateWithoutEquipment_departmentInput>
  }

  export type equipmentUpdateWithWhereUniqueWithoutEquipment_departmentInput = {
    where: equipmentWhereUniqueInput
    data: XOR<equipmentUpdateWithoutEquipment_departmentInput, equipmentUncheckedUpdateWithoutEquipment_departmentInput>
  }

  export type equipmentUpdateManyWithWhereWithoutEquipment_departmentInput = {
    where: equipmentScalarWhereInput
    data: XOR<equipmentUpdateManyMutationInput, equipmentUncheckedUpdateManyWithoutEquipment_departmentInput>
  }

  export type equipmentScalarWhereInput = {
    AND?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
    OR?: equipmentScalarWhereInput[]
    NOT?: equipmentScalarWhereInput | equipmentScalarWhereInput[]
    id?: IntFilter<"equipment"> | number
    equipment_category_id?: IntFilter<"equipment"> | number
    equipment_department_id?: IntFilter<"equipment"> | number
    title_th?: StringFilter<"equipment"> | string
    title_en?: StringNullableFilter<"equipment"> | string | null
    detail_th?: StringNullableFilter<"equipment"> | string | null
    detail_en?: StringNullableFilter<"equipment"> | string | null
    equipment_file?: StringNullableFilter<"equipment"> | string | null
    rate_file?: StringNullableFilter<"equipment"> | string | null
    is_active?: IntFilter<"equipment"> | number
    is_publish?: IntFilter<"equipment"> | number
    count_views?: IntFilter<"equipment"> | number
    created_equipment?: DateTimeFilter<"equipment"> | Date | string
    created_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    created_by?: StringNullableFilter<"equipment"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment"> | Date | string | null
  }

  export type equipmentCreateWithoutEquipment_categoryInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_department: equipment_departmentCreateNestedOneWithoutEquipmentsInput
    equipment_method?: equipment_methodCreateNestedManyWithoutEquipmentInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUncheckedCreateWithoutEquipment_categoryInput = {
    id?: number
    equipment_department_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_method?: equipment_methodUncheckedCreateNestedManyWithoutEquipmentInput
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentCreateOrConnectWithoutEquipment_categoryInput = {
    where: equipmentWhereUniqueInput
    create: XOR<equipmentCreateWithoutEquipment_categoryInput, equipmentUncheckedCreateWithoutEquipment_categoryInput>
  }

  export type equipmentCreateManyEquipment_categoryInputEnvelope = {
    data: equipmentCreateManyEquipment_categoryInput | equipmentCreateManyEquipment_categoryInput[]
    skipDuplicates?: boolean
  }

  export type equipmentUpsertWithWhereUniqueWithoutEquipment_categoryInput = {
    where: equipmentWhereUniqueInput
    update: XOR<equipmentUpdateWithoutEquipment_categoryInput, equipmentUncheckedUpdateWithoutEquipment_categoryInput>
    create: XOR<equipmentCreateWithoutEquipment_categoryInput, equipmentUncheckedCreateWithoutEquipment_categoryInput>
  }

  export type equipmentUpdateWithWhereUniqueWithoutEquipment_categoryInput = {
    where: equipmentWhereUniqueInput
    data: XOR<equipmentUpdateWithoutEquipment_categoryInput, equipmentUncheckedUpdateWithoutEquipment_categoryInput>
  }

  export type equipmentUpdateManyWithWhereWithoutEquipment_categoryInput = {
    where: equipmentScalarWhereInput
    data: XOR<equipmentUpdateManyMutationInput, equipmentUncheckedUpdateManyWithoutEquipment_categoryInput>
  }

  export type equipment_categoryCreateWithoutEquipmentsInput = {
    name_th: string
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_categoryUncheckedCreateWithoutEquipmentsInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_categoryCreateOrConnectWithoutEquipmentsInput = {
    where: equipment_categoryWhereUniqueInput
    create: XOR<equipment_categoryCreateWithoutEquipmentsInput, equipment_categoryUncheckedCreateWithoutEquipmentsInput>
  }

  export type equipment_departmentCreateWithoutEquipmentsInput = {
    name_th?: string | null
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_departmentUncheckedCreateWithoutEquipmentsInput = {
    id?: number
    name_th?: string | null
    name_en?: string | null
    name_short?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_departmentCreateOrConnectWithoutEquipmentsInput = {
    where: equipment_departmentWhereUniqueInput
    create: XOR<equipment_departmentCreateWithoutEquipmentsInput, equipment_departmentUncheckedCreateWithoutEquipmentsInput>
  }

  export type equipment_methodCreateWithoutEquipmentInput = {
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking_method?: equipment_booking_methodCreateNestedManyWithoutEquipment_methodInput
  }

  export type equipment_methodUncheckedCreateWithoutEquipmentInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_methodInput
  }

  export type equipment_methodCreateOrConnectWithoutEquipmentInput = {
    where: equipment_methodWhereUniqueInput
    create: XOR<equipment_methodCreateWithoutEquipmentInput, equipment_methodUncheckedCreateWithoutEquipmentInput>
  }

  export type equipment_methodCreateManyEquipmentInputEnvelope = {
    data: equipment_methodCreateManyEquipmentInput | equipment_methodCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type equipment_bookingCreateWithoutEquipmentInput = {
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutEquipment_bookingInput
    equipment_booking_method?: equipment_booking_methodCreateNestedManyWithoutEquipment_bookingInput
  }

  export type equipment_bookingUncheckedCreateWithoutEquipmentInput = {
    id?: number
    user_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_bookingInput
  }

  export type equipment_bookingCreateOrConnectWithoutEquipmentInput = {
    where: equipment_bookingWhereUniqueInput
    create: XOR<equipment_bookingCreateWithoutEquipmentInput, equipment_bookingUncheckedCreateWithoutEquipmentInput>
  }

  export type equipment_bookingCreateManyEquipmentInputEnvelope = {
    data: equipment_bookingCreateManyEquipmentInput | equipment_bookingCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type equipment_categoryUpsertWithoutEquipmentsInput = {
    update: XOR<equipment_categoryUpdateWithoutEquipmentsInput, equipment_categoryUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<equipment_categoryCreateWithoutEquipmentsInput, equipment_categoryUncheckedCreateWithoutEquipmentsInput>
    where?: equipment_categoryWhereInput
  }

  export type equipment_categoryUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: equipment_categoryWhereInput
    data: XOR<equipment_categoryUpdateWithoutEquipmentsInput, equipment_categoryUncheckedUpdateWithoutEquipmentsInput>
  }

  export type equipment_categoryUpdateWithoutEquipmentsInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_categoryUncheckedUpdateWithoutEquipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_departmentUpsertWithoutEquipmentsInput = {
    update: XOR<equipment_departmentUpdateWithoutEquipmentsInput, equipment_departmentUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<equipment_departmentCreateWithoutEquipmentsInput, equipment_departmentUncheckedCreateWithoutEquipmentsInput>
    where?: equipment_departmentWhereInput
  }

  export type equipment_departmentUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: equipment_departmentWhereInput
    data: XOR<equipment_departmentUpdateWithoutEquipmentsInput, equipment_departmentUncheckedUpdateWithoutEquipmentsInput>
  }

  export type equipment_departmentUpdateWithoutEquipmentsInput = {
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_departmentUncheckedUpdateWithoutEquipmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: NullableStringFieldUpdateOperationsInput | string | null
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_methodUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: equipment_methodWhereUniqueInput
    update: XOR<equipment_methodUpdateWithoutEquipmentInput, equipment_methodUncheckedUpdateWithoutEquipmentInput>
    create: XOR<equipment_methodCreateWithoutEquipmentInput, equipment_methodUncheckedCreateWithoutEquipmentInput>
  }

  export type equipment_methodUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: equipment_methodWhereUniqueInput
    data: XOR<equipment_methodUpdateWithoutEquipmentInput, equipment_methodUncheckedUpdateWithoutEquipmentInput>
  }

  export type equipment_methodUpdateManyWithWhereWithoutEquipmentInput = {
    where: equipment_methodScalarWhereInput
    data: XOR<equipment_methodUpdateManyMutationInput, equipment_methodUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type equipment_methodScalarWhereInput = {
    AND?: equipment_methodScalarWhereInput | equipment_methodScalarWhereInput[]
    OR?: equipment_methodScalarWhereInput[]
    NOT?: equipment_methodScalarWhereInput | equipment_methodScalarWhereInput[]
    id?: IntFilter<"equipment_method"> | number
    name_th?: StringFilter<"equipment_method"> | string
    name_en?: StringNullableFilter<"equipment_method"> | string | null
    name_short?: StringNullableFilter<"equipment_method"> | string | null
    unit_th?: StringNullableFilter<"equipment_method"> | string | null
    unit_en?: StringNullableFilter<"equipment_method"> | string | null
    price?: IntNullableFilter<"equipment_method"> | number | null
    is_fixrate?: IntNullableFilter<"equipment_method"> | number | null
    is_active?: IntFilter<"equipment_method"> | number
    is_publish?: IntFilter<"equipment_method"> | number
    created_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_method"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_method"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_method"> | Date | string | null
    equipment_id?: IntFilter<"equipment_method"> | number
  }

  export type equipment_bookingUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: equipment_bookingWhereUniqueInput
    update: XOR<equipment_bookingUpdateWithoutEquipmentInput, equipment_bookingUncheckedUpdateWithoutEquipmentInput>
    create: XOR<equipment_bookingCreateWithoutEquipmentInput, equipment_bookingUncheckedCreateWithoutEquipmentInput>
  }

  export type equipment_bookingUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: equipment_bookingWhereUniqueInput
    data: XOR<equipment_bookingUpdateWithoutEquipmentInput, equipment_bookingUncheckedUpdateWithoutEquipmentInput>
  }

  export type equipment_bookingUpdateManyWithWhereWithoutEquipmentInput = {
    where: equipment_bookingScalarWhereInput
    data: XOR<equipment_bookingUpdateManyMutationInput, equipment_bookingUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type equipment_bookingScalarWhereInput = {
    AND?: equipment_bookingScalarWhereInput | equipment_bookingScalarWhereInput[]
    OR?: equipment_bookingScalarWhereInput[]
    NOT?: equipment_bookingScalarWhereInput | equipment_bookingScalarWhereInput[]
    id?: IntFilter<"equipment_booking"> | number
    user_id?: IntFilter<"equipment_booking"> | number
    equipment_id?: IntFilter<"equipment_booking"> | number
    booking_date?: DateTimeFilter<"equipment_booking"> | Date | string
    period_time?: IntFilter<"equipment_booking"> | number
    member_status?: IntFilter<"equipment_booking"> | number
    example?: StringNullableFilter<"equipment_booking"> | string | null
    prefix?: StringNullableFilter<"equipment_booking"> | string | null
    firstname?: StringNullableFilter<"equipment_booking"> | string | null
    surname?: StringNullableFilter<"equipment_booking"> | string | null
    organization?: StringNullableFilter<"equipment_booking"> | string | null
    contact_address?: StringNullableFilter<"equipment_booking"> | string | null
    phone?: StringNullableFilter<"equipment_booking"> | string | null
    email?: StringNullableFilter<"equipment_booking"> | string | null
    invoice_address?: StringNullableFilter<"equipment_booking"> | string | null
    tax_id?: StringNullableFilter<"equipment_booking"> | string | null
    price?: IntNullableFilter<"equipment_booking"> | number | null
    reject_comment?: StringNullableFilter<"equipment_booking"> | string | null
    confirmed_date?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    status_id?: IntFilter<"equipment_booking"> | number
    is_active?: IntFilter<"equipment_booking"> | number
    is_publish?: IntFilter<"equipment_booking"> | number
    created_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_booking"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_booking"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_booking"> | Date | string | null
  }

  export type equipmentCreateWithoutEquipment_methodInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_category: equipment_categoryCreateNestedOneWithoutEquipmentsInput
    equipment_department: equipment_departmentCreateNestedOneWithoutEquipmentsInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUncheckedCreateWithoutEquipment_methodInput = {
    id?: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentCreateOrConnectWithoutEquipment_methodInput = {
    where: equipmentWhereUniqueInput
    create: XOR<equipmentCreateWithoutEquipment_methodInput, equipmentUncheckedCreateWithoutEquipment_methodInput>
  }

  export type equipment_booking_methodCreateWithoutEquipment_methodInput = {
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking: equipment_bookingCreateNestedOneWithoutEquipment_booking_methodInput
  }

  export type equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput = {
    id?: number
    equipment_booking_id: number
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_booking_methodCreateOrConnectWithoutEquipment_methodInput = {
    where: equipment_booking_methodWhereUniqueInput
    create: XOR<equipment_booking_methodCreateWithoutEquipment_methodInput, equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput>
  }

  export type equipment_booking_methodCreateManyEquipment_methodInputEnvelope = {
    data: equipment_booking_methodCreateManyEquipment_methodInput | equipment_booking_methodCreateManyEquipment_methodInput[]
    skipDuplicates?: boolean
  }

  export type equipmentUpsertWithoutEquipment_methodInput = {
    update: XOR<equipmentUpdateWithoutEquipment_methodInput, equipmentUncheckedUpdateWithoutEquipment_methodInput>
    create: XOR<equipmentCreateWithoutEquipment_methodInput, equipmentUncheckedCreateWithoutEquipment_methodInput>
    where?: equipmentWhereInput
  }

  export type equipmentUpdateToOneWithWhereWithoutEquipment_methodInput = {
    where?: equipmentWhereInput
    data: XOR<equipmentUpdateWithoutEquipment_methodInput, equipmentUncheckedUpdateWithoutEquipment_methodInput>
  }

  export type equipmentUpdateWithoutEquipment_methodInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_category?: equipment_categoryUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_department?: equipment_departmentUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateWithoutEquipment_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_category_id?: IntFieldUpdateOperationsInput | number
    equipment_department_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_methodInput = {
    where: equipment_booking_methodWhereUniqueInput
    update: XOR<equipment_booking_methodUpdateWithoutEquipment_methodInput, equipment_booking_methodUncheckedUpdateWithoutEquipment_methodInput>
    create: XOR<equipment_booking_methodCreateWithoutEquipment_methodInput, equipment_booking_methodUncheckedCreateWithoutEquipment_methodInput>
  }

  export type equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_methodInput = {
    where: equipment_booking_methodWhereUniqueInput
    data: XOR<equipment_booking_methodUpdateWithoutEquipment_methodInput, equipment_booking_methodUncheckedUpdateWithoutEquipment_methodInput>
  }

  export type equipment_booking_methodUpdateManyWithWhereWithoutEquipment_methodInput = {
    where: equipment_booking_methodScalarWhereInput
    data: XOR<equipment_booking_methodUpdateManyMutationInput, equipment_booking_methodUncheckedUpdateManyWithoutEquipment_methodInput>
  }

  export type equipment_booking_methodScalarWhereInput = {
    AND?: equipment_booking_methodScalarWhereInput | equipment_booking_methodScalarWhereInput[]
    OR?: equipment_booking_methodScalarWhereInput[]
    NOT?: equipment_booking_methodScalarWhereInput | equipment_booking_methodScalarWhereInput[]
    id?: IntFilter<"equipment_booking_method"> | number
    equipment_booking_id?: IntFilter<"equipment_booking_method"> | number
    equipment_method_id?: IntFilter<"equipment_booking_method"> | number
    quantity?: IntNullableFilter<"equipment_booking_method"> | number | null
    price?: IntNullableFilter<"equipment_booking_method"> | number | null
    is_active?: IntFilter<"equipment_booking_method"> | number
    is_publish?: IntFilter<"equipment_booking_method"> | number
    created_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    created_by?: StringNullableFilter<"equipment_booking_method"> | string | null
    updated_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
    updated_by?: StringNullableFilter<"equipment_booking_method"> | string | null
    deleted_at?: DateTimeNullableFilter<"equipment_booking_method"> | Date | string | null
  }

  export type userCreateWithoutGroupInput = {
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    profile?: profileCreateNestedOneWithoutUserInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutGroupInput = {
    id?: number
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutGroupInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGroupInput, userUncheckedCreateWithoutGroupInput>
  }

  export type userCreateManyGroupInputEnvelope = {
    data: userCreateManyGroupInput | userCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithWhereUniqueWithoutGroupInput = {
    where: userWhereUniqueInput
    update: XOR<userUpdateWithoutGroupInput, userUncheckedUpdateWithoutGroupInput>
    create: XOR<userCreateWithoutGroupInput, userUncheckedCreateWithoutGroupInput>
  }

  export type userUpdateWithWhereUniqueWithoutGroupInput = {
    where: userWhereUniqueInput
    data: XOR<userUpdateWithoutGroupInput, userUncheckedUpdateWithoutGroupInput>
  }

  export type userUpdateManyWithWhereWithoutGroupInput = {
    where: userScalarWhereInput
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyWithoutGroupInput>
  }

  export type userScalarWhereInput = {
    AND?: userScalarWhereInput | userScalarWhereInput[]
    OR?: userScalarWhereInput[]
    NOT?: userScalarWhereInput | userScalarWhereInput[]
    id?: IntFilter<"user"> | number
    group_id?: IntFilter<"user"> | number
    email?: StringFilter<"user"> | string
    secret_confirm_email?: StringNullableFilter<"user"> | string | null
    password?: StringNullableFilter<"user"> | string | null
    status?: IntFilter<"user"> | number
    is_active?: IntFilter<"user"> | number
    is_publish?: IntFilter<"user"> | number
    created_at?: DateTimeNullableFilter<"user"> | Date | string | null
    created_by?: StringNullableFilter<"user"> | string | null
    updated_at?: DateTimeNullableFilter<"user"> | Date | string | null
    updated_by?: StringNullableFilter<"user"> | string | null
    deleted_at?: DateTimeNullableFilter<"user"> | Date | string | null
  }

  export type groupCreateWithoutUsersInput = {
    title_th: string
    title_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type groupUncheckedCreateWithoutUsersInput = {
    id?: number
    title_th: string
    title_en?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type groupCreateOrConnectWithoutUsersInput = {
    where: groupWhereUniqueInput
    create: XOR<groupCreateWithoutUsersInput, groupUncheckedCreateWithoutUsersInput>
  }

  export type profileCreateWithoutUserInput = {
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    member_status: number
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_name?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type profileUncheckedCreateWithoutUserInput = {
    id?: number
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    member_status: number
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_name?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type profileCreateOrConnectWithoutUserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type equipment_bookingCreateWithoutUserInput = {
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment: equipmentCreateNestedOneWithoutEquipment_bookingInput
    equipment_booking_method?: equipment_booking_methodCreateNestedManyWithoutEquipment_bookingInput
  }

  export type equipment_bookingUncheckedCreateWithoutUserInput = {
    id?: number
    equipment_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedCreateNestedManyWithoutEquipment_bookingInput
  }

  export type equipment_bookingCreateOrConnectWithoutUserInput = {
    where: equipment_bookingWhereUniqueInput
    create: XOR<equipment_bookingCreateWithoutUserInput, equipment_bookingUncheckedCreateWithoutUserInput>
  }

  export type equipment_bookingCreateManyUserInputEnvelope = {
    data: equipment_bookingCreateManyUserInput | equipment_bookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type groupUpsertWithoutUsersInput = {
    update: XOR<groupUpdateWithoutUsersInput, groupUncheckedUpdateWithoutUsersInput>
    create: XOR<groupCreateWithoutUsersInput, groupUncheckedCreateWithoutUsersInput>
    where?: groupWhereInput
  }

  export type groupUpdateToOneWithWhereWithoutUsersInput = {
    where?: groupWhereInput
    data: XOR<groupUpdateWithoutUsersInput, groupUncheckedUpdateWithoutUsersInput>
  }

  export type groupUpdateWithoutUsersInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileUpsertWithoutUserInput = {
    update: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    where?: profileWhereInput
  }

  export type profileUpdateToOneWithWhereWithoutUserInput = {
    where?: profileWhereInput
    data: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateWithoutUserInput = {
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    member_status?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type profileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    member_status?: IntFieldUpdateOperationsInput | number
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_name?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_bookingUpsertWithWhereUniqueWithoutUserInput = {
    where: equipment_bookingWhereUniqueInput
    update: XOR<equipment_bookingUpdateWithoutUserInput, equipment_bookingUncheckedUpdateWithoutUserInput>
    create: XOR<equipment_bookingCreateWithoutUserInput, equipment_bookingUncheckedCreateWithoutUserInput>
  }

  export type equipment_bookingUpdateWithWhereUniqueWithoutUserInput = {
    where: equipment_bookingWhereUniqueInput
    data: XOR<equipment_bookingUpdateWithoutUserInput, equipment_bookingUncheckedUpdateWithoutUserInput>
  }

  export type equipment_bookingUpdateManyWithWhereWithoutUserInput = {
    where: equipment_bookingScalarWhereInput
    data: XOR<equipment_bookingUpdateManyMutationInput, equipment_bookingUncheckedUpdateManyWithoutUserInput>
  }

  export type userCreateWithoutProfileInput = {
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    group: groupCreateNestedOneWithoutUsersInput
    equipment_booking?: equipment_bookingCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfileInput = {
    id?: number
    group_id: number
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_booking?: equipment_bookingUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfileInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type userUpsertWithoutProfileInput = {
    update: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutProfileInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
  }

  export type userUpdateWithoutProfileInput = {
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: groupUpdateOneRequiredWithoutUsersNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutEquipment_bookingInput = {
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    group: groupCreateNestedOneWithoutUsersInput
    profile?: profileCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutEquipment_bookingInput = {
    id?: number
    group_id: number
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
  }

  export type userCreateOrConnectWithoutEquipment_bookingInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEquipment_bookingInput, userUncheckedCreateWithoutEquipment_bookingInput>
  }

  export type equipmentCreateWithoutEquipment_bookingInput = {
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_category: equipment_categoryCreateNestedOneWithoutEquipmentsInput
    equipment_department: equipment_departmentCreateNestedOneWithoutEquipmentsInput
    equipment_method?: equipment_methodCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentUncheckedCreateWithoutEquipment_bookingInput = {
    id?: number
    equipment_category_id: number
    equipment_department_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_method?: equipment_methodUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type equipmentCreateOrConnectWithoutEquipment_bookingInput = {
    where: equipmentWhereUniqueInput
    create: XOR<equipmentCreateWithoutEquipment_bookingInput, equipmentUncheckedCreateWithoutEquipment_bookingInput>
  }

  export type equipment_booking_methodCreateWithoutEquipment_bookingInput = {
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_method: equipment_methodCreateNestedOneWithoutEquipment_booking_methodInput
  }

  export type equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput = {
    id?: number
    equipment_method_id: number
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_booking_methodCreateOrConnectWithoutEquipment_bookingInput = {
    where: equipment_booking_methodWhereUniqueInput
    create: XOR<equipment_booking_methodCreateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput>
  }

  export type equipment_booking_methodCreateManyEquipment_bookingInputEnvelope = {
    data: equipment_booking_methodCreateManyEquipment_bookingInput | equipment_booking_methodCreateManyEquipment_bookingInput[]
    skipDuplicates?: boolean
  }

  export type userUpsertWithoutEquipment_bookingInput = {
    update: XOR<userUpdateWithoutEquipment_bookingInput, userUncheckedUpdateWithoutEquipment_bookingInput>
    create: XOR<userCreateWithoutEquipment_bookingInput, userUncheckedCreateWithoutEquipment_bookingInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutEquipment_bookingInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutEquipment_bookingInput, userUncheckedUpdateWithoutEquipment_bookingInput>
  }

  export type userUpdateWithoutEquipment_bookingInput = {
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    group?: groupUpdateOneRequiredWithoutUsersNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEquipment_bookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type equipmentUpsertWithoutEquipment_bookingInput = {
    update: XOR<equipmentUpdateWithoutEquipment_bookingInput, equipmentUncheckedUpdateWithoutEquipment_bookingInput>
    create: XOR<equipmentCreateWithoutEquipment_bookingInput, equipmentUncheckedCreateWithoutEquipment_bookingInput>
    where?: equipmentWhereInput
  }

  export type equipmentUpdateToOneWithWhereWithoutEquipment_bookingInput = {
    where?: equipmentWhereInput
    data: XOR<equipmentUpdateWithoutEquipment_bookingInput, equipmentUncheckedUpdateWithoutEquipment_bookingInput>
  }

  export type equipmentUpdateWithoutEquipment_bookingInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_category?: equipment_categoryUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_department?: equipment_departmentUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_method?: equipment_methodUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateWithoutEquipment_bookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_category_id?: IntFieldUpdateOperationsInput | number
    equipment_department_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_method?: equipment_methodUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type equipment_booking_methodUpsertWithWhereUniqueWithoutEquipment_bookingInput = {
    where: equipment_booking_methodWhereUniqueInput
    update: XOR<equipment_booking_methodUpdateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedUpdateWithoutEquipment_bookingInput>
    create: XOR<equipment_booking_methodCreateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedCreateWithoutEquipment_bookingInput>
  }

  export type equipment_booking_methodUpdateWithWhereUniqueWithoutEquipment_bookingInput = {
    where: equipment_booking_methodWhereUniqueInput
    data: XOR<equipment_booking_methodUpdateWithoutEquipment_bookingInput, equipment_booking_methodUncheckedUpdateWithoutEquipment_bookingInput>
  }

  export type equipment_booking_methodUpdateManyWithWhereWithoutEquipment_bookingInput = {
    where: equipment_booking_methodScalarWhereInput
    data: XOR<equipment_booking_methodUpdateManyMutationInput, equipment_booking_methodUncheckedUpdateManyWithoutEquipment_bookingInput>
  }

  export type equipment_bookingCreateWithoutEquipment_booking_methodInput = {
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    user: userCreateNestedOneWithoutEquipment_bookingInput
    equipment: equipmentCreateNestedOneWithoutEquipment_bookingInput
  }

  export type equipment_bookingUncheckedCreateWithoutEquipment_booking_methodInput = {
    id?: number
    user_id: number
    equipment_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_bookingCreateOrConnectWithoutEquipment_booking_methodInput = {
    where: equipment_bookingWhereUniqueInput
    create: XOR<equipment_bookingCreateWithoutEquipment_booking_methodInput, equipment_bookingUncheckedCreateWithoutEquipment_booking_methodInput>
  }

  export type equipment_methodCreateWithoutEquipment_booking_methodInput = {
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment: equipmentCreateNestedOneWithoutEquipment_methodInput
  }

  export type equipment_methodUncheckedCreateWithoutEquipment_booking_methodInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
    equipment_id: number
  }

  export type equipment_methodCreateOrConnectWithoutEquipment_booking_methodInput = {
    where: equipment_methodWhereUniqueInput
    create: XOR<equipment_methodCreateWithoutEquipment_booking_methodInput, equipment_methodUncheckedCreateWithoutEquipment_booking_methodInput>
  }

  export type equipment_bookingUpsertWithoutEquipment_booking_methodInput = {
    update: XOR<equipment_bookingUpdateWithoutEquipment_booking_methodInput, equipment_bookingUncheckedUpdateWithoutEquipment_booking_methodInput>
    create: XOR<equipment_bookingCreateWithoutEquipment_booking_methodInput, equipment_bookingUncheckedCreateWithoutEquipment_booking_methodInput>
    where?: equipment_bookingWhereInput
  }

  export type equipment_bookingUpdateToOneWithWhereWithoutEquipment_booking_methodInput = {
    where?: equipment_bookingWhereInput
    data: XOR<equipment_bookingUpdateWithoutEquipment_booking_methodInput, equipment_bookingUncheckedUpdateWithoutEquipment_booking_methodInput>
  }

  export type equipment_bookingUpdateWithoutEquipment_booking_methodInput = {
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutEquipment_bookingNestedInput
    equipment?: equipmentUpdateOneRequiredWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingUncheckedUpdateWithoutEquipment_booking_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    equipment_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_methodUpsertWithoutEquipment_booking_methodInput = {
    update: XOR<equipment_methodUpdateWithoutEquipment_booking_methodInput, equipment_methodUncheckedUpdateWithoutEquipment_booking_methodInput>
    create: XOR<equipment_methodCreateWithoutEquipment_booking_methodInput, equipment_methodUncheckedCreateWithoutEquipment_booking_methodInput>
    where?: equipment_methodWhereInput
  }

  export type equipment_methodUpdateToOneWithWhereWithoutEquipment_booking_methodInput = {
    where?: equipment_methodWhereInput
    data: XOR<equipment_methodUpdateWithoutEquipment_booking_methodInput, equipment_methodUncheckedUpdateWithoutEquipment_booking_methodInput>
  }

  export type equipment_methodUpdateWithoutEquipment_booking_methodInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: equipmentUpdateOneRequiredWithoutEquipment_methodNestedInput
  }

  export type equipment_methodUncheckedUpdateWithoutEquipment_booking_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_id?: IntFieldUpdateOperationsInput | number
  }

  export type newsCreateManyNews_typeInput = {
    id?: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    news_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_news: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type newsUpdateWithoutNews_typeInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsUncheckedUpdateWithoutNews_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type newsUncheckedUpdateManyWithoutNews_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    news_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_news?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamCreateManyDepartmentInput = {
    id?: number
    prefix_th?: string | null
    prefix_en?: string | null
    firstname_th?: string | null
    firstname_en?: string | null
    surname_th?: string | null
    surname_en?: string | null
    position_th?: string | null
    position_en?: string | null
    position_level_th?: string | null
    position_level_en?: string | null
    phone: string
    email: string
    level: number
    team_file?: string | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type teamUpdateWithoutDepartmentInput = {
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamUncheckedUpdateWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type teamUncheckedUpdateManyWithoutDepartmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    prefix_th?: NullableStringFieldUpdateOperationsInput | string | null
    prefix_en?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_th?: NullableStringFieldUpdateOperationsInput | string | null
    firstname_en?: NullableStringFieldUpdateOperationsInput | string | null
    surname_th?: NullableStringFieldUpdateOperationsInput | string | null
    surname_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_en?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_th?: NullableStringFieldUpdateOperationsInput | string | null
    position_level_en?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    team_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipmentCreateManyEquipment_departmentInput = {
    id?: number
    equipment_category_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipmentUpdateWithoutEquipment_departmentInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_category?: equipment_categoryUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_method?: equipment_methodUpdateManyWithoutEquipmentNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateWithoutEquipment_departmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_category_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_method?: equipment_methodUncheckedUpdateManyWithoutEquipmentNestedInput
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateManyWithoutEquipment_departmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_category_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipmentCreateManyEquipment_categoryInput = {
    id?: number
    equipment_department_id: number
    title_th: string
    title_en?: string | null
    detail_th?: string | null
    detail_en?: string | null
    equipment_file?: string | null
    rate_file?: string | null
    is_active?: number
    is_publish?: number
    count_views?: number
    created_equipment: Date | string
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipmentUpdateWithoutEquipment_categoryInput = {
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_department?: equipment_departmentUpdateOneRequiredWithoutEquipmentsNestedInput
    equipment_method?: equipment_methodUpdateManyWithoutEquipmentNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateWithoutEquipment_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_department_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_method?: equipment_methodUncheckedUpdateManyWithoutEquipmentNestedInput
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type equipmentUncheckedUpdateManyWithoutEquipment_categoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_department_id?: IntFieldUpdateOperationsInput | number
    title_th?: StringFieldUpdateOperationsInput | string
    title_en?: NullableStringFieldUpdateOperationsInput | string | null
    detail_th?: NullableStringFieldUpdateOperationsInput | string | null
    detail_en?: NullableStringFieldUpdateOperationsInput | string | null
    equipment_file?: NullableStringFieldUpdateOperationsInput | string | null
    rate_file?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    count_views?: IntFieldUpdateOperationsInput | number
    created_equipment?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_methodCreateManyEquipmentInput = {
    id?: number
    name_th: string
    name_en?: string | null
    name_short?: string | null
    unit_th?: string | null
    unit_en?: string | null
    price?: number | null
    is_fixrate?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_bookingCreateManyEquipmentInput = {
    id?: number
    user_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_methodUpdateWithoutEquipmentInput = {
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking_method?: equipment_booking_methodUpdateManyWithoutEquipment_methodNestedInput
  }

  export type equipment_methodUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedUpdateManyWithoutEquipment_methodNestedInput
  }

  export type equipment_methodUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name_th?: StringFieldUpdateOperationsInput | string
    name_en?: NullableStringFieldUpdateOperationsInput | string | null
    name_short?: NullableStringFieldUpdateOperationsInput | string | null
    unit_th?: NullableStringFieldUpdateOperationsInput | string | null
    unit_en?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_fixrate?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_bookingUpdateWithoutEquipmentInput = {
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: userUpdateOneRequiredWithoutEquipment_bookingNestedInput
    equipment_booking_method?: equipment_booking_methodUpdateManyWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedUpdateManyWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodCreateManyEquipment_methodInput = {
    id?: number
    equipment_booking_id: number
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_booking_methodUpdateWithoutEquipment_methodInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking?: equipment_bookingUpdateOneRequiredWithoutEquipment_booking_methodNestedInput
  }

  export type equipment_booking_methodUncheckedUpdateWithoutEquipment_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_booking_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodUncheckedUpdateManyWithoutEquipment_methodInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_booking_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userCreateManyGroupInput = {
    id?: number
    email: string
    secret_confirm_email?: string | null
    password?: string | null
    status?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type userUpdateWithoutGroupInput = {
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUpdateOneWithoutUserNestedInput
    equipment_booking?: equipment_bookingUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    equipment_booking?: equipment_bookingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateManyWithoutGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    secret_confirm_email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_bookingCreateManyUserInput = {
    id?: number
    equipment_id: number
    booking_date: Date | string
    period_time: number
    member_status: number
    example?: string | null
    prefix?: string | null
    firstname?: string | null
    surname?: string | null
    organization?: string | null
    contact_address?: string | null
    phone?: string | null
    email?: string | null
    invoice_address?: string | null
    tax_id?: string | null
    price?: number | null
    reject_comment?: string | null
    confirmed_date?: Date | string | null
    status_id?: number
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_bookingUpdateWithoutUserInput = {
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment?: equipmentUpdateOneRequiredWithoutEquipment_bookingNestedInput
    equipment_booking_method?: equipment_booking_methodUpdateManyWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_booking_method?: equipment_booking_methodUncheckedUpdateManyWithoutEquipment_bookingNestedInput
  }

  export type equipment_bookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_id?: IntFieldUpdateOperationsInput | number
    booking_date?: DateTimeFieldUpdateOperationsInput | Date | string
    period_time?: IntFieldUpdateOperationsInput | number
    member_status?: IntFieldUpdateOperationsInput | number
    example?: NullableStringFieldUpdateOperationsInput | string | null
    prefix?: NullableStringFieldUpdateOperationsInput | string | null
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    surname?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    contact_address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    invoice_address?: NullableStringFieldUpdateOperationsInput | string | null
    tax_id?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    reject_comment?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status_id?: IntFieldUpdateOperationsInput | number
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodCreateManyEquipment_bookingInput = {
    id?: number
    equipment_method_id: number
    quantity?: number | null
    price?: number | null
    is_active?: number
    is_publish?: number
    created_at?: Date | string | null
    created_by?: string | null
    updated_at?: Date | string | null
    updated_by?: string | null
    deleted_at?: Date | string | null
  }

  export type equipment_booking_methodUpdateWithoutEquipment_bookingInput = {
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    equipment_method?: equipment_methodUpdateOneRequiredWithoutEquipment_booking_methodNestedInput
  }

  export type equipment_booking_methodUncheckedUpdateWithoutEquipment_bookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_method_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type equipment_booking_methodUncheckedUpdateManyWithoutEquipment_bookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    equipment_method_id?: IntFieldUpdateOperationsInput | number
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    is_active?: IntFieldUpdateOperationsInput | number
    is_publish?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_by?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}